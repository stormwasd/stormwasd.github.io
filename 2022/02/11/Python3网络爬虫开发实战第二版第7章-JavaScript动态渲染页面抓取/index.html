<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Lhj">
    
    <title>
        
            Python3网络爬虫开发实战第二版第7章-JavaScript动态渲染页面抓取 |
        
        Alexander
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Alexander
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                NOTE
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">NOTE</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Python3网络爬虫开发实战第二版第7章-JavaScript动态渲染页面抓取</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Lhj</span>
                        
                            <span class="author-label">Lv6</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-02-11 10:09:30</span>
        <span class="mobile">2022-02-11 10:09</span>
    </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>16.6k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>71 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>在第5章中，我们了解了Ajax数据的分析和爬取方式，其实这也是JavaScript动态渲染页面的一种情形，通过直接分析Ajax，使我们仍然可以借助request或urllib实现数据爬取，不过JavaScript动态渲染不止Ajax一种，有些页面的分页部分由JavaScript生成，而非原始HTML代码，这其中并不包含Ajax请求；如Echarts的<a class="link"   target="_blank" rel="noopener" href="http://echarts.baidu.com/demo.html" >官方实例<i class="fas fa-external-link-alt"></i></a>，其图形都是经过JavaScript计算之后生成的，还有类似淘宝这种页面，即使是Ajax获取的数据，其Ajax接口中也含有很多加密参数，使我们很难直接找出规律</p>
<p>为了解决这些问题，我们可以直接模拟浏览器运行，然后爬取数据，这样就能做到在浏览器中看到的内容是什么样，爬取的源码就是什么样—所见即所爬；此时我们无需去管网页内部的JavaScript使用什么算法渲染页面，也不用管网页后台的Ajax接口到底还有哪些参数</p>
<p>Python提供了很多模拟浏览器运行的库，例如Selenium、Splash、Pyppeter、Playwright等，我们可以借助这些库来完成爬取动态渲染的页面</p>
<h3 id="Selenium的使用"><a href="#Selenium的使用" class="headerlink" title="Selenium的使用"></a>Selenium的使用</h3><p>很多情况下，Ajax的请求接口会含有加密参数，例如token、sing等，由于请求Ajax接口时必须加上token等参数，因此如果深入分析并找到token等参数的构造逻辑，是很难模拟Ajax请求的</p>
<p>方法通常有两种:</p>
<ul>
<li>深挖其中的逻辑，把token参数的构造逻辑完全找出来，再用Python代码实现</li>
<li>模拟浏览器的运行，爬取数据</li>
</ul>
<p>Selenium是一个自动化测试工具，利用它可以驱动浏览器完成特定的操作，例如点击，下拉等，还可以获取浏览器当前呈现的页面的源代码，做到所见即所爬，对于一些JavaScript动态渲染的页面，这种爬取方式非常有效</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li>安装Chrome浏览器</li>
<li>安装Selenium这个包</li>
<li>安装并配置好ChormDriver这个驱动</li>
</ul>
<p>具体准备工作各个模块的安装步骤，可参见: <a class="link"   target="_blank" rel="noopener" href="https://setup.scrape.center/selenium" >https://setup.scrape.center/selenium<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>我们首先大体来看看Selenium的功能:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    <span class="built_in">input</span> = browser.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>)  <span class="comment"># 找到这个元素</span></span><br><span class="line">    <span class="built_in">input</span>.send_keys(<span class="string">&#x27;Python&#x27;</span>)  <span class="comment"># 相当于在搜索框中键入Python</span></span><br><span class="line">    <span class="built_in">input</span>.send_keys(Keys.ENTER)  <span class="comment"># 相当于点击搜索键</span></span><br><span class="line">    wait = WebDriverWait(browser, <span class="number">10</span>)  <span class="comment"># 给浏览器一定的加载时间，不然会出错</span></span><br><span class="line">    wait.until(EC.presence_of_element_located((By.ID, <span class="string">&#x27;content_left&#x27;</span>)))</span><br><span class="line">    <span class="built_in">print</span>(browser.current_url)  <span class="comment"># 输出浏览器当前所处理的url</span></span><br><span class="line">    <span class="built_in">print</span>(browser.get_cookies())  <span class="comment"># 输出当前的Cookie</span></span><br><span class="line">    <span class="built_in">print</span>(browser.page_source)  <span class="comment"># 输出网页源代码</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()  <span class="comment"># 关闭浏览器</span></span><br></pre></td></tr></table></figure>

<p>运行以上代码之后会打开一个Chrome浏览器，浏览器会跳转到百度页面，然后在搜索框中输入Python，就会跳转到搜索结果页面:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220208/Snipaste_2022-02-11_11-12-49.3yazzttcewc0.webp"
                      alt="Snipaste_2022-02-11_11-12-49"
                ></p>
<p>下面详细了解下Selenium的用法:</p>
<h4 id="初始化浏览器对象"><a href="#初始化浏览器对象" class="headerlink" title="初始化浏览器对象"></a>初始化浏览器对象</h4><p>我们可以用如下方式初始化浏览器对象:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> Webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser = webdriver.Safari()</span><br></pre></td></tr></table></figure>

<h4 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> Webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.page_source)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<p>以上代码弹出浏览器并且自动访问了淘宝，打印了页面代码之后关闭浏览器</p>
<h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><h5 id="单个节点"><a href="#单个节点" class="headerlink" title="单个节点"></a>单个节点</h5><p>我们要想从淘宝页面中提取搜索框这个节点，首先就要观察这个页面的源代码，我们发现淘宝页面输入框的id属性值是q，name属性值也是q，此外，还有许多其他属性，我们可以用多种方式获取它们，例如<code>find_element_by_name</code>是根据name属性获取，<code>find_element_by_id</code>是根据id属性获取，此外还有更新Xpth、CSS选择器等的获取方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">&#x27;q&#x27;</span>)  <span class="comment"># 根据name属性获取</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">&#x27;#q&#x27;</span>)  <span class="comment"># 用CSS选择器方式</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;q&quot;]&#x27;</span>)  <span class="comment"># 用Xpth方式</span></span><br><span class="line"><span class="built_in">print</span>(input_first, input_second, input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<p>获取单个节点可以使用如下方式:</p>
<ul>
<li>find_element_by_id()</li>
<li>find_element_by_name()</li>
<li>find_element_by_xpath()</li>
<li>find_element_by_link_text()</li>
<li>find_element_by_partial_link_text()</li>
<li>find_element_by_tag_name()</li>
<li>find_element_by_class_name()</li>
<li>find_element_by_css_selector</li>
</ul>
<p>除了上述方法，Selenium还提供了通用方法find_element()，比如find_element_by_id(id)就等价于find_element(By.ID, id)，我们来看下实例代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line">input_first = browser.find_element(By.ID, <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(input_first)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h5 id="多个节点"><a href="#多个节点" class="headerlink" title="多个节点"></a>多个节点</h5><p>单个节点使用find_element()，如果目标节点是多个，那就使用find_elements()，首先我们同样来看看单个方法的方式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">&#x27;.service-bd li&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<p>以上返回的节点都是WebElement类型，使用find_elements_by…就可返回多个节点，获取多个节点可以使用方式:</p>
<ul>
<li>find_elements_by_id()</li>
<li>find_elements_by_name()</li>
<li>find_elements_by_xpath()</li>
<li>find_elements_by_link_text()</li>
<li>find_elements_by_partial_link_text()</li>
<li>find_elements_by_tag_name()</li>
<li>find_elements_by_class_name()</li>
<li>find_elements_by_css_selector</li>
</ul>
<p>同样的，我们也可直接使用find_elements()，以上代码可以改写为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lis = browser.find_elements(By.CSS_SELECTO<span class="string">R&#x27;.service-bd li&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h4><p>Selenium可以驱动浏览器执行一些操作，比较常见的用法有:用send_keys()输入文字，用clear()清空文字，用click()点击按钮，实例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element_by_id(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&#x27;iPhone&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">input</span>.clear()</span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&#x27;iPad&#x27;</span>)</span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">&#x27;btn-search&#x27;</span>)</span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure>

<h4 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h4><p>上面提到的都是单个动作，但是我们如果要完成比如鼠标拖拽、键盘按键这些操作时，那就需要用另一种方式执行，那就是动作链</p>
<p>例如，可以这样实现拖拽的动作:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&#x27;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">&#x27;iframeResult&#x27;</span>)  <span class="comment"># 切换frame，因为节点在子页面</span></span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">&#x27;#draggable&#x27;</span>)</span><br><span class="line">target = browser.find_element_by_css_selector(<span class="string">&#x27;#droppable&#x27;</span>)</span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line">actions.perform()  <span class="comment"># 执行</span></span><br></pre></td></tr></table></figure>

<p>由于我的chrome的安装问题这里就不贴案例图片了</p>
<h4 id="运行JavaScript"><a href="#运行JavaScript" class="headerlink" title="运行JavaScript"></a>运行JavaScript</h4><p>还有一些操作，Selenium并没有提供API，例如下拉进度条，这种情况我们就可以模拟运行JavaScript，使用<code>execute_script()</code>可以实现，如下实例所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.zhihu.com/explore&#x27;</span>)</span><br><span class="line">browser.execute_script(<span class="string">&#x27;window.scrollTo(0, document.body.scrollHeight)&#x27;</span>)</span><br><span class="line">browser.execute_script(<span class="string">&#x27;alert(&quot;To Bottom&quot;)&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h4><p>前面我们已经通过page_source获取了网页的源代码，下面就可以使用解析库(正则、Beautiful Soup、pyquery等)从中提取信息了，不过，既然Selenium已经提供了选择节点的方法，返回结果是WebElemet类型，那么它肯定也有相关的方法和属性用来直接获取节点信息，我们来看看:</p>
<ul>
<li><p>获取属性</p>
<p>可以使用get_attribute方法获取节点的属性，但前提是得先选中这个节点:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&#x27;https://dynamic2.scrape.cuiqingcai.com/&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">&#x27;logo-image&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(logo)</span><br><span class="line"><span class="built_in">print</span>(logo.get_attribute(<span class="string">&#x27;src&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>获取文本值</p>
<p>可以使用text属性获取文本值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&#x27;https://dynamic2.scrape.cuiqingcai.com/&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element_by_class_name(<span class="string">&#x27;logo-title&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.text)</span><br></pre></td></tr></table></figure></li>
<li><p>获取ID、位置、标签名和大小</p>
<p>除了属性和文本值，WebElemet节点还有一些其他属性，例如id属性用于获取节点ID，location属性用于获取节点在页面中的相对位置，tag_name属性用于获取标签的名称，size属性用于获取节点的大小，也就是宽高，有些时候这些属性还是挺重要的，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&#x27;https://dynamic2.scrape.cuiqingcai.com/&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element_by_class_name(<span class="string">&#x27;logo-title&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.location)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.tag_name)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.size)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="切换Frame"><a href="#切换Frame" class="headerlink" title="切换Frame"></a>切换Frame</h4><p>我们知道网页中有一种节点叫做iframe，也就是子Frame，相当于页面的子页面，它的结构和外部网页的结构完全一致，Selenimu打开一个页面后，默认是在父页面里操作，此时这个页面中如果还有子Frame，它是不能获取子Frame里的节点的，这时就需要使用<code>switch_to.frame</code>方法切换Frame，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&#x27;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">&#x27;iframeResult&#x27;</span>)  <span class="comment"># 切换到子Frame中</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logo = browser.find_element_by_class_name(<span class="string">&#x27;logo&#x27;</span>)  <span class="comment">#尝试获取其中的logo节点</span></span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:  <span class="comment"># 如果没找到logo节点就会抛出异常(这边实际上是没有的)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;NO LOGO&#x27;</span>)</span><br><span class="line">browser.switch_to.parent_frame()  <span class="comment"># 切换回父Frame</span></span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">&#x27;logo&#x27;</span>)  <span class="comment"># 重新获取logo</span></span><br><span class="line"><span class="built_in">print</span>(logo)</span><br><span class="line"><span class="built_in">print</span>(logo.text)</span><br></pre></td></tr></table></figure>

<h4 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h4><p>在Selenium中，get方法在网页框架加载完毕之后才会结束执行，如果我们在get方法执行完毕时获取网页源代码，其结果可能并不是浏览器完全加载完成的页面，因为某些页面有额外的Ajax请求，页面还会经由JavaScript渲染，所以，在必要的时候，我们需要设置浏览器延时等待一段时间，确保节点已经加载出来</p>
<p>这里方式有两种，一种是隐式等待，一种是显式等待</p>
<ul>
<li><p>隐式等待</p>
<p>使用隐式等待执行测试时，如果Selenium没有在DOM中找到节点，将继续等待，在超出设定时间后，将抛出找不到节点的异常，默认的等待时间是0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">browser.get(<span class="string">&#x27;https://dynamic2.scrape.cuiqingcai.com/&#x27;</span>)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element_by_class_name(<span class="string">&#x27;logo-image&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>显式等待</p>
</li>
</ul>
<p>隐式等待的效果其实不太好，因为我们只规定了一个固定的时间，而页面的加载时间会受网络条件影响，还有一种方式就是显式等待，这种方式会指定要查找的节点和最长等待时间，如果在规定的时间内加载出了要查找的节点，就返回这个节点，如果到了规定的时间依然没有加载出节点，就抛出超时异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com/&#x27;</span>)</span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">input</span> = wait.until(EC.presence_of_element_located((By.ID, <span class="string">&#x27;q&#x27;</span>)))</span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">&#x27;.btn-search&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>, button)</span><br></pre></td></tr></table></figure>

<p>这里首先引入WebDriver对象，指定最长等待时间为10，并赋值给wait变量，然后调用wait的until方法，传入等待条件；这里先传入了presence_of_element_located这个条件，代表节点出现，其参数是节点的定位元组(By.ID, ‘q’)；然后传入的等待条件是element_to_be_clickable，代表按钮可点击，其参数是利用css查找的定位元组(By.CSS_SELECTOR, ‘.btn-search’)</p>
<p>更多的等待条件可以见书本</p>
<h4 id="前进和后退"><a href="#前进和后退" class="headerlink" title="前进和后退"></a>前进和后退</h4><p>使用froword方法前进，使用back方法后退，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com/&#x27;</span>)</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.python.org/&#x27;</span>)</span><br><span class="line">browser.back()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.forward()</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<p>这里我们打开了3个页面，然后调用back方法回到第2个页面，接着调用forword方法又前进到第3个页面</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>使用Selenium，还可以方便地对Cookie进行操作，例如获取、添加、删除等，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.zhihu.com/explore&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())  <span class="comment"># 获取</span></span><br><span class="line">browser.add_cookie(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;www.zhihu.com&#x27;</span>, <span class="string">&#x27;value&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>&#125;)  <span class="comment"># 添加</span></span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())</span><br><span class="line">browser.delete_all_cookies()  <span class="comment"># 删除</span></span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())</span><br></pre></td></tr></table></figure>

<h4 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h4><p>在访问网页的时候，会开启一个个选项卡，在selenium中，我们也可以对选项卡做操作，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">browser.execute_script(<span class="string">&#x27;window.open()&#x27;</span>)  <span class="comment"># 开启一个新的选项卡</span></span><br><span class="line"><span class="built_in">print</span>(browser.window_handles)</span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">1</span>])  <span class="comment"># 切换到新开的选项卡</span></span><br><span class="line">browser.get(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">0</span>])  <span class="comment"># 回到原来的选项卡</span></span><br><span class="line">browser.get(<span class="string">&#x27;https://python.org&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>在使用Selenium的过程中，难免会遇到一些异常，例如超时、节点未找到等，一旦出现此类异常，程序便不会再继续运行了，此时我们可以使用try…except语句捕获各种异常，NoSuchElementException表示节点未找到</p>
<h4 id="反屏蔽"><a href="#反屏蔽" class="headerlink" title="反屏蔽"></a>反屏蔽</h4><p>现在有很多网站增加了对Selenium的检测，防止一些爬虫的恶意爬取，如果检测到有人使用Selenium打开浏览器，就直接屏蔽，在大多数情况下，检测的基本原理是检测当前浏览器窗口下的window.navigator对象中是否包含webdriver属性，因为在正常使用浏览器时，这个属性应该是undefined，一旦使用了Selenium，它就会给window.navigator对象设置webdriver属性，很多网站就是通过这个JavaScript语句判断是否存在webdriver属性，如果存在就直接屏蔽</p>
<p>一个典型的案例网站<a class="link"   target="_blank" rel="noopener" href="https://antispider.scrape.center/%E5%B0%B1%E6%98%AF%E4%BD%BF%E7%94%A8%E4%B8%8A%E8%BF%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8webdriver%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8Selenium%E7%9B%B4%E6%8E%A5%E7%88%AC%E5%8F%96%E8%AF%A5%E7%BD%91%E7%AB%99%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%BD%91%E7%AB%99%E5%B0%B1%E4%BC%9A%E8%BF%94%E5%9B%9E%60Webdriver" >https://antispider.scrape.center/就是使用上述原理，检测是否存在webdriver属性，如果我们使用Selenium直接爬取该网站的数据，网站就会返回`Webdriver<i class="fas fa-external-link-alt"></i></a> Rrobidden`</p>
<p>这时可能有人会直接使用JavaScript语句把webdriver属性置空不就行了，例如调用execuet_script方法执行这行代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(navigator, <span class="string">&quot;webdriver&quot;</span>, &#123;<span class="attr">get</span>: <span class="function">() =&gt;</span> <span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<p>这行代码确实可以把webdriver属性置空，但execute_script方法是在页面加载完毕之后才调用的，这个时候调用就太晚了，网页早就检测到webdriver属性了，所以这个方法行不通</p>
<p>在Selenium中，可以用CDP(即Chrome Devtools Protocol)，解决这个问题，利用它可以实现在每个页面刚加载的时候就执行JavaScript语句，将webdriver属性置空，另外还可以加入几个选项来隐藏Webdriver提示条和自动化扩展信息，代码实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">option.add_experimental_option(<span class="string">&#x27;useAutomationExtension&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line">browser.execute_cdp_cmd(<span class="string">&#x27;Page.addScriptToEvaluateOnNewDocument&#x27;</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;source&#x27;</span>: <span class="string">&#x27;Object.defineProperty(navigator, &quot;webdriver&quot;, &#123;get: () =&gt; undefined&#125;)&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider1.scrape.cuiqingcai.com/&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在大多数时候，以上方式可以实现Selenium的反屏蔽，但也存在一些特殊网站会对Wdbdriver属性设置更多的特征检测，这种情况下就要具体排查了</p>
<h4 id="无头模式"><a href="#无头模式" class="headerlink" title="无头模式"></a>无头模式</h4><p>在上面的案例中，都会弹出一个浏览器窗口，虽然有助于观察页面的爬取状况，但窗口弹来弹去有时也会造成一些干扰</p>
<p>Chrome浏览器从60版本开始，已经开启了对无头浏览器的支持，即Headless，我们可以借助ChromeOptions对象开启Chrome浏览器的无头模式，代码实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line">browser.set_window_size(<span class="number">1366</span>, <span class="number">768</span>)</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">browser.get_screenshot_as_file(<span class="string">&#x27;preview.png&#x27;</span>)  <span class="comment"># 页面截图</span></span><br></pre></td></tr></table></figure>

<h3 id="Splash的使用"><a href="#Splash的使用" class="headerlink" title="Splash的使用"></a>Splash的使用</h3><p>Splash是一个JavaScript渲染服务，是一个含有HTTP API的轻量级浏览器，它还对接了Python中的Twisted库和QT库，利用它，同样可以爬取动态渲染的页面</p>
<h4 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h4><ul>
<li>异步处理多个网页的渲染过程</li>
<li>获取渲染后页面的源代码或截图</li>
<li>通过关闭图片渲染或者使用Adblock规则的方式加快页面渲染的速度</li>
<li>执行特定的JavaScript脚本</li>
<li>通过Lua脚本控制页面的渲染过程</li>
<li>获取页面渲染的详细过程并以HAR(HTTP Archive)的格式呈现出来</li>
</ul>
<h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h4><p>请确保Splash已经正确安装并可以在本地8050端口上正常运行，安装方法见: <a class="link"   target="_blank" rel="noopener" href="https://setup.scrape.center/splash" >https://setup.scrape.center/splash<i class="fas fa-external-link-alt"></i></a></p>
<p>由于我这工作电脑是win7的，安装docker-desktop比较麻烦，所以这部分还是见书本叭</p>
<h3 id="Pyppeteer的使用"><a href="#Pyppeteer的使用" class="headerlink" title="Pyppeteer的使用"></a>Pyppeteer的使用</h3><p>在前面，我们使用了Selenium，其功能的确非常强大，但很多时候会发现它也有一些不太方便的地方，例如配置环境时，需要先安装好相关浏览器，例如Chrome、Firefox等，然后到官方网站下载对应的驱动，最重要的是得看版本是否对应，另外，如果大规模部署Selenium，一些环境配置问题也是很头疼的，这里我们介绍Selenium的一个替代品: Pyppeteer</p>
<h4 id="Pyppeteer介绍"><a href="#Pyppeteer介绍" class="headerlink" title="Pyppeteer介绍"></a>Pyppeteer介绍</h4><p>PupeteerGoogle基于node.js开发的一个工具，有了它，我们可以利用JavaScript控制Chrome浏览器的一些操作；当然，Puppeteer也可以应用于网络爬虫上，其API极其完善，功能非常强大</p>
<p>Pyppeteer又是什么呢，它其实是Puppeteer的Python版实现，但不是Google开发的，是由一位来自日本的工程师依据Puppeteer的一些功能开发出来的非官方版本</p>
<p>Pyppeteer的背后实际上有一个类似于Chrome的浏览器—-Chromium，它执行一些动作，从而进行网页渲染，总的来说，两款浏览器的内核一样，实现方式也一样，可以看作开发版和正式版，功能上没有太大区别</p>
<p>Pyppeteer就是依赖Chromium浏览器运行的，第一次运行Pyppeteer的时候，没有安装Chroimium浏览器，程序会自动帮我们安装和配置好，免去了琐碎的环境配置等工作，另外，Pyppeteer是基于Python的新特性async实现的，所以它的一些操作执行也支持异步方式，和Selenium相比效率也提高了</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>由于Pyppeteer采用了Python的async机制，所以要求Python版本为3.5以上</p>
<p>安装命令如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyppeteer</span><br></pre></td></tr></table></figure>

<h4 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h4><p>测试网址: <a class="link"   target="_blank" rel="noopener" href="https://spa2.scrape.center/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E5%B7%B2%E7%BB%8F%E5%88%86%E6%9E%90%E8%BF%87%E4%BA%86%E6%95%B4%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%98%AF%E7%94%A8JavaScript%E6%B8%B2%E6%9F%93%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%8C%E4%B8%80%E4%BA%9BAjax%E6%8E%A5%E5%8F%A3%E8%BF%98%E5%B8%A6%E6%9C%89%E5%8A%A0%E5%AF%86%E5%8F%82%E6%95%B0%EF%BC%8C%E6%89%80%E4%BB%A5%E6%B2%A1%E6%B3%95%E7%9B%B4%E6%8E%A5%E7%94%A8requests%E7%88%AC%E5%8F%96%E7%9C%8B%E5%88%B0%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B9%9F%E4%B8%8D%E5%A4%AA%E5%A5%BD%E7%9B%B4%E6%8E%A5%E6%A8%A1%E6%8B%9F%EF%BC%8CAjax%E6%9D%A5%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%9B%E5%9C%A8%E5%89%8D%E9%9D%A2%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AFSelenium%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E8%AF%95%E8%AF%95Pyppeteer" >https://spa2.scrape.center/，这个网站在前面已经分析过了整个页面是用JavaScript渲染出来的，一些Ajax接口还带有加密参数，所以没法直接用requests爬取看到数据，同时也不太好直接模拟，Ajax来获取数据；在前面我们使用的是Selenium，这里我们试试Pyppeteer<i class="fas fa-external-link-alt"></i></a>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch()  <span class="comment"># 调用launch方法新建了一个Browser对象，相当于启动了了浏览器</span></span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()  <span class="comment"># 相当于在浏览器中新建一个选项卡</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://dynamic2.scrape.cuiqingcai.com/&#x27;</span>)  <span class="comment"># 相当于在浏览器中输入goto方法的参数中的URL，之后浏览器加载对应的页面</span></span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">&#x27;.item .name&#x27;</span>)  <span class="comment"># 传入选择器，页面会等待选择器对应的节点信息加载出来后就立即返回，否则持续等待直到超时</span></span><br><span class="line">    doc = pq(<span class="keyword">await</span> page.content())  <span class="comment"># 获取当前浏览器页面的源代码，这就是JavaScript渲染后的结果</span></span><br><span class="line">    names = [item.text() <span class="keyword">for</span> item <span class="keyword">in</span> doc(<span class="string">&#x27;.item .name&#x27;</span>).items()]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Names:&#x27;</span>, names)</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p>相比来说是比Selenium简单点，接下来我们来看看另一个例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line">width, height = <span class="number">1366</span>, <span class="number">768</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch()</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.setViewport(&#123;<span class="string">&#x27;width&#x27;</span>: width, <span class="string">&#x27;height&#x27;</span>: height&#125;)  <span class="comment"># 设置页面窗口大小</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://dynamic2.scrape.cuiqingcai.com/&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(path=<span class="string">&#x27;example.png&#x27;</span>)  <span class="comment"># 保存页面截图</span></span><br><span class="line">    dimensions = <span class="keyword">await</span> page.evaluate(<span class="string">&#x27;&#x27;&#x27;() =&gt; &#123;</span></span><br><span class="line"><span class="string">        return &#123;</span></span><br><span class="line"><span class="string">            width: document.documentElement.clientWidth,</span></span><br><span class="line"><span class="string">            height: document.documentElement.clientHeight,</span></span><br><span class="line"><span class="string">            deviceScaleFactor: window.devicePixelRatio,</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;&#x27;&#x27;&#x27;</span>)  <span class="comment"># 调用evaluate执行JavaScript语句并返回了对应的数据，是一个json格式的对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(dimensions)</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p>在screenshot方法中，我们通过path参数用于传入页面截图的保存路径，另外还可以指定截图的保存格式type、清晰度quality、是否全屏fullpage和裁切clip等参数</p>
<p>Pyppeteer所有的用法都在其官方文档中，我们不用死记硬背，即查即用即可: <a class="link"   target="_blank" rel="noopener" href="https://pyppeteer.github.io/pyppeteer/reference.html" >https://pyppeteer.github.io/pyppeteer/reference.html<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="launch方法"><a href="#launch方法" class="headerlink" title="launch方法"></a>launch方法</h4><p>launch方法相当于双击桌面上的浏览器图标，用于启动浏览器</p>
<p>launch方法的API链接为: <a class="link"   target="_blank" rel="noopener" href="https://pyppeteer.github.io/pyppeteer/reference.html#launcher%EF%BC%8C%E5%85%B7%E4%BD%93%E5%8F%AF%E6%9F%A5%E7%9C%8B%E8%BF%99%E4%B8%AA%E9%93%BE%E6%8E%A5%EF%BC%8C%E4%B9%9F%E5%8F%AF%E7%BB%93%E5%90%88%E4%B9%A6%E6%9C%AC246%E9%A1%B5" >https://pyppeteer.github.io/pyppeteer/reference.html#launcher，具体可查看这个链接，也可结合书本246页<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="无头模式-1"><a href="#无头模式-1" class="headerlink" title="无头模式"></a>无头模式</h4><p>无头模式，launch方法中使用参数<code>headless</code>，将它设置为False就是在启动的时候可以看到界面，反之则看不到，示例代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">await</span> launch(headless=<span class="literal">False</span>)  <span class="comment"># 显示浏览器界面</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><p>调试模式，launch方法中使用参数<code>devtools</code>，将它设置为True就会在开启页面的时候会弹出一个调试窗口，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(devtools=<span class="literal">True</span>)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220208/Snipaste_2022-02-11_17-45-41.34cme8eh1w40.webp"
                      alt="Snipaste_2022-02-11_17-45-41"
                ></p>
<h4 id="禁用提示条"><a href="#禁用提示条" class="headerlink" title="禁用提示条"></a>禁用提示条</h4><p>如上图片所示，有一个提示，’Chrome正受到自动测试软件的控制’，这个提示有点烦人，我们可以使用args参数关闭:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser = <span class="keyword">await</span> launch(devtools=<span class="literal">True</span>, args=[<span class="string">&#x27;--disable-infobars&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="防止检测"><a href="#防止检测" class="headerlink" title="防止检测"></a>防止检测</h4><p>刚刚只是把提示关闭了，有些网站还是能检测到Webdriver属性，不妨拿之前的案例网站<a class="link"   target="_blank" rel="noopener" href="https://antispider1.scrape.center/%E9%AA%8C%E8%AF%81%E4%B8%8B" >https://antispider1.scrape.center/验证下<i class="fas fa-external-link-alt"></i></a>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(devtools=<span class="literal">True</span>, args=[<span class="string">&#x27;--disable-infobars&#x27;</span>])</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://antispider1.scrape.center/&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220208/Snipaste_2022-02-11_17-54-52.su7xyt0cxsw.webp"
                      alt="Snipaste_2022-02-11_17-54-52"
                ></p>
<p>果然就被检测出来了，这说明Pyppeteer开启Chromium后，照样能被检测到Webdriver属性的存在</p>
<p>那么如何规避此问题呢，Pyppeteer的page对象有一个叫做evaluateOneNewDocument的方法，意思是在每次加载网页的时候执行某条语句，这里可以利用它执行隐藏Webdriver属性的命令，代码改写如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(devtools=<span class="literal">True</span>, args=[<span class="string">&#x27;--disable-infobars&#x27;</span>])</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.evaluateOnNewDocument(<span class="string">&#x27;Object.defineProperty(navigator, &quot;webdriver&quot;, &#123;get: () =&gt; undefined&#125;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://antispider1.scrape.center/&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p>这样就加载出来了:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220208/Snipaste_2022-02-11_18-00-58.4njbw2rykqg0.webp"
                      alt="Snipaste_2022-02-11_18-00-58"
                ></p>
<h4 id="页面大小设置"><a href="#页面大小设置" class="headerlink" title="页面大小设置"></a>页面大小设置</h4><p>这时我们可以设置窗口大小，调用Page对象的setViewport方法即可，代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line">width, height = <span class="number">1366</span>, <span class="number">768</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=<span class="literal">False</span>, args=[<span class="string">&#x27;--disable-infobars&#x27;</span>, <span class="string">f&#x27;--window-size=<span class="subst">&#123;width&#125;</span>,<span class="subst">&#123;height&#125;</span>&#x27;</span>])  <span class="comment"># 这里设置了浏览器的宽高</span></span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.setViewport(&#123;<span class="string">&#x27;width&#x27;</span>: width, <span class="string">&#x27;height&#x27;</span>: height&#125;)  <span class="comment"># 这里设置了显示区域的宽高</span></span><br><span class="line">    <span class="keyword">await</span> page.evaluateOnNewDocument(<span class="string">&#x27;Object.defineProperty(navigator, &quot;webdriver&quot;, &#123;get: () =&gt; undefined&#125;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://antispider1.scrape.cuiqingcai.com/&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p>这里我们同时设置了浏览器窗口的宽高以及显示区域的宽高，让二者保持一致</p>
<h4 id="用户数据持久化"><a href="#用户数据持久化" class="headerlink" title="用户数据持久化"></a>用户数据持久化</h4><p>我们发现，每次打开Pyppeteer都是一个新的空白的浏览器，如果网页需要登录，那么下次打开同样需要登录，这是因为它默认没保存cookie，既然要下次还处于登录状态，那么就是需要存储一些数据，那么这些数据保存到哪里呢？答案是用户目录下，其中不仅包括浏览器的基本配置信息，还包括一些Cache、cookie等信息，如果我们能在浏览器启动的时候读取这些信息，就可恢复一些历史记录甚至登录状态信息了，那么如何设置用户目录呢？很简单，在启动浏览器的时候设置userDataDir属性就好了，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line">width, height = <span class="number">1366</span>, <span class="number">768</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=<span class="literal">False</span>, userDataDir=<span class="string">&#x27;./userdata&#x27;</span>,</span><br><span class="line">                           args=[<span class="string">&#x27;--disable-infobars&#x27;</span>, <span class="string">f&#x27;--window-size=<span class="subst">&#123;width&#125;</span>,<span class="subst">&#123;height&#125;</span>&#x27;</span>])</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.setViewport(&#123;<span class="string">&#x27;width&#x27;</span>: width, <span class="string">&#x27;height&#x27;</span>: height&#125;)</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<h4 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h4><p>我们了解了launch方法，它的返回值是一个Browser对象，也就是浏览器对象，我们通常会将其赋值给browser变量，它就是Browser的一个实例，browser作为Browser的实例，自然有很多用于操作浏览器的方法，下面我们选取一些比较有用的方法介绍下:</p>
<h4 id="开启无痕模式"><a href="#开启无痕模式" class="headerlink" title="开启无痕模式"></a>开启无痕模式</h4><p>我们知道Chrome浏览器有无痕模式，其好处就是环境比较干净，不与其他浏览器示例共享Cache、cookie等内容，可以通过createIncognitoBrowserContext方法开启无痕模式，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line">width, height = <span class="number">1200</span>, <span class="number">768</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=<span class="literal">False</span>,</span><br><span class="line">                           args=[<span class="string">&#x27;--disable-infobars&#x27;</span>, <span class="string">f&#x27;--window-size=<span class="subst">&#123;width&#125;</span>,<span class="subst">&#123;height&#125;</span>&#x27;</span>])</span><br><span class="line">    context = <span class="keyword">await</span> browser.createIncognitoBrowserContext()</span><br><span class="line">    page = <span class="keyword">await</span> context.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.setViewport(&#123;<span class="string">&#x27;width&#x27;</span>: width, <span class="string">&#x27;height&#x27;</span>: height&#125;)</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>使用close方法关闭浏览器，很多时候会因为忘记关闭浏览器而产生额外的开销</p>
<h4 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h4><p>page即页面，对应一个网页，一个选项卡，下面来看看它的一些常见用法</p>
<ul>
<li><p>选择器</p>
<p>page对象内置了很多用于选取节点的选择器方法，例如<strong>J方法，给它传入一个选择器，就能返回匹配到的第一个节点，等价于querySelector方法</strong>；又如<strong>JJ方法，给它传入选择器，会返回符合选择器的所有节点组成的列表，等价于querySectorAll方法</strong>，下面我们分别调用了J方法、querySelector方法、JJ方法、和querySelectorAll方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch()</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://dynamic2.scrape.cuiqingcai.com/&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line">    j_result1 = <span class="keyword">await</span> page.J(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line">    j_result2 = <span class="keyword">await</span> page.querySelector(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line">    jj_result1 = <span class="keyword">await</span> page.JJ(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line">    jj_result2 = <span class="keyword">await</span> page.querySelectorAll(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;J Result1:&#x27;</span>, j_result1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;J Result2:&#x27;</span>, j_result2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;JJ Result1:&#x27;</span>, jj_result1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;JJ Result2:&#x27;</span>, jj_result2)</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">J Result1: &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E565C8</span>&gt;</span><br><span class="line">J Result2: &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E5BC48</span>&gt;</span><br><span class="line">JJ Result1: [&lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E63888</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E63BC8</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E63A08</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E63C88</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E63808</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E61E88</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E61E08</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E61DC8</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E61E48</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E61D88</span>&gt;]</span><br><span class="line">JJ Result2: [&lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E63F48</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E63948</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E631C8</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E63388</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E638C8</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E5BCC8</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E5B388</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E5B348</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E5BC88</span>&gt;, &lt;pyppeteer.element_handle.ElementHandle <span class="built_in">object</span> at <span class="number">0x0000000003E5B308</span>&gt;]</span><br></pre></td></tr></table></figure>

<p>可以看到J方法和querySelector方法的返回结果都是传入的选择器相匹配的单个节点，返回值为ElementHandle对象；JJ方法和querySectorAll方法则都是返回了和选择器相匹配的节点组成的列表，列表中的内容是ElementHandle对象</p>
</li>
<li><p>选项卡操作</p>
<p>前面使用的newPage方法用于新建选项卡的操作，那么新建选项卡之后怎么获取和切换呢？我们可以先调用pages方法获取所有打开的页面，然后选择一个页面调用其bringToFront方法即可，来看看例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://www.bing.com&#x27;</span>)</span><br><span class="line">    pages = <span class="keyword">await</span> browser.pages()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Pages:&#x27;</span>, pages)</span><br><span class="line">    page1 = pages[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">await</span> page1.bringToFront()</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bSdXut"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/22/bSdXut.png"
                      alt="bSdXut.png"
                ></a></p>
</li>
<li><p>页面操作</p>
<p>一定要有对应的方法来控制一个页面的加载、前进、后退、关闭和保存等行为，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://cuiqingcai.com/31099.html/&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://www.cnblogs.com/youyouxiaosheng-lh/p/11212340.html&#x27;</span>)</span><br><span class="line">    <span class="comment"># 后退</span></span><br><span class="line">    <span class="keyword">await</span> page.goBack()</span><br><span class="line">    <span class="comment"># 前进</span></span><br><span class="line">    <span class="keyword">await</span> page.goForward()</span><br><span class="line">    <span class="comment"># 刷新</span></span><br><span class="line">    <span class="keyword">await</span> page.reload()</span><br><span class="line">    <span class="comment"># 保存 PDF</span></span><br><span class="line">    <span class="keyword">await</span> page.pdf()  <span class="comment"># 运行显示还未实现</span></span><br><span class="line">    <span class="comment"># 截图</span></span><br><span class="line">    <span class="keyword">await</span> page.screenshot()</span><br><span class="line">    <span class="comment"># 设置页面 HTML</span></span><br><span class="line">    <span class="keyword">await</span> page.setContent(<span class="string">&#x27;&lt;h2&gt;Hello World&lt;/h2&gt;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置 User-Agent</span></span><br><span class="line">    <span class="keyword">await</span> page.setUserAgent(<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置 Headers</span></span><br><span class="line">    <span class="keyword">await</span> page.setExtraHTTPHeaders(headers=&#123;&#125;)</span><br><span class="line">    <span class="comment"># 关闭</span></span><br><span class="line">    <span class="keyword">await</span> page.close()</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure></li>
<li><p>点击</p>
<p>Pyppeteer同样可以模拟点击，调用其click方法即可；以<a class="link"   target="_blank" rel="noopener" href="https://spa2.scrape.center/%E4%B8%BA%E4%BE%8B%EF%BC%8C%E7%AD%89%E5%85%B6%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E9%83%BD%E5%8A%A0%E8%BD%BD%E5%87%BA%E6%9D%A5%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%A8%A1%E6%8B%9F%E9%82%AE%E4%BB%B6%E7%82%B9%E5%87%BB" >https://spa2.scrape.center/为例，等其所有节点都加载出来之后，模拟邮件点击<i class="fas fa-external-link-alt"></i></a>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://spa2.scrape.center/&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">&#x27;.item .name&#x27;</span>, options=&#123;</span><br><span class="line">        <span class="string">&#x27;button&#x27;</span>: <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;clickCount&#x27;</span>: <span class="number">1</span>,  <span class="comment"># 1 or 2</span></span><br><span class="line">        <span class="string">&#x27;delay&#x27;</span>: <span class="number">3000</span>,  <span class="comment"># 毫秒</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bSB96s"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/22/bSB96s.png"
                      alt="bSB96s.png"
                ></a></p>
<p>这里click方法中的第一个参数就是选择器，即在哪里操作；第二个参数是几项配置，具体有以下内容:</p>
<ul>
<li>button: 鼠标按钮，取值有left、middle、right</li>
<li>clickCount: 点击次数，取值有1和2，表示单击和双击</li>
<li>delay: 延迟点击</li>
</ul>
</li>
<li><p>Pyppeteer也可以输入文本，使用type方法即可，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://www.taobao.com&#x27;</span>)</span><br><span class="line">    <span class="comment"># 后退</span></span><br><span class="line">    <span class="keyword">await</span> page.<span class="built_in">type</span>(<span class="string">&#x27;#q&#x27;</span>, <span class="string">&#x27;iPad&#x27;</span>)</span><br><span class="line">    <span class="comment"># 关闭</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<p>效果如下:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bSBhBq"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/22/bSBhBq.png"
                      alt="bSBhBq.png"
                ></a></p>
<p>这里我们打开了淘宝，给type方法的第一个参数传入选择器，第二个参数传入要输入的内容</p>
</li>
<li><p>获取信息</p>
<p>Page对象需要调用content方法获取源码，Cookie对象调用cookies方法获取，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;HTML:&#x27;</span>, <span class="keyword">await</span> page.content())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Cookies:&#x27;</span>, <span class="keyword">await</span> page.cookies())</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure></li>
<li><p>执行</p>
<p>Pyppeteer可以支持执行JavaScript语句，使用evaluate方法即可，我们来看一个例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch()</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;http://quotes.toscrape.com/js/&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(path=<span class="string">&#x27;example.png&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> page.pdf(path=<span class="string">&#x27;example.pdf&#x27;</span>)</span><br><span class="line">    dimensions = <span class="keyword">await</span> page.evaluate(<span class="string">&#x27;&#x27;&#x27;() =&gt; &#123;</span></span><br><span class="line"><span class="string">        return &#123;</span></span><br><span class="line"><span class="string">            width: document.documentElement.clientWidth,</span></span><br><span class="line"><span class="string">            height: document.documentElement.clientHeight,</span></span><br><span class="line"><span class="string">            deviceScaleFactor: window.devicePixelRatio,</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(dimensions)</span><br><span class="line">    <span class="comment"># &gt;&gt;&gt; &#123;&#x27;width&#x27;: 800, &#x27;height&#x27;: 600, &#x27;deviceScaleFactor&#x27;: 1&#125;</span></span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure></li>
<li><p>延时等待</p>
<p>在本文章最开头的地方，我们演示了waitForSelector的用法，它可以让页面等待某些符合条件的节点加载出来再返回结果；例如这里我们给waitForSelector传入一个css选择器，如果找到符合条件的节点，就立马返回结果，否则等待直到超时，下面我们来看看其他的:</p>
<ul>
<li>waitForFunction: 等待某个Java方法执行完毕或返回结果</li>
<li>waitForNavigation: 等待页面跳转，如果没加载出来，就报错</li>
<li>waitForRequest: 等待某个特定的请求发出</li>
<li>waitFOrResponse: 等待某个特定的请求对应的响应</li>
<li>waitFor: 通用的等待方法</li>
<li>waitForXpth: 等待符合xpath的节点加载出来</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Pyppeteer还有其他很多功能，例如键盘事件、鼠标事件、对话框事件等，这里就不再一一赘述了，更多内容可以查看官方文档: <a class="link"   target="_blank" rel="noopener" href="https://miyakogi.github.io/pyppeteer/reference.html" >https://miyakogi.github.io/pyppeteer/reference.html<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Playwright的使用"><a href="#Playwright的使用" class="headerlink" title="Playwright的使用"></a>Playwright的使用</h3><h4 id="Playwright的特点"><a href="#Playwright的特点" class="headerlink" title="Playwright的特点"></a>Playwright的特点</h4><ul>
<li>支持当前所有主流浏览器，包括Chrome和Edge(基于Chromium)、Filefox、Safari(基于WebKit)，提供完善的自动化控制的API</li>
<li>支持移动端页面测试，使用设备模拟技术，可以让我们在移动Web浏览器中测试响应式的Web应用程序</li>
<li>支持所有浏览器的无头和非无头模式的测试</li>
<li>安装和配置过程非常简单，安装过程中会自动安装对应的浏览器和驱动，不需要额外配置WebDriver</li>
<li>提供自动等待相关的API，在页面加载时会自动等待对应的节点加载，大大减小了API编写的复杂度</li>
</ul>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>首先请确保Python的版本大于或等于3.7，直接使用pip工具安装，命令如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install playwright</span><br></pre></td></tr></table></figure>

<p>具体的安装说明可以参考: <a class="link"   target="_blank" rel="noopener" href="https://setup.scrape.center/playwright" >https://setup.scrape.center/playwright<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>playwright支持两种编写模式，一种是和Pyppeteer一样的异步模式，另一种是和Selenium一样的同步模式，可以根据实际需要选择不同的模式，下面先来看一个同步模式的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    <span class="keyword">for</span> browser_type <span class="keyword">in</span> [p.chromium, p.firefox, p.webkit]:</span><br><span class="line">        browser = browser_type.launch(headless=<span class="literal">False</span>)</span><br><span class="line">        page = browser.new_page()</span><br><span class="line">        page.goto(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">        page.screenshot(path=<span class="string">f&#x27;screenshot-<span class="subst">&#123;browser_type.name&#125;</span>.png&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(page.title())</span><br><span class="line">        browser.close()</span><br></pre></td></tr></table></figure>

<p>这里我们首先导入了并直接调用了sync_playwright方法，该方法的返回值是一个PlaywrightContextManger对象，可以理解为一个浏览器上下文管理器，我们将其赋值为P变量；然后依次调用p的chromium、firefox和webkit属性创建了Chromium、Firefox以及WebKit浏览器实例，接着用一个for循环依次执行了这3个浏览器的launch方法，同时设置headless的参数为false，如果不设置为false，这里我们将看不到任何效果，然后分别打印网页标题然后保存了浏览器截图</p>
<p>这里由于我的playwright安装出了点问题，不知道是不是工作电脑的问题，现在报这个错:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bCpAaQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/23/bCpAaQ.png"
                      alt="bCpAaQ.png"
                ></a></p>
<p>来看看异步模式:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> playwright.async_api <span class="keyword">import</span> async_playwright</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> async_playwright() <span class="keyword">as</span> p:</span><br><span class="line">        <span class="keyword">for</span> browser_type <span class="keyword">in</span> [p.chromium, p.firefox, p.webkit]:</span><br><span class="line">            browser = <span class="keyword">await</span> browser_type.launch(headless=<span class="literal">False</span>)</span><br><span class="line">            page = <span class="keyword">await</span> browser.new_page()</span><br><span class="line">            <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">            <span class="keyword">await</span> page.screenshot(path=<span class="string">f&#x27;screenshot-<span class="subst">&#123;browser_type.name&#125;</span>.png&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> page.title())</span><br><span class="line">            <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p>对比这两个代码，我们可以看到，写法和同步模式基本一样，只不过这里导入的是async_playwright方法，不再是sync_playwright方法，以及写法上添加了async/await关键字，最后的运行效果是和同步一样的，另外可以注意到，这个例子中使用了with as语句，with用于管理上下文对象，可以返回一个上下文管理器，即一个PlaywrightContextManger对象，无论代码运行期间是否抛出异常，该对象都能帮助我们自动分配并且释放Playwright的资源</p>
<h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>Playwright还有一个强大的功能，是可以录制我们在浏览器中的操作，并自动生成代码，有了这个功能，我们甚至可以一行代码不用写，这个功能可以通过playwright调用condegen实现，先来看下condgen命令都有什么参数，输入如下命令:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">playwright codegen --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>由于我工作的电脑的问题，我的playwright安装有点问题，以上命令无法执行，大家知道知道这个可以查看所有的参数即可</p>
<p>了解了以上用法之后，我们来尝试启动一个Firefox浏览器，然后将操作结果输出到script.py文件，命令如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">playwright codegen -o script.py -b firefox</span><br></pre></td></tr></table></figure>

<p>运行代码后会弹出一个Firefox浏览器，同时右侧输出一个脚本窗口，实时显示当前操作对应的代码；我们可以在浏览器中随意操作，例如打开百度，点击搜索框并输入nba，再点击搜索按钮，由于无法使用playwright，这里我就用语言描述下:</p>
<p>浏览器会高亮显示我们正在操作的页面节点，同时显示对应的节点信息，在操作浏览器的过程中，该窗口中的代码会跟着实时变化，所有操作完成后，关闭浏览器后，playwright会生成一个scrit.py文件，这个生成的代码和我们之前写的示例代码几乎差不多，而且也是可以运行的，运行之后会看到它在复现我们刚才所做的操作，所以，有了代码生成功能，只通过简单的可视化点击就能生成代码，可谓非常方便，另外这还有一个值得注意的点，仔细观察一下生成的代码，和前面例子不同的是，这里的new_page方法并不是直接通过browser调用的，而是通过context，这个context又是由browser调用new_context方法生成的，那么这个context究竟是做什么的呢，其实context变量是一个BrowserContext对象，这是一个类似隐身模式的独立上下文环境，其运行资源是单独隔离的，在一些自动化测试过程中，我们可以为每个测试用例单独创建一个BroserContext对象，这样能够保证各个测试用例互不干扰</p>
<h4 id="支持移动端浏览器"><a href="#支持移动端浏览器" class="headerlink" title="支持移动端浏览器"></a>支持移动端浏览器</h4><p>示例代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    iphone_12_pro_max = p.devices[<span class="string">&#x27;iPhone 12 Pro Max&#x27;</span>]</span><br><span class="line">    browser = p.webkit.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    context = browser.new_context(</span><br><span class="line">        **iphone_12_pro_max,</span><br><span class="line">        locale=<span class="string">&#x27;zh-CN&#x27;</span>,</span><br><span class="line">        geolocation=&#123;<span class="string">&#x27;longitude&#x27;</span>: <span class="number">116.39014</span>, <span class="string">&#x27;latitude&#x27;</span>: <span class="number">39.913904</span>&#125;,</span><br><span class="line">        permissions=[<span class="string">&#x27;geolocation&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line">    page = context.new_page()</span><br><span class="line">    page.goto(<span class="string">&#x27;https://amap.com&#x27;</span>)</span><br><span class="line">    page.wait_for_load_state(state=<span class="string">&#x27;networkidle&#x27;</span>)</span><br><span class="line">    page.screenshot(path=<span class="string">&#x27;location-iphone.png&#x27;</span>)</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<p>这里我们先用 PlaywrightContextManager 对象的 devices 属性指定了一台移动设备，这里传入的是手机的型号，比如 iPhone 12 Pro Max，当然也可以传其他名称，比如 iPhone 8，Pixel 2 等。</p>
<p>前面我们已经了解了 BrowserContext 对象，BrowserContext 对象也可以用来模拟移动端浏览器，初始化一些移动设备信息、语言、权限、位置等信息，这里我们就用它来创建了一个移动端 BrowserContext 对象，通过 geolocation 参数传入了经纬度信息，通过 permissions 参数传入了赋予的权限信息，最后将得到的 BrowserContext 对象赋值为 context 变量。</p>
<p>接着我们就可以用 BrowserContext 对象来新建一个页面，还是调用 new_page 方法创建一个新的选项卡，然后跳转到高德地图，并调用了 wait_for_load_state 方法等待页面某个状态完成，这里我们传入的 state 是 networkidle，也就是网络空闲状态。因为在页面初始化和加载过程中，肯定是伴随有网络请求的，所以加载过程中肯定不算 networkidle 状态，所以这里我们传入 networkidle 就可以标识当前页面和数据加载完成的状态。加载完成之后，我们再调用 screenshot 方法获取当前页面截图，最后关闭浏览器。</p>
<p>运行下代码，可以发现这里就弹出了一个移动版浏览器，然后加载了高德地图，并定位到了故宫的位置，如图所示:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bCEl4O"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/23/bCEl4O.png"
                      alt="bCEl4O.png"
                ></a></p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>前面我们注意到 click 和 fill 等方法都传入了一个字符串，这些字符串有的符合 CSS 选择器的语法，有的又是 text= 开头的，感觉似乎没太有规律的样子，它到底支持怎样的匹配规则呢？下面我们来了解下。</p>
<p>传入的这个字符串，我们可以称之为 Element Selector，它不仅仅支持 CSS 选择器、XPath，Playwright 还扩展了一些方便好用的规则，比如直接根据文本内容筛选，根据节点层级结构筛选等等</p>
<h5 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h5><p>文本选择支持直接使用 <code>text=</code> 这样的语法进行筛选，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.click(<span class="string">&quot;text=Log in&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这就代表选择文本是 Log in 的节点，并点击</p>
<h5 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h5><p>CSS 选择器之前也介绍过了，比如根据 id 或者 class 筛选:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">page.click(<span class="string">&quot;button&quot;</span>)</span><br><span class="line">page.click(<span class="string">&quot;#nav-bar .contact-us-item&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>根据特定的节点属性筛选:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">page.click(<span class="string">&quot;[data-test=login-button]&quot;</span>)</span><br><span class="line">page.click(<span class="string">&quot;[aria-label=&#x27;Sign in&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="CSS-选择器-文本"><a href="#CSS-选择器-文本" class="headerlink" title="CSS 选择器 + 文本"></a>CSS 选择器 + 文本</h5><p>我们还可以使用 CSS 选择器结合文本值进行海选，比较常用的就是 has-text 和 text，前者代表包含指定的字符串，后者代表字符串完全匹配，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">page.click(<span class="string">&quot;article:has-text(&#x27;Playwright&#x27;)&quot;</span>)</span><br><span class="line">page.click(<span class="string">&quot;#nav-bar :text(&#x27;Contact us&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>第一个就是选择文本中包含 Playwright 的 article 节点，第二个就是选择 id 为 nav-bar 节点中文本值等于 Contact us 的节点</p>
<h5 id="CSS-选择器-节点关系"><a href="#CSS-选择器-节点关系" class="headerlink" title="CSS 选择器 + 节点关系"></a>CSS 选择器 + 节点关系</h5><p>还可以结合节点关系来筛选节点，比如使用 has 来指定另外一个选择器，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.click(<span class="string">&quot;.item-description:has(.item-promo-banner)&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>比如这里选择的就是选择 class 为 item-description 的节点，且该节点还要包含 class 为 item-promo-banner 的子节点</p>
<p>另外还有一些相对位置关系，比如 right-of 可以指定位于某个节点右侧的节点，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.click(<span class="string">&quot;input:right-of(:text(&#x27;Username&#x27;))&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里选择的就是一个 input 节点，并且该 input 节点要位于文本值为 Username 的节点的右侧</p>
<h5 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h5><p>当然 XPath 也是支持的，不过 xpath 这个关键字需要我们自行制定，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.click(<span class="string">&quot;xpath=//button&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里需要在开头指定 <code>xpath=</code> 字符串，代表后面是一个 XPath 表达式</p>
<p>关于更多选择器的用法和最佳实践，可以参考官方文档：<a class="link"   target="_blank" rel="noopener" href="https://playwright.dev/python/docs/selectors%E3%80%82" >https://playwright.dev/python/docs/selectors<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="常用操作方法"><a href="#常用操作方法" class="headerlink" title="常用操作方法"></a>常用操作方法</h4><p>上面我们了解了浏览器的一些初始化设置和基本的操作实例，下面我们再对一些常用的操作 API 进行说明。</p>
<p>常见的一些 API 如点击 click，输入 fill 等操作，这些方法都是属于 Page 对象的，所以所有的方法都从 Page 对象的 API 文档查找，文档地址：<a class="link"   target="_blank" rel="noopener" href="https://playwright.dev/python/docs/api/class-page%E3%80%82" >https://playwright.dev/python/docs/api/class-page<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h5><p>Page 对象提供了一个 on 方法，它可以用来监听页面中发生的各个事件，比如 close、console、load、request、response 等等。</p>
<p>比如这里我们可以监听 response 事件，response 事件可以在每次网络请求得到响应的时候触发，我们可以设置对应的回调方法获取到对应 Response 的全部信息，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_response</span>(<span class="params">response</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Statue <span class="subst">&#123;response.status&#125;</span>: <span class="subst">&#123;response.url&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.on(<span class="string">&#x27;response&#x27;</span>, on_response)</span><br><span class="line">    page.goto(<span class="string">&#x27;https://spa6.scrape.center/&#x27;</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">&#x27;networkidle&#x27;</span>)</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<p>这里我们在创建 Page 对象之后，就开始监听 response 事件，同时将回调方法设置为 on_response，on_response 对象接收一个参数，然后把 Response 的状态码和链接都输出出来了</p>
<p>运行之后可以看到控制台输出结果如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Statue <span class="number">200</span>: https://spa6.scrape.center/</span><br><span class="line">Statue <span class="number">200</span>: https://spa6.scrape.center/css/app.ea9d802a.css</span><br><span class="line">Statue <span class="number">200</span>: https://spa6.scrape.center/js/app<span class="number">.5</span>ef0d454.js</span><br><span class="line">Statue <span class="number">200</span>: https://spa6.scrape.center/js/chunk-vendors<span class="number">.77</span>daf991.js</span><br><span class="line">Statue <span class="number">200</span>: https://spa6.scrape.center/css/chunk-19c920f8<span class="number">.2</span>a6496e0.css</span><br><span class="line">...</span><br><span class="line">Statue <span class="number">200</span>: https://spa6.scrape.center/css/chunk-19c920f8<span class="number">.2</span>a6496e0.css</span><br><span class="line">Statue <span class="number">200</span>: https://spa6.scrape.center/js/chunk-19c920f8.c3a1129d.js</span><br><span class="line">Statue <span class="number">200</span>: https://spa6.scrape.center/img/logo.a508a8f0.png</span><br><span class="line">Statue <span class="number">200</span>: https://spa6.scrape.center/fonts/element-icons<span class="number">.535877</span>f5.woff</span><br><span class="line">Statue <span class="number">301</span>: https://spa6.scrape.center/api/movie?limit=<span class="number">10</span>&amp;offset=<span class="number">0</span>&amp;token=NGMwMzFhNGEzMTFiMzJkOGE0ZTQ1YjUzMTc2OWNiYTI1Yzk0ZDM3MSwxNjIyOTE4NTE5</span><br><span class="line">Statue <span class="number">200</span>: https://spa6.scrape.center/api/movie/?limit=<span class="number">10</span>&amp;offset=<span class="number">0</span>&amp;token=NGMwMzFhNGEzMTFiMzJkOGE0ZTQ1YjUzMTc2OWNiYTI1Yzk0ZDM3MSwxNjIyOTE4NTE5</span><br><span class="line">Statue <span class="number">200</span>: https://p0.meituan.net/movie/da64660f82b98cdc1b8a3804e69609e041108.jpg@464w_644h_1e_1c</span><br><span class="line">Statue <span class="number">200</span>: https://p0.meituan.net/movie/283292171619cdfd5b240c8fd093f1eb255670.jpg@464w_644h_1e_1c</span><br><span class="line">....</span><br><span class="line">Statue <span class="number">200</span>: https://p1.meituan.net/movie/b607fba7513e7f15eab170aac1e1400d878112.jpg@464w_644h_1e_1c</span><br></pre></td></tr></table></figure>

<p>这个网站我们之前分析过，其真实的数据都是 Ajax 加载的，同时 Ajax 请求中还带有加密参数，不好轻易获取，但有了这个方法之后，这里如果我们想要的Ajax请求，就非常容易了，改写下判定条件，输出对应的JSON结果，改写如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_response</span>(<span class="params">response</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;/api/movie/&#x27;</span> <span class="keyword">in</span> response.url <span class="keyword">and</span> response.status == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(response.json())</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.on(<span class="string">&#x27;response&#x27;</span>, on_response)</span><br><span class="line">    page.goto(<span class="string">&#x27;https://spa6.scrape.center/&#x27;</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">&#x27;networkidle&#x27;</span>)</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<p>控制台输出如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;count&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;results&#x27;</span>: [&#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;霸王别姬&#x27;</span>, <span class="string">&#x27;alias&#x27;</span>: <span class="string">&#x27;Farewell My Concubine&#x27;</span>, <span class="string">&#x27;cover&#x27;</span>: <span class="string">&#x27;https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c&#x27;</span>, <span class="string">&#x27;categories&#x27;</span>: [<span class="string">&#x27;剧情&#x27;</span>, <span class="string">&#x27;爱情&#x27;</span>], <span class="string">&#x27;published_at&#x27;</span>: <span class="string">&#x27;1993-07-26&#x27;</span>, <span class="string">&#x27;minute&#x27;</span>: <span class="number">171</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">9.5</span>, <span class="string">&#x27;regions&#x27;</span>: [<span class="string">&#x27;中国大陆&#x27;</span>, <span class="string">&#x27;中国香港&#x27;</span>]&#125;, </span><br><span class="line">...</span><br><span class="line"><span class="string">&#x27;published_at&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;minute&#x27;</span>: <span class="number">103</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">9.0</span>, <span class="string">&#x27;regions&#x27;</span>: [<span class="string">&#x27;美国&#x27;</span>]&#125;, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;狮子王&#x27;</span>, <span class="string">&#x27;alias&#x27;</span>: <span class="string">&#x27;The Lion King&#x27;</span>, <span class="string">&#x27;cover&#x27;</span>: <span class="string">&#x27;https://p0.meituan.net/movie/27b76fe6cf3903f3d74963f70786001e1438406.jpg@464w_644h_1e_1c&#x27;</span>, <span class="string">&#x27;categories&#x27;</span>: [<span class="string">&#x27;动画&#x27;</span>, <span class="string">&#x27;歌舞&#x27;</span>, <span class="string">&#x27;冒险&#x27;</span>], <span class="string">&#x27;published_at&#x27;</span>: <span class="string">&#x27;1995-07-15&#x27;</span>, <span class="string">&#x27;minute&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">9.0</span>, <span class="string">&#x27;regions&#x27;</span>: [<span class="string">&#x27;美国&#x27;</span>]&#125;]&#125;</span><br></pre></td></tr></table></figure>

<h5 id="获取页面源码"><a href="#获取页面源码" class="headerlink" title="获取页面源码"></a>获取页面源码</h5><p>要获取页面的 HTML 代码其实很简单，我们直接通过 content 方法获取即可，用法如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">&#x27;https://spa6.scrape.center/&#x27;</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">&#x27;networkidle&#x27;</span>)</span><br><span class="line">    html = page.content()</span><br><span class="line">    <span class="built_in">print</span>(html)</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<p>运行结果就是页面的 HTML 代码。获取了 HTML 代码之后，我们通过一些解析工具就可以提取想要的信息了</p>
<h5 id="页面点击"><a href="#页面点击" class="headerlink" title="页面点击"></a>页面点击</h5><p>刚才我们通过示例也了解了页面点击的方法，那就是 click，这里详细说一下其使用方法</p>
<p>页面点击的 API 定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.click(selector, **kwargs)</span><br></pre></td></tr></table></figure>

<p>这里可以看到必传的参数是 selector，其他的参数都是可选的。第一个 selector 就代表选择器，可以用来匹配想要点击的节点，如果传入的选择器匹配了多个节点，那么只会用第一个节点。</p>
<p>这个方法的内部执行逻辑如下：</p>
<ul>
<li>根据 selector 找到匹配的节点，如果没有找到，那就一直等待直到超时，超时时间可以由额外的 timeout 参数设置，默认是 30 秒。</li>
<li>等待对该节点的可操作性检查的结果，比如说如果某个按钮设置了不可点击，那它会等待该按钮变成了可点击的时候才去点击，除非通过 force 参数设置跳过可操作性检查步骤强制点击。</li>
<li>如果需要的话，就滚动下页面，把需要被点击的节点呈现出来。</li>
<li>调用 page 对象的 mouse 方法，点击节点中心的位置，如果指定了 position 参数，那就点击指定的位置。</li>
</ul>
<p>click 方法的一些比较重要的参数如下：</p>
<ul>
<li>click_count：点击次数，默认为 1。</li>
<li>timeout：等待要点击的节点的超时时间，默认是 30 秒。</li>
<li>position：需要传入一个字典，带有 x 和 y 属性，代表点击位置相对节点左上角的偏移位置。</li>
<li>force：即使不可点击，那也强制点击。默认是 False。</li>
</ul>
<p>具体的 API 设置参数可以参考官方文档：<a class="link"   target="_blank" rel="noopener" href="https://playwright.dev/python/docs/api/class-page/#pageclickselector-kwargs%E3%80%82" >https://playwright.dev/python/docs/api/class-page/#pageclickselector-kwargs<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h5><p>文本输入对应的方法是 fill，API 定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.fill(selector, value, **kwargs)</span><br></pre></td></tr></table></figure>

<p>这个方法有两个必传参数，第一个参数也是 selector，第二个参数是 value，代表输入的内容，另外还可以通过 timeout 参数指定对应节点的最长等待时间</p>
<h5 id="获取节点属性"><a href="#获取节点属性" class="headerlink" title="获取节点属性"></a>获取节点属性</h5><p>除了对节点进行操作，我们还可以获取节点的属性，方法就是 get_attribute，API 定义如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.get_attribute(selector, name, **kwargs)</span><br></pre></td></tr></table></figure>

<p>这个方法有两个必传参数，第一个参数也是 selector，第二个参数是 name，代表要获取的属性名称，另外还可以通过 timeout 参数指定对应节点的最长等待时间</p>
<p>示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">&#x27;https://spa6.scrape.center/&#x27;</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">&#x27;networkidle&#x27;</span>)</span><br><span class="line">    href = page.get_attribute(<span class="string">&#x27;a.name&#x27;</span>, <span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(href)</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<p>这里我们调用了 get_attribute 方法，传入的 selector 是 <code>a.name</code>，选定了 class 为 name 的 a 节点，然后第二个参数传入了 href，获取超链接的内容，输出结果如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx</span><br></pre></td></tr></table></figure>

<p>可以看到对应 href 属性就获取出来了，但这里只有一条结果，因为这里有个条件，那就是如果传入的选择器匹配了多个节点，那么只会用第一个节点。</p>
<p>那怎么获取所有的节点呢</p>
<h5 id="获取多个节点"><a href="#获取多个节点" class="headerlink" title="获取多个节点"></a>获取多个节点</h5><p>获取所有节点可以使用 query_selector_all 方法，它可以返回节点列表，通过遍历获取到单个节点之后，我们可以接着调用单个节点的方法来进行一些操作和属性获取，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">&#x27;https://spa6.scrape.center/&#x27;</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">&#x27;networkidle&#x27;</span>)</span><br><span class="line">    elements = page.query_selector_all(<span class="string">&#x27;a.name&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">        <span class="built_in">print</span>(element.get_attribute(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(element.text_content())</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<p>这里我们通过 query_selector_all 方法获取了所有匹配到的节点，每个节点对应的是一个 ElementHandle 对象，然后 ElementHandle 对象也有 get_attribute 方法来获取节点属性，另外还可以通过 text_content 方法获取节点文本，运行结果如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx</span><br><span class="line">霸王别姬 - Farewell My Concubine</span><br><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIy</span><br><span class="line">这个杀手不太冷 - Léon</span><br><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIz</span><br><span class="line">肖申克的救赎 - The Shawshank Redemption</span><br><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI0</span><br><span class="line">泰坦尼克号 - Titanic</span><br><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI1</span><br><span class="line">罗马假日 - Roman Holiday</span><br><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI2</span><br><span class="line">唐伯虎点秋香 - Flirting Scholar</span><br><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI3</span><br><span class="line">乱世佳人 - Gone <span class="keyword">with</span> the Wind</span><br><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI4</span><br><span class="line">喜剧之王 - The King of Comedy</span><br><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWI5</span><br><span class="line">楚门的世界 - The Truman Show</span><br><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIxMA==</span><br><span class="line">狮子王 - The Lion King</span><br></pre></td></tr></table></figure>

<h5 id="获取单个节点"><a href="#获取单个节点" class="headerlink" title="获取单个节点"></a>获取单个节点</h5><p>获取单个节点也有特定的方法，就是 query_selector，如果传入的选择器匹配到多个节点，那它只会返回第一个节点，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">&#x27;https://spa6.scrape.center/&#x27;</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">&#x27;networkidle&#x27;</span>)</span><br><span class="line">    element = page.query_selector(<span class="string">&#x27;a.name&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(element.get_attribute(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(element.text_content())</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx</span><br><span class="line">霸王别姬 - Farewell My Concubine</span><br></pre></td></tr></table></figure>

<p>可以看到这里只输出了第一个匹配节点的信息</p>
<h5 id="网络劫持"><a href="#网络劫持" class="headerlink" title="网络劫持"></a>网络劫持</h5><p>最后再介绍一个实用的方法 route，利用 route 方法，我们可以实现一些网络劫持和修改操作，比如修改 request 的属性，修改 response 响应结果等</p>
<p>看一个实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cancel_request</span>(<span class="params">route, request</span>):</span></span><br><span class="line">        route.abort()</span><br><span class="line"></span><br><span class="line">    page.route(re.<span class="built_in">compile</span>(<span class="string">r&quot;(\.png)|(\.jpg)&quot;</span>), cancel_request)</span><br><span class="line">    page.goto(<span class="string">&quot;https://spa6.scrape.center/&quot;</span>)</span><br><span class="line">    page.wait_for_load_state(<span class="string">&#x27;networkidle&#x27;</span>)</span><br><span class="line">    page.screenshot(path=<span class="string">&#x27;no_picture.png&#x27;</span>)</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<p>这里我们调用了 route 方法，第一个参数通过正则表达式传入了匹配的 URL 路径，这里代表的是任何包含 <code>.png</code> 或 <code>.jpg</code> 的链接，遇到这样的请求，会回调 cancel_request 方法处理，cancel_request 方法可以接收两个参数，一个是 route，代表一个 CallableRoute 对象，另外一个是 request，代表 Request 对象。这里我们直接调用了 route 的 abort 方法，取消了这次请求，所以最终导致的结果就是图片的加载全部取消了，运行结果如下所示:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bCNuq0"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/23/bCNuq0.png"
                      alt="bCNuq0.png"
                ></a></p>
<p>这个设置有什么用呢？其实是有用的，因为图片资源都是二进制文件，而我们在做爬取过程中可能并不想关心其具体的二进制文件的内容，可能只关心图片的 URL 是什么，所以在浏览器中是否把图片加载出来就不重要了。所以如此设置之后，我们可以提高整个页面的加载速度，提高爬取效率。</p>
<p>另外，利用这个功能，我们还可以将一些响应内容进行修改，比如直接修改 Response 的结果为自定义的文本文件内容。</p>
<p>首先这里定义一个 HTML 文本文件，命名为 custom_response.html，内容如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Hack Response&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hack Response&lt;/h1&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>代码编写如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">modify_response</span>(<span class="params">route, request</span>):</span></span><br><span class="line">        route.fulfill(path=<span class="string">&quot;./custom_response.html&quot;</span>)</span><br><span class="line"></span><br><span class="line">    page.route(<span class="string">&#x27;/&#x27;</span>, modify_response)</span><br><span class="line">    page.goto(<span class="string">&quot;https://spa6.scrape.center/&quot;</span>)</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<p>这里我们使用 route 的 fulfill 方法指定了一个本地文件，就是刚才我们定义的 HTML 文件，运行结果如下:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bCN5FS"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/23/bCN5FS.png"
                      alt="bCN5FS.png"
                ></a></p>
<p>可以看到，Response 的运行结果就被我们修改了，URL 还是不变的，但是结果已经成了我们修改的 HTML 代码。</p>
<p>所以通过 route 方法，我们可以灵活地控制请求和响应的内容，从而在某些场景下达成某些目的</p>
<h3 id="Selenium爬取实战"><a href="#Selenium爬取实战" class="headerlink" title="Selenium爬取实战"></a>Selenium爬取实战</h3><p>目标网站: <a class="link"   target="_blank" rel="noopener" href="https://spa2.scrape.center/" >https://spa2.scrape.center/<i class="fas fa-external-link-alt"></i></a></p>
<p>我们要完成以下工作:</p>
<ul>
<li>通过Selenium遍历列表页，获取每部电影的详情页URL</li>
<li>通过Selenium根据上一步获取的详情页URL爬取每部电影的详情页</li>
<li>从详情页中提取每部电影的名称、类别、分数、简介、封面等信息</li>
</ul>
<p>下面就直接上代码叭:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> makedirs</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> exists</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://spa2.scrape.center/page/&#123;page&#125;&#x27;</span></span><br><span class="line">TIMEOUT = <span class="number">10</span></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span></span><br><span class="line"><span class="comment"># 以上代码都是初始化操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RESULTS_DIR = <span class="string">&#x27;results&#x27;</span></span><br><span class="line"></span><br><span class="line">exists(RESULTS_DIR) <span class="keyword">or</span> makedirs(RESULTS_DIR)</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;useAutomationExtension&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=options)  <span class="comment"># 创建一个浏览器对象</span></span><br><span class="line">wait = WebDriverWait(browser, TIMEOUT)  <span class="comment"># 利用它可以配置页面加载的最长时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_page</span>(<span class="params">url, condition, locator</span>):</span>  <span class="comment"># 通用的爬取方法，可以对任意的URL进行爬取、状态监听以及异常处理</span></span><br><span class="line">    logging.info(<span class="string">&#x27;scraping %s&#x27;</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        browser.get(url)</span><br><span class="line">        wait.until(condition(locator))</span><br><span class="line">    <span class="keyword">except</span> TimeoutException:</span><br><span class="line">        logging.error(<span class="string">&#x27;error occurred while scraping %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_index</span>(<span class="params">page</span>):</span>  <span class="comment"># 爬取列表页</span></span><br><span class="line">    url = INDEX_URL.<span class="built_in">format</span>(page=page)</span><br><span class="line">    scrape_page(url, condition=EC.visibility_of_all_elements_located,</span><br><span class="line">                locator=(By.CSS_SELECTOR, <span class="string">&#x27;#index .item&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_index</span>():</span>  <span class="comment"># 解析列表页</span></span><br><span class="line">    elements = browser.find_elements_by_css_selector(<span class="string">&#x27;#index .item .name&#x27;</span>)  <span class="comment"># 从列表页中提取所有电影节点</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">        href = element.get_attribute(<span class="string">&#x27;href&#x27;</span>)  <span class="comment"># 提取详情页的href</span></span><br><span class="line">        <span class="keyword">yield</span> urljoin(INDEX_URL, href)  <span class="comment"># 合并成完整的URL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scrape_detail</span>(<span class="params">url</span>):</span>  <span class="comment"># 爬取详情页之前，先判断页面是否加载成功，用visibility_of_element_located查看是否将h2加载出来，如果加载出来了，那页面就加载成功</span></span><br><span class="line">    scrape_page(url, condition=EC.visibility_of_element_located,</span><br><span class="line">                locator=(By.TAG_NAME, <span class="string">&#x27;h2&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span>():</span>  <span class="comment"># 爬取详情页</span></span><br><span class="line">    url = browser.current_url</span><br><span class="line">    name = browser.find_element_by_tag_name(<span class="string">&#x27;h2&#x27;</span>).text</span><br><span class="line">    categories = [element.text <span class="keyword">for</span> element <span class="keyword">in</span> browser.find_elements_by_css_selector(<span class="string">&#x27;.categories button span&#x27;</span>)]</span><br><span class="line">    cover = browser.find_element_by_css_selector(<span class="string">&#x27;.cover&#x27;</span>).get_attribute(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    score = browser.find_element_by_class_name(<span class="string">&#x27;score&#x27;</span>).text</span><br><span class="line">    drama = browser.find_element_by_css_selector(<span class="string">&#x27;.drama p&#x27;</span>).text</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span>: url,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">        <span class="string">&#x27;categories&#x27;</span>: categories,</span><br><span class="line">        <span class="string">&#x27;cover&#x27;</span>: cover,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: score,</span><br><span class="line">        <span class="string">&#x27;drama&#x27;</span>: drama</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    name = data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    data_path = <span class="string">f&#x27;<span class="subst">&#123;RESULTS_DIR&#125;</span>/<span class="subst">&#123;name&#125;</span>.json&#x27;</span></span><br><span class="line">    json.dump(data, <span class="built_in">open</span>(data_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>), ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>):</span><br><span class="line">            scrape_index(page)</span><br><span class="line">            detail_urls = parse_index()</span><br><span class="line">            <span class="keyword">for</span> detail_url <span class="keyword">in</span> <span class="built_in">list</span>(detail_urls):</span><br><span class="line">                logging.info(<span class="string">&#x27;get detail url %s&#x27;</span>, detail_url)</span><br><span class="line">                scrape_detail(detail_url)</span><br><span class="line">                detail_data = parse_detail()</span><br><span class="line">                logging.info(<span class="string">&#x27;detail data %s&#x27;</span>, detail_data)</span><br><span class="line">                save_data(detail_data)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="Pyppeteer爬取实战"><a href="#Pyppeteer爬取实战" class="headerlink" title="Pyppeteer爬取实战"></a>Pyppeteer爬取实战</h3><p>目标网站: <a class="link"   target="_blank" rel="noopener" href="https://spa2.scrape.center/" >https://spa2.scrape.center/<i class="fas fa-external-link-alt"></i></a></p>
<p>要完成的工作和上面的一样</p>
<p>准备工作，安装好Python，最低版本为3.6，安装好Pyppeteer并能成功运行实例</p>
<p>下面就直接上代码叭:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> exists</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> makedirs</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> pyppeteer.errors <span class="keyword">import</span> TimeoutError</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://spa2.scrape.center/page/&#123;page&#125;&#x27;</span></span><br><span class="line">TIMEOUT = <span class="number">10</span></span><br><span class="line">TOTAL_PAGE = <span class="number">10</span></span><br><span class="line">RESULTS_DIR = <span class="string">&#x27;results&#x27;</span></span><br><span class="line">WINDOW_WIDTH, WINDOW_HEIGHT = <span class="number">1366</span>, <span class="number">768</span></span><br><span class="line"></span><br><span class="line">exists(RESULTS_DIR) <span class="keyword">or</span> makedirs(RESULTS_DIR)</span><br><span class="line"></span><br><span class="line">browser, tab = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">HEADLESS = <span class="literal">True</span>  <span class="comment"># 不会弹出窗口</span></span><br><span class="line"><span class="comment"># 以上代码都是准备工作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    <span class="keyword">global</span> browser, tab  <span class="comment"># 设置为全局变量，方便其他方法调用</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(headless=HEADLESS,</span><br><span class="line">                           args=[<span class="string">&#x27;--disable-infobars&#x27;</span>, <span class="string">f&#x27;--window-size=<span class="subst">&#123;WINDOW_WIDTH&#125;</span>,<span class="subst">&#123;WINDOW_HEIGHT&#125;</span>&#x27;</span>])  <span class="comment"># 隐藏提示条和设置了浏览器宽高</span></span><br><span class="line">    tab = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> tab.setViewport(&#123;<span class="string">&#x27;width&#x27;</span>: WINDOW_WIDTH, <span class="string">&#x27;height&#x27;</span>: WINDOW_HEIGHT&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">scrape_page</span>(<span class="params">url, selector</span>):</span>  <span class="comment"># 通用的爬取方法，url为要爬取的页面的URL，使用 goto即可调用此URL访问对应页面，Selector即等待渲染出的节点对应的CSS选择器</span></span><br><span class="line">    logging.info(<span class="string">&#x27;scraping %s&#x27;</span>, url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> tab.goto(url)</span><br><span class="line">        <span class="keyword">await</span> tab.waitForSelector(selector, options=&#123;</span><br><span class="line">            <span class="string">&#x27;timeout&#x27;</span>: TIMEOUT * <span class="number">1000</span></span><br><span class="line">        &#125;)  <span class="comment"># 调用waitForSelector方法，传入selector，并通过options指定了最长等待时间</span></span><br><span class="line">    <span class="keyword">except</span> TimeoutError:</span><br><span class="line">        logging.error(<span class="string">&#x27;error occurred while scraping %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">scrape_index</span>(<span class="params">page</span>):</span>  <span class="comment"># 爬取列表页</span></span><br><span class="line">    url = INDEX_URL.<span class="built_in">format</span>(page=page)</span><br><span class="line">    <span class="keyword">await</span> scrape_page(url, <span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_index</span>():</span>  <span class="comment"># 解析列表页</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> tab.querySelectorAllEval(<span class="string">&#x27;.item .name&#x27;</span>, <span class="string">&#x27;nodes =&gt; nodes.map(node =&gt; node.href)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">scrape_detail</span>(<span class="params">url</span>):</span>  <span class="comment"># 爬取详情页</span></span><br><span class="line">    <span class="keyword">await</span> scrape_page(url, <span class="string">&#x27;h2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span>():</span></span><br><span class="line">    url = tab.url</span><br><span class="line">    name = <span class="keyword">await</span> tab.querySelectorEval(<span class="string">&#x27;h2&#x27;</span>, <span class="string">&#x27;node =&gt; node.innerText&#x27;</span>)</span><br><span class="line">    categories = <span class="keyword">await</span> tab.querySelectorAllEval(<span class="string">&#x27;.categories button span&#x27;</span>, <span class="string">&#x27;nodes =&gt; nodes.map(node =&gt; node.innerText)&#x27;</span>)</span><br><span class="line">    cover = <span class="keyword">await</span> tab.querySelectorEval(<span class="string">&#x27;.cover&#x27;</span>, <span class="string">&#x27;node =&gt; node.src&#x27;</span>)</span><br><span class="line">    score = <span class="keyword">await</span> tab.querySelectorEval(<span class="string">&#x27;.score&#x27;</span>, <span class="string">&#x27;node =&gt; node.innerText&#x27;</span>)</span><br><span class="line">    drama = <span class="keyword">await</span> tab.querySelectorEval(<span class="string">&#x27;.drama p&#x27;</span>, <span class="string">&#x27;node =&gt; node.innerText&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span>: url,</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: name,</span><br><span class="line">        <span class="string">&#x27;categories&#x27;</span>: categories,</span><br><span class="line">        <span class="string">&#x27;cover&#x27;</span>: cover,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: score,</span><br><span class="line">        <span class="string">&#x27;drama&#x27;</span>: drama</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    name = data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    data_path = <span class="string">f&#x27;<span class="subst">&#123;RESULTS_DIR&#125;</span>/<span class="subst">&#123;name&#125;</span>.json&#x27;</span></span><br><span class="line">    json.dump(data, <span class="built_in">open</span>(data_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>), ensure_ascii=<span class="literal">False</span>, indent=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">await</span> init()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, TOTAL_PAGE + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">await</span> scrape_index(page)</span><br><span class="line">            detail_urls = <span class="keyword">await</span> parse_index()</span><br><span class="line">            <span class="keyword">for</span> detail_url <span class="keyword">in</span> detail_urls:</span><br><span class="line">                <span class="keyword">await</span> scrape_detail(detail_url)</span><br><span class="line">                detail_data = <span class="keyword">await</span> parse_detail()</span><br><span class="line">                logging.info(<span class="string">&#x27;data %s&#x27;</span>, detail_data)</span><br><span class="line">                <span class="keyword">await</span> save_data(detail_data)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure>

<h3 id="CSS位置偏移反爬案例分析与爬取实战"><a href="#CSS位置偏移反爬案例分析与爬取实战" class="headerlink" title="CSS位置偏移反爬案例分析与爬取实战"></a>CSS位置偏移反爬案例分析与爬取实战</h3><p>我们学习了Selenium、Pyppeteer等工具，体会了它们的强大，但千万别以为这些工具就是万能的，不容易爬取的数据依然存在，例如网页利用CSS控制文字的偏移位置，或者通过一些特殊的方式隐蔽关键信息，都有可能对数据爬取造成干扰，接下来我们就先了解下CSS位置偏移反爬虫的一些解决方案</p>
<h4 id="案例导入"><a href="#案例导入" class="headerlink" title="案例导入"></a>案例导入</h4><p>先介绍下一个案例<a class="link"   target="_blank" rel="noopener" href="https://antispider3.scrape.center/%EF%BC%8C%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA" >https://antispider3.scrape.center/，页面如下图所示<i class="fas fa-external-link-alt"></i></a>:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bP3Epn"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/23/bP3Epn.png"
                      alt="bP3Epn.png"
                ></a></p>
<p>乍一看似乎也没什么特别之处，但如果真用Selenium等工具爬取和提取数据，坑就立马显现出来了，不妨试一试，我们先尝试用Selenium获取首页的页面源代码，并解析每个标题的内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider3.scrape.center/&#x27;</span>)</span><br><span class="line">WebDriverWait(browser, <span class="number">10</span>) \</span><br><span class="line">    .until(EC.presence_of_all_elements_located((By.CSS_SELECTOR, <span class="string">&#x27;.item&#x27;</span>)))</span><br><span class="line">html = browser.page_source</span><br><span class="line">doc = pq(html)</span><br><span class="line">names = doc(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names.items():</span><br><span class="line">    <span class="built_in">print</span>(name.text())</span><br></pre></td></tr></table></figure>

<p>然而结果确是这样的：</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bPGhSs"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/23/bPGhSs.png"
                      alt="bPGhSs.png"
                ></a></p>
<p>很多字的顺序都乱了，这是怎么回事呢</p>
<h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><p>我们进浏览器去看下源代码:</p>
<p>可以看到这源代码本身就是乱的，一个字对应一个span节点，所以用pyqueqy提取出来的标题内容乱序就不足为怪了，那么源代码本身就是乱的，那为什么在网页上看到的标题是正确的?这是因为网页本身利用CSS控制了文字的偏移位置，什么意思呢，我们先观察以下源代码:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">data-v-7f1a77ef</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;m-b-sm name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">data-v-7f1a77ef</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;char&quot;</span> <span class="attr">style</span>=<span class="string">&quot;left: 48px;&quot;</span>&gt;</span></span><br><span class="line">                      风</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">data-v-7f1a77ef</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;char&quot;</span> <span class="attr">style</span>=<span class="string">&quot;left: 16px;&quot;</span>&gt;</span></span><br><span class="line">                      白</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">data-v-7f1a77ef</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;char&quot;</span> <span class="attr">style</span>=<span class="string">&quot;left: 0px;&quot;</span>&gt;</span></span><br><span class="line">                      清</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">data-v-7f1a77ef</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;char&quot;</span> <span class="attr">style</span>=<span class="string">&quot;left: 32px;&quot;</span>&gt;</span></span><br><span class="line">                      家</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以发现，每个span节点都有一个style属性，表示CSS样式，left的取值各不相同；另外，在浏览器中观察一下每各span节点的完整样式，如下图所示:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bPYdKI"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/23/bPYdKI.png"
                      alt="bPYdKI.png"
                ></a></p>
<p>可以看到，span还有两个额外的样式，是display: inline-block和position: absolute，后者比较重要，代表绝对定位，设置这个样式后，就可以通过left的值控制span节点在页面中的偏移位置了，例如left:0px代表不偏移，left:16px代表从左边起向右偏移16像素，于是节点就到了右边，那这样就能解释上面字的顺序了</p>
<h4 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a>爬取</h4><p>了解了基本原理后，我们就可以对症下药了，这里只需要获取每个span节点的style属性，提取出偏移值，然后排序就可以得到最终结果了，我们先实现基本的提取方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_name</span>(<span class="params">name_html</span>):</span>  <span class="comment"># name_html:标题的HTML文本</span></span><br><span class="line">    chars = name_html(<span class="string">&#x27;.char&#x27;</span>)</span><br><span class="line">    items = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> chars.items():</span><br><span class="line">        items.append(&#123;</span><br><span class="line">            <span class="string">&#x27;text&#x27;</span>: char.text().strip(),</span><br><span class="line">            <span class="string">&#x27;left&#x27;</span>: <span class="built_in">int</span>(re.search(<span class="string">&#x27;(\d+)px&#x27;</span>, char.attr(<span class="string">&#x27;style&#x27;</span>)).group(<span class="number">1</span>))  <span class="comment"># 提取style属性值</span></span><br><span class="line">        &#125;)</span><br><span class="line">    items = <span class="built_in">sorted</span>(items, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;left&#x27;</span>], reverse=<span class="literal">False</span>)  <span class="comment"># 字典排序</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([item.get(<span class="string">&#x27;text&#x27;</span>) <span class="keyword">for</span> item <span class="keyword">in</span> items])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider3.scrape.center/&#x27;</span>)</span><br><span class="line">WebDriverWait(browser, <span class="number">10</span>) \</span><br><span class="line">    .until(EC.presence_of_all_elements_located((By.CSS_SELECTOR, <span class="string">&#x27;.item&#x27;</span>)))</span><br><span class="line">html = browser.page_source</span><br><span class="line">doc = pq(html)</span><br><span class="line">names = doc(<span class="string">&#x27;.item .name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name_html <span class="keyword">in</span> names.items():</span><br><span class="line">    name = parse_name(name_html)</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<p>以上代码不多做解释，最终最终的运行效果就没错了，可是我们发现，少了几个标题，然后内容之间还有空余，我们来看看源代码:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bPXurD"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/24/bPXurD.png"
                      alt="bPXurD.png"
                ></a><br>经过观察，我们发现内部没有span节点的h3标题节点都带有一个额外的取值为name whole的class属性，其余标题节点都分为了一个个span节点，搞清楚了问题所在，接下来稍加判断即可，改写解析方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_name</span>(<span class="params">name_html</span>):</span>  <span class="comment"># name_html:标题的HTML文本</span></span><br><span class="line">    has_whole = name_html(<span class="string">&#x27;.whole&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> has_whole:</span><br><span class="line">        <span class="keyword">return</span> name_html.text()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        chars = name_html(<span class="string">&#x27;.char&#x27;</span>)</span><br><span class="line">        items = []</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> chars.items():</span><br><span class="line">            items.append(&#123;</span><br><span class="line">                <span class="string">&#x27;text&#x27;</span>: char.text().strip(),</span><br><span class="line">                <span class="string">&#x27;left&#x27;</span>: <span class="built_in">int</span>(re.search(<span class="string">&#x27;(\d+)px&#x27;</span>, char.attr(<span class="string">&#x27;style&#x27;</span>)).group(<span class="number">1</span>))  <span class="comment"># 提取style属性值</span></span><br><span class="line">            &#125;)</span><br><span class="line">        items = <span class="built_in">sorted</span>(items, key=<span class="keyword">lambda</span> x: x[<span class="string">&#x27;left&#x27;</span>], reverse=<span class="literal">False</span>)  <span class="comment"># 字典排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join([item.get(<span class="string">&#x27;text&#x27;</span>) <span class="keyword">for</span> item <span class="keyword">in</span> items])</span><br></pre></td></tr></table></figure>

<p>这样我们就成功爬取了书籍网站上的每本书的名称，刚刚用火狐使了下，下面看看效果:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bPvqVe"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/24/bPvqVe.png"
                      alt="bPvqVe.png"
                ></a></p>
<h3 id="字体反爬案例分析与爬取实战"><a href="#字体反爬案例分析与爬取实战" class="headerlink" title="字体反爬案例分析与爬取实战"></a>字体反爬案例分析与爬取实战</h3><p>接下来我们再分析一个反爬案例，该案例将真实的数据隐藏到字体文件里，使我们即使获取到了页面源代码，也没法直接提取数据的真实值</p>
<h4 id="案例导入-1"><a href="#案例导入-1" class="headerlink" title="案例导入"></a>案例导入</h4><p>案例网站: <a class="link"   target="_blank" rel="noopener" href="https://antispider4.scrape.center/" >https://antispider4.scrape.center/<i class="fas fa-external-link-alt"></i></a></p>
<p>我们先按正常的逻辑来爬取一些信息，例如电影标题、类别、评分等，代码实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider4.scrape.center/&#x27;</span>)</span><br><span class="line">WebDriverWait(browser, <span class="number">10</span>) \</span><br><span class="line">    .until(EC.presence_of_all_elements_located((By.CSS_SELECTOR, <span class="string">&#x27;.item&#x27;</span>)))</span><br><span class="line">html = browser.page_source</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(<span class="string">&#x27;.item&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items.items():</span><br><span class="line">    name = item(<span class="string">&#x27;.name&#x27;</span>).text()</span><br><span class="line">    categories = [o.text() <span class="keyword">for</span> o <span class="keyword">in</span> item(<span class="string">&#x27;.categories button&#x27;</span>).items()]</span><br><span class="line">    score = item(<span class="string">&#x27;.score&#x27;</span>).text()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;name: <span class="subst">&#123;name&#125;</span> categories: <span class="subst">&#123;categories&#125;</span> score: <span class="subst">&#123;score&#125;</span>&#x27;</span>)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<p>运行结果如下，我们发现score看不到任何东西，但是在页面上是能看到的啊:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bPxUsK"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/24/bPxUsK.png"
                      alt="bPxUsK.png"
                ></a></p>
<p>经过观察，我们发现评分对应的源代码并不包含数字信息，如下图所示:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bPxTWn"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/24/bPxTWn.png"
                      alt="bPxTWn.png"
                ></a></p>
<p>span节点中啥也没有，那自然提取不出来了，那页面上的评分是怎么显示出来的呢，其实也是CSS在搞鬼</p>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>我们观察源码得到，各个span节点的不同之处在于内部i节点的class取值不太一样；可以看到下图中一共有3个span节点，对应的class取值分别是icon-789、icon-981和icon-504，这和显示出来的9.5有什么关系呢？</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/biSCNQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/24/biSCNQ.png"
                      alt="biSCNQ.png"
                ></a></p>
<p>会发现i节点内部有一个::before字段，在CSS中，该字段用于创建一个伪节点，即这个节点和i节点或者span节点不一样；::before可以往特定的节点中插入内容，同时在CSS中使用content字段定义这个内容；我们在第一个i节点里看到了9这个数字，再观察另外两个i节点，可以看到，这三个组合起来就是9.5</p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>那class的取值和content字段值的映射关系是怎么定义的呢，我们可以在浏览器中追踪CSS源代码，代码文件如下图标注所示:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bipCqK"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/24/bipCqK.png"
                      alt="bipCqK.png"
                ></a></p>
<p>进入文件之后，我们可以看到整个CSS源代码都放在一行，点击”{}”按钮格式化代码，如下图所示:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bip8iQ"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/24/bip8iQ.png"
                      alt="bip8iQ.png"
                ></a></p>
<p>我们可以在其中找出如下内容:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/biPJRH"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/24/biPJRH.png"
                      alt="biPJRH.png"
                ></a></p>
<p>原来class对应的值就是一个个评分结果，这样我们就有底了，只需要解析对应的结果再做转换即可；这里需要读取CSS文件并提取映射关系，这个CSS文件是: <a class="link"   target="_blank" rel="noopener" href="https://spa2.scrape.center/css/app.ea9d802a.css%EF%BC%8C%E5%85%B6%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA" >https://spa2.scrape.center/css/app.ea9d802a.css，其部分内容如下所示<i class="fas fa-external-link-alt"></i></a>:</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bFmegK"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://s4.ax1x.com/2022/02/24/bFmegK.png"
                      alt="bFmegK.png"
                ></a></p>
<p>我们可以试着用requsest库读取结果，并通过正则表达式将映射关系提取出来，代码实现如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;https://antispider4.scrape.center/css/app.654ba59e.css&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;.icon-(.*?):before\&#123;content:&quot;(.*?)&quot;\&#125;&#x27;</span>)</span><br><span class="line">results = re.findall(pattern, response.text)</span><br><span class="line">icon_map = &#123;item[<span class="number">0</span>]: item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> results&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们首先使用request库提取了CSS文件的内容，然后使用了正则表达式进行了文本匹配，表达式写作:<code>.icon-(.*?):before\&#123;content:&quot;(.*?)&quot;\&#125;</code>，这个表达式并没有考虑空格，因为CSS源代码本身就没有空格</p>
<p>以上结果就类似:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;at&quot;</span>: <span class="string">&quot;@&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A&quot;</span>: <span class="string">&quot;A&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如使用789索引，得到的结果就是9:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(icon_map[<span class="string">&#x27;789&#x27;</span>])  <span class="comment"># 9</span></span><br></pre></td></tr></table></figure>

<p>所以我们只需要修改下逻辑，代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;https://antispider4.scrape.center/css/app.654ba59e.css&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;.icon-(.*?):before\&#123;content:&quot;(.*?)&quot;\&#125;&#x27;</span>)</span><br><span class="line">results = re.findall(pattern, response.text)</span><br><span class="line">icon_map = &#123;item[<span class="number">0</span>]: item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> results&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_score</span>(<span class="params">item</span>):</span></span><br><span class="line">    elements = item(<span class="string">&#x27;.icon&#x27;</span>)</span><br><span class="line">    icon_values = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> elements.items():</span><br><span class="line">        class_name = (element.attr(<span class="string">&#x27;class&#x27;</span>))</span><br><span class="line">        icon_key = re.search(<span class="string">&#x27;icon-(\d+)&#x27;</span>, class_name).group(<span class="number">1</span>)</span><br><span class="line">        icon_value = icon_map.get(icon_key)</span><br><span class="line">        icon_values.append(icon_value)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(icon_values)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://antispider4.scrape.center/&#x27;</span>)</span><br><span class="line">WebDriverWait(browser, <span class="number">10</span>) \</span><br><span class="line">    .until(EC.presence_of_all_elements_located((By.CSS_SELECTOR, <span class="string">&#x27;.item&#x27;</span>)))</span><br><span class="line">html = browser.page_source</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(<span class="string">&#x27;.item&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items.items():</span><br><span class="line">    name = item(<span class="string">&#x27;.name&#x27;</span>).text()</span><br><span class="line">    categories = [o.text() <span class="keyword">for</span> o <span class="keyword">in</span> item(<span class="string">&#x27;.categories button&#x27;</span>).items()]</span><br><span class="line">    score = parse_score(item)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;name: <span class="subst">&#123;name&#125;</span> categories: <span class="subst">&#123;categories&#125;</span> score: <span class="subst">&#123;score&#125;</span>&#x27;</span>)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个parse_score方法，它接收一个Pyquery对象item，对应着一个电影条目；首先提取item中所有带icon这个class的节点，然后遍历这些节点，从class属性里提取对应的icon代号，例如icon-789，提取的结果就是789，和我们刚刚构造的icon_map是相对应的，将其赋值给icon_key，然后使用icon_key从icon_map中查找对应的真实值，赋值为icon_value，最后将icon_value拼合成一个字符串返回</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：Python3网络爬虫开发实战第二版第7章-JavaScript动态渲染页面抓取</li>
        <li>Post author：Lhj</li>
        <li>Create time：2022-02-11 10:09:30</li>
        <li>
            Post link：https://keep.xpoet.cn/2022/02/11/Python3网络爬虫开发实战第二版第7章-JavaScript动态渲染页面抓取/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/02/14/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC8%E7%AB%A0-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E8%AF%86%E5%88%AB/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Python3网络爬虫开发实战第二版第8章-验证码的识别</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/02/09/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC6%E7%AB%A0-%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Python3网络爬虫开发实战第二版第6章-异步爬虫</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'nIcO1O6cSVuRH8EROCWwNFWN-gzGzoHsz',
                    appKey: 'qrglokTeum8DXiYRzM4k4NF4',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '😜 尽情吐槽吧~',
                    lang: 'en'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'Lhj';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Lhj</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        $tools-item-width = 32px;
$tools-item-font-size = 1.1rem;
$tools-item-border-radius = 1px;


.side-tools-container {
  position: relative;

  .tools-item {
    width: $tools-item-width;
    height: $tools-item-width;
    font-size: $tools-item-font-size;
    margin-bottom: 3px;
    cursor: pointer;
    border-right: none;
    border-radius: $tools-item-border-radius;
    box-shadow: 1px 1px 3px var(--shadow-color);
    color: var(--default-text-color);
    background: var(--background-color);

    i {
      color: var(--default-text-color);
    }

    &:hover {
      color: var(--background-color);
      background: var(--primary-color);
      box-shadow: 2px 2px 6px var(--shadow-color);

      i {
        color: var(--background-color);
      }
    }

    +keep-tablet() {
      width: $tools-item-width * 0.9;
      height: $tools-item-width * 0.9;
      font-size: $tools-item-font-size * 0.9;
      margin-bottom: 2px;
    }

    &.rss {

      a {
        border-radius: $tools-item-border-radius;
        width: 100%;
        height: 100%;

        &:hover {
          color: var(--background-color);
          background: var(--primary-color);
          box-shadow: 2px 2px 6px var(--shadow-color);
        }
      }
    }
  }


  .side-tools-list {
    opacity: 0;
    transform: translateX(100%);
    transition-t("transform, opacity", "0, 0", "0.2, 0.2", "linear, linear");

    .tool-expand-width {
      +keep-tablet() {
        display: none;
      }
    }


    &.show {
      opacity: 1;
      transform: translateX(0);
    }
  }


  .exposed-tools-list {

    if (hexo-config('style.scroll.percent.enable') == true) {
      .tool-scroll-to-top {
        display: none;

        &.show {
          display: flex;
        }

        &:hover {

          .percent {
            display: none;
          }

          .arrow-up {
            display: flex;
          }

        }

        .arrow-up {
          display: none;
        }

        .percent {
          display: flex;
          font-size: 1rem;
        }

      }

    }
  }
}

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Selenium%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">Selenium的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.</span> <span class="nav-text">初始化浏览器对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2"><span class="nav-number">1.4.</span> <span class="nav-text">访问页面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9"><span class="nav-number">1.5.</span> <span class="nav-text">查找节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.5.1.</span> <span class="nav-text">单个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.5.2.</span> <span class="nav-text">多个节点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8A%82%E7%82%B9%E4%BA%A4%E4%BA%92"><span class="nav-number">1.6.</span> <span class="nav-text">节点交互</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E4%BD%9C%E9%93%BE"><span class="nav-number">1.7.</span> <span class="nav-text">动作链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8CJavaScript"><span class="nav-number">1.8.</span> <span class="nav-text">运行JavaScript</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF"><span class="nav-number">1.9.</span> <span class="nav-text">获取节点信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E6%8D%A2Frame"><span class="nav-number">1.10.</span> <span class="nav-text">切换Frame</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E6%97%B6%E7%AD%89%E5%BE%85"><span class="nav-number">1.11.</span> <span class="nav-text">延时等待</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80"><span class="nav-number">1.12.</span> <span class="nav-text">前进和后退</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie"><span class="nav-number">1.13.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E9%A1%B9%E5%8D%A1%E7%AE%A1%E7%90%86"><span class="nav-number">1.14.</span> <span class="nav-text">选项卡管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.15.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B1%8F%E8%94%BD"><span class="nav-number">1.16.</span> <span class="nav-text">反屏蔽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%A4%B4%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.17.</span> <span class="nav-text">无头模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Splash%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">Splash的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">功能介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C-1"><span class="nav-number">2.2.</span> <span class="nav-text">准备工作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pyppeteer%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">Pyppeteer的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Pyppeteer%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.</span> <span class="nav-text">Pyppeteer介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">3.2.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="nav-number">3.3.</span> <span class="nav-text">快速上手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#launch%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">launch方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%A4%B4%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">3.5.</span> <span class="nav-text">无头模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.6.</span> <span class="nav-text">调试模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%81%E7%94%A8%E6%8F%90%E7%A4%BA%E6%9D%A1"><span class="nav-number">3.7.</span> <span class="nav-text">禁用提示条</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E6%A3%80%E6%B5%8B"><span class="nav-number">3.8.</span> <span class="nav-text">防止检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.9.</span> <span class="nav-text">页面大小设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">3.10.</span> <span class="nav-text">用户数据持久化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Browser"><span class="nav-number">3.11.</span> <span class="nav-text">Browser</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E6%97%A0%E7%97%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.12.</span> <span class="nav-text">开启无痕模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%97%AD"><span class="nav-number">3.13.</span> <span class="nav-text">关闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Page"><span class="nav-number">3.14.</span> <span class="nav-text">Page</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.15.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Playwright%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">Playwright的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Playwright%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">4.1.</span> <span class="nav-text">Playwright的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-1"><span class="nav-number">4.2.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">4.4.</span> <span class="nav-text">代码生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="nav-number">4.5.</span> <span class="nav-text">支持移动端浏览器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">4.6.</span> <span class="nav-text">选择器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E9%80%89%E6%8B%A9"><span class="nav-number">4.6.1.</span> <span class="nav-text">文本选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CSS%E9%80%89%E6%8B%A9%E5%99%A8"><span class="nav-number">4.6.2.</span> <span class="nav-text">CSS选择器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CSS-%E9%80%89%E6%8B%A9%E5%99%A8-%E6%96%87%E6%9C%AC"><span class="nav-number">4.6.3.</span> <span class="nav-text">CSS 选择器 + 文本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CSS-%E9%80%89%E6%8B%A9%E5%99%A8-%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB"><span class="nav-number">4.6.4.</span> <span class="nav-text">CSS 选择器 + 节点关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Xpath"><span class="nav-number">4.6.5.</span> <span class="nav-text">Xpath</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-number">4.7.</span> <span class="nav-text">常用操作方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="nav-number">4.7.1.</span> <span class="nav-text">事件监听</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E6%BA%90%E7%A0%81"><span class="nav-number">4.7.2.</span> <span class="nav-text">获取页面源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%82%B9%E5%87%BB"><span class="nav-number">4.7.3.</span> <span class="nav-text">页面点击</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5"><span class="nav-number">4.7.4.</span> <span class="nav-text">文本输入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="nav-number">4.7.5.</span> <span class="nav-text">获取节点属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">4.7.6.</span> <span class="nav-text">获取多个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">4.7.7.</span> <span class="nav-text">获取单个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%8A%AB%E6%8C%81"><span class="nav-number">4.7.8.</span> <span class="nav-text">网络劫持</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Selenium%E7%88%AC%E5%8F%96%E5%AE%9E%E6%88%98"><span class="nav-number">5.</span> <span class="nav-text">Selenium爬取实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pyppeteer%E7%88%AC%E5%8F%96%E5%AE%9E%E6%88%98"><span class="nav-number">6.</span> <span class="nav-text">Pyppeteer爬取实战</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS%E4%BD%8D%E7%BD%AE%E5%81%8F%E7%A7%BB%E5%8F%8D%E7%88%AC%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E7%88%AC%E5%8F%96%E5%AE%9E%E6%88%98"><span class="nav-number">7.</span> <span class="nav-text">CSS位置偏移反爬案例分析与爬取实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%AF%BC%E5%85%A5"><span class="nav-number">7.1.</span> <span class="nav-text">案例导入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E6%9F%A5"><span class="nav-number">7.2.</span> <span class="nav-text">排查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%AC%E5%8F%96"><span class="nav-number">7.3.</span> <span class="nav-text">爬取</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E4%BD%93%E5%8F%8D%E7%88%AC%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E7%88%AC%E5%8F%96%E5%AE%9E%E6%88%98"><span class="nav-number">8.</span> <span class="nav-text">字体反爬案例分析与爬取实战</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%AF%BC%E5%85%A5-1"><span class="nav-number">8.1.</span> <span class="nav-text">案例导入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">8.2.</span> <span class="nav-text">案例分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%88%98"><span class="nav-number">8.3.</span> <span class="nav-text">实战</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
