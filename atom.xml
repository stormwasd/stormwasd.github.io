<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-13T09:40:28.394Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js混淆-动态cookie题目详解</title>
    <link href="http://example.com/2022/01/13/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/01/13/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-01-13T08:11:30.000Z</published>
    <updated>2022-01-13T09:40:28.394Z</updated>
    
    <content type="html"><![CDATA[<p>第二题是js混线，动态cookie，这也是提取全部5页的数据，题目链接:<a class="link"   href="https://match.yuanrenxue.com/match/2" >https://match.yuanrenxue.com/match/2<i class="fas fa-external-link-alt"></i></a></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-13-29.3z6b7ki67ye0.webp"                      alt="Snipaste_2022-01-13_16-13-29"                ></p><p>我们先来抓下包叭，打开F12同样会在断点处断住，然后我们只需要右键点击Never parsed here即可，随后我们可以看到第一页的十条数据</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-19-31.7krfqxq74xc0.webp"                      alt="Snipaste_2022-01-13_16-19-31"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-21-02.2xas5aqu4jm0.webp"                      alt="Snipaste_2022-01-13_16-21-02"                ></p><p>这是个xhr请求，而且它只有一个参数page</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-22-37.38mf806puvs0.webp"                      alt="Snipaste_2022-01-13_16-22-37"                ></p><p>实际上这个题它这边已经说了是个动态cookie，所以是一定要有cookie才能去访问的，然后，一般情况下，如果我们碰到一个类似的网页，如果只是当时即时使用的话可以直接复制这个cookie去拿数据，但我们都知道cookie是具有一定时效性的，时间久了这种操作是不可取的，所以我们就需要去分析cookie是怎么来的，是本地生成的还是服务器返回的一个set-cookie，如果是服务器返回的，那就可以模拟浏览器的请求去开一个session即可，如果是本地生成的话就得分析cookie是怎么本地生成的，然后把这个cookie给它凑出来，扣js或者是怎么样把这个cookie给生成出来，如果是两种方法都有的话那就两种方法结合起来用</p><p>我们继续抓一下包，点击第二页会弹出一个框说cookie失效，说明合格cookie的有效期是比较短的，点击确定后就会获取一个新的cookie，然后进入页面，以下是第一页抓到的包，我们看到这边是有cookie的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-39-04.184fqz9f177g.webp"                      alt="Snipaste_2022-01-13_16-39-04"                ></p><p>然后我们要拿到的数据就是它返回的数据，也就是Preview中的数据</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-43-10.4q3e6sbq69w0.webp"                      alt="Snipaste_2022-01-13_16-43-10"                ></p><p>未完待续</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第二题是js混线，动态cookie，这也是提取全部5页的数据，题目链接:&lt;a class=&quot;link&quot;   href=&quot;https://match.yuanrenxue.com/match/2&quot; &gt;https://match.yuanrenxue.com/match/2&lt;i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js混淆-源码乱码题目详解</title>
    <link href="http://example.com/2022/01/13/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/01/13/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-01-13T03:16:30.000Z</published>
    <updated>2022-01-13T07:11:35.202Z</updated>
    
    <content type="html"><![CDATA[<p>我们打开猿人学的刷题网站:<a class="link"   href="https://match.yuanrenxue.com/list" >https://match.yuanrenxue.com/list<i class="fas fa-external-link-alt"></i></a></p><p>我们先来看第一题，第一题是关于js混淆的，这题目看着就比较有意思，我们来看看</p><p>首先我们打开一题，然后按F12打开调试，发现这边一打开就有个断点</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_14-43-50.41jvk3e1uyw0.webp"                      alt="Snipaste_2022-01-13_14-43-50"                ></p><p>然后我们可以在设置间隔的函数中把debugger给跳过(右键点击Never pause here)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_14-52-31.5g4rrskb28g0.webp"                      alt="Snipaste_2022-01-13_14-52-31"                ></p><p>我们过掉这个debug之后，重新抓下包，可以看到1到3页都是有的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_14-57-38.1zslirmzf2bk.webp"                      alt="Snipaste_2022-01-13_14-57-38"                ></p><p>点击第四页就会弹出一个弹窗</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_14-58-42.76ac9zzw4as.webp"                      alt="Snipaste_2022-01-13_14-58-42"                ></p><p>可以看到这边有个payload，我们主要要解这m参数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_15-07-26.3pmquafpveg.webp"                      alt="Snipaste_2022-01-13_15-07-26"                ></p><p>这个参数的话竖线后面是一个时间戳</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们打开猿人学的刷题网站:&lt;a class=&quot;link&quot;   href=&quot;https://match.yuanrenxue.com/list&quot; &gt;https://match.yuanrenxue.com/list&lt;i class=&quot;fas fa-external-link-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件构建CMake 快速入门</title>
    <link href="http://example.com/2022/01/13/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BACMake%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/13/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BACMake%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-13T01:26:20.000Z</published>
    <updated>2022-01-13T03:12:31.744Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来讲一下软件构建工具，无论你用的是什么平台、什么编程语言，构建(Build)都是软件开发中必不可少的一个步骤</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-28-51.4r66svbqwbs0.webp"                      alt="Snipaste_2022-01-13_09-28-51"                ></p><p>如果你的项目只有一个源文件，我们当然可以用一行命令完成编译、链接的整个过程</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-32-52.llvqtbn80cg.webp"                      alt="Snipaste_2022-01-13_09-32-52"                ></p><p>但如果你面对的是一个复杂的项目，其中包含不同的模块、组件，每个组件由若干个源文件组成，里面还用到了不少的第三方库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-35-14.37bgecfd1z80.webp"                      alt="Snipaste_2022-01-13_09-35-14"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-35-43.69948jblt2o0.webp"                      alt="Snipaste_2022-01-13_09-35-43"                ></p><p>这时候如果我们再去手动编译链接，将会非常的低效，而软件构建所做的就是全自动完成代码编译、链接、打包的整个过程，并且还能管理不同组件、甚至包括第三方库的关联，我们平时使用的IDE大多都内置了构建系统，只是我们没有留意罢了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-39-11.6ihfm3a2r600.webp"                      alt="Snipaste_2022-01-13_09-39-11"                ></p><p>每一个构建工具通常有各自擅长的领域，如果你在VS中做C++开发，那么多半用到的是微软自己的MSBuild</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-41-13.48jcqdensgo0.webp"                      alt="Snipaste_2022-01-13_09-41-13"                ></p><p>如果你使用Android Stuiod写移动端的程序，那么多半用到的是Gradle等等</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-42-27.50s3cij5n1k0.webp"                      alt="Snipaste_2022-01-13_09-42-27"                ></p><p>当然还有一些更复杂、更万能的构建系统，比如Bazel、BUCK</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-43-44.26b508ka13gg.webp"                      alt="Snipaste_2022-01-13_09-43-44"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-44-13.5gr7yq3g6yg0.webp"                      alt="Snipaste_2022-01-13_09-44-13"                ></p><p>它们试图使用单个工具来完成各种语言在不同环境下的构建，今天我会以CMake为例专门介绍一下C和C++程序的构建</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-46-02.1ya1r6riui2o.webp"                      alt="Snipaste_2022-01-13_09-46-02"                ></p><p>它是一个被广泛使用的、开源免费使用并且完全跨平台的构建工具，如果你希望在不同平台上编译运行你的软件，以后就不再需要手动配置Makefile，vs或者Xcode工程了，我们今天讲到的CMake会自动帮你做到这一切</p><p> 首先我们看看CMake的安装，我们可以直接在官网下载最新的安装包</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-51-20.3nd1mselb9o0.webp"                      alt="Snipaste_2022-01-13_09-51-20"                ></p><p>也可以使用操作系统自带的包管理工具</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-51-20.3nd1mselb9o0.webp"                      alt="Snipaste_2022-01-13_09-51-20"                ></p><p>随后可以试着在命令行中输入CMake命令</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-53-54.6mcka3o1hq80.webp"                      alt="Snipaste_2022-01-13_09-53-54"                ></p><p>这里如果找不到命令的话可能还需要手动配置安装路径到PATH环境变量下</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-54-33.5syfzrje21k.webp"                      alt="Snipaste_2022-01-13_09-54-33"                ></p><p>另外我们要确保计算机上安装有C++的编译工具，比如windows下的MSBuild工具链或者直接安装Visual Studio，在Linux下则需要安装gcc或者clang等等，这是因为CMake自身是不带编译工具的，他会根据你编写的构建规则，也就是我们马上要讲道德CMakeLists文件，来自动生成目标平台下的原生工程文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_09-59-25.7e55kb6z1yc0.webp"                      alt="Snipaste_2022-01-13_09-59-25"                ></p><p>比如windows下的VS工程或者Linux下的Makefile等等，因此要顺利完成编译，C++工具链是必不可少的，接下来我会从最简单的，只有单个源文件的例子来介绍CMake的基本用法，最后我会用之前视频中创建的一个黑洞渲染的工程，来讲解相对复杂一点的情况，刚好这个工程包含多个源文件、图片资源还会有一些第三方库，因此更加贴近与实际项目一些</p><p>首先我们要做的第一件事是在项目的根目录下创建一个CMakeLists.txt文件，对于一个最简单的、只有一个源文件的工程，这三行代码是必不可少的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-07-17.6e4og08tza00.webp"                      alt="Snipaste_2022-01-13_10-07-17"                ></p><p>首先第一行指定了构建项目所需的最低CMake版本，第二行指定了工程的名字，我们随后输出的可执行文件也会和它同一个名称</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-09-44.4prnh08hhf0.webp"                      alt="Snipaste_2022-01-13_10-09-44"                ></p><p>第三行表示我们的项目需要构建一个可执行文件，并且它由main.cpp编译而成</p><p>随后我们需要根据这个CMakeList文件生成目标平台下的原生工程，这个过程在CMake中叫做”配置”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-11-50.5lh2kup3dm80.webp"                      alt="Snipaste_2022-01-13_10-11-50"                ></p><p>我们可以在菜单中找到CMake Configure命令</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-14-39.6gbnapdrz6w0.webp"                      alt="Snipaste_2022-01-13_10-14-39"                ></p><p>或者VScode在打开项目时会自动提示你进行项目“配置”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-15-56.60lvfdsl9cg0.webp"                      alt="Snipaste_2022-01-13_10-15-56"                ></p><p>我们只需要选择平台原生的C++构建工具然后等待配置完成即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-17-41.xscb8wyamy8.webp"                      alt="Snipaste_2022-01-13_10-17-41"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-19-13.4hyns6v2b8c0.webp"                      alt="Snipaste_2022-01-13_10-19-13"                ></p><p>接下来到了真正构建环节</p><p>这里我们可以使用快捷键F7，或者在菜单中运行CMake: Build命令</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-21-37.6r7j7wyyoeo0.webp"                      alt="Snipaste_2022-01-13_10-21-37"                ></p><p>如果一切顺利的话，面板中会输出成功编译的可执行文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-22-40.3ssas4n706k0.webp"                      alt="Snipaste_2022-01-13_10-22-40"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-23-18.un7g3s9i5cg.webp"                      alt="Snipaste_2022-01-13_10-23-18"                ></p><p>另外我们所做的“配置”和“构建”操作都有对应的命令行指令，我们也可以在输出面板中找到它们</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-24-58.2gwvtoonrl40.webp"                      alt="Snipaste_2022-01-13_10-24-58"                ></p><p>在通常情况下，使用菜单或者图形界面自然更方便一些，但入股哦我们想在服务器上做持续继承(CI)，进行自动化的编译和测试，这里的命令行就格外有用了</p><p>接下来，我们来看第二个相对复杂一点的工程配置，之前我们讲到这个工程包含了多个源文件、图片资源还有一些第三方库，因此这里的CmakeLists也会相对复杂一些</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-30-09.5w098ggtap40.webp"                      alt="Snipaste_2022-01-13_10-30-09"                ></p><p>首先前两行和我们之前讲到的完全一样，它们定义了CMake最低版本和工程文件名，随后映入眼帘的是一系列的find_package()命令，它会在你的计算机中寻找符合要求的第三方库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-33-08.i325z0d4cg0.webp"                      alt="Snipaste_2022-01-13_10-33-08"                ></p><p>首先你需要确保计算机中事先安装好了它们</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-34-24.757o3s9eb4k0.webp"                      alt="Snipaste_2022-01-13_10-34-24"                ></p><p>关于库的安装我后面再说</p><p>其次这些库也需要支持用CMake进行构建，这个一般没有问题，因为大多数常见的C++库都提供了CMake的支持，这个命令的第一个参数是各个库的名字，后面的REQUIRED代表这个库是必须的，如果计算机中没有安装则会直接报错</p><p>我们继续来看后面这个命令，由于这个项目由多个源文件组成，所以我们先调用file GLOB命令通过通配符匹配所有的C++源文件，并将它存放在变量SRC_FILE中，随后我们调用相同的add_executable()命令来构建一个可执行文件，第一个参数是工程文件的名字，这里的CMAKE_PROJECT_NAME是一个宏，会被自动替换成这里的工程名Blackhole，第二个禅师则是我们之前匹配的所有源文件</p><p>由于我们项目用到了一些第三方库，所以自然少不了链接(Link)库的操作</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-49-11.40jxqoj5oli0.webp"                      alt="Snipaste_2022-01-13_10-49-11"                ></p><p>如果忘记了这个步骤，那么你应该会遇到经典的符号无法解析的错误</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-50-31.5fqvyvhzjdk0.webp"                      alt="Snipaste_2022-01-13_10-50-31"                ></p><p>并且由于我们项目用到了C++17以上的语法，所以这里需要通过target_compile_fetures()打开对C++17的支持，最后我们用到这个命令add_custom_command</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-53-45.73e3byhz3s80.webp"                      alt="Snipaste_2022-01-13_10-53-45"                ></p><p>这里的POST_BUILD也就是字面意思代表编译之后要执行的操作，我们会调用CMake命令将根目录下的assets文件夹拷贝到输出路径下</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-57-02.1yww4k1wrcqo.webp"                      alt="Snipaste_2022-01-13_10-57-02"                ></p><p>这一步只是一个简单的自动化，避免了文件的手动复制，这样在构建完成之后我们可以在输出路径下找到应用所需所有文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-58-46.38dd3y0fzhe0.webp"                      alt="Snipaste_2022-01-13_10-58-46"                ></p><p>在最后我们来讲下C++第三方库的安装</p><p>由于CMake只是一个构建工具，它并不包含库的安装和管理，如果我们的项目用到了第三方库，则需要确保计算机中事先安装好了它们，常见的安装方式有直接下载库的源文件，然后手动构建并指定CMake库的路径，当然对于Linux和mac我们也可以直接通过包管理工具安装，不过缺点是，每安装一个库都需要执行许多繁琐的步骤，并且不同平台下的配置过程也不太一样，因此这里推荐一个微软的开源工具vcpkg</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_11-05-25.2s4onmlme0o0.webp"                      alt="Snipaste_2022-01-13_11-05-25"                ></p><p>虽然名字叫vcpkg，不过它是一个跨平台的C++库管理工具，类似Python的pip，你要做的是先调用vcpkg install 安装第三方库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_11-07-26.65cbb60k54w0.webp"                      alt="Snipaste_2022-01-13_11-07-26"                ></p><p>然后在CMake构建的时候指定vcpkg工具链即可，如果你用过的是命令行，只需要额外传递一个参数CMAKE_TOOLCHAIN_FILE</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_11-09-04.a738lwx508g.webp"                      alt="Snipaste_2022-01-13_11-09-04"                ></p><p>如果你用的是vscode插件，那么在设置中添加这个路径即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_11-10-02.3kbngsv7tv40.webp"                      alt="Snipaste_2022-01-13_11-10-02"                ></p><p>关于vcpkg的安装步骤大家可以参考官方详细的文档</p><p>CMake其实是一个非常灵活但也非常复杂的工具，这个最好还是边学边用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天我们来讲一下软件构建工具，无论你用的是什么平台、什么编程语言，构建(Build)都是软件开发中必不可少的一个步骤&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python实例方法、类方法、静态方法的区别与作用</title>
    <link href="http://example.com/2022/01/13/Python%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2022/01/13/Python%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8/</id>
    <published>2022-01-13T01:08:30.000Z</published>
    <updated>2022-01-13T01:16:33.997Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>实例方法</p><p>定义: 第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法(也可以传类的属性和方法)，简而言之，实例方法就是类的实例能够使用的方法</p><p>调用: 只能由实例对象调用</p></li><li><p>类方法</p><p>定义: 使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法(不能传实例的属性和方法)，原则上，类方法是将类本身作为对象进行操作的方法。假设有个方法，且这个方法在逻辑上采用类本身作为对象来调用更合理，那么这个方法就可以定义为类方法。另外，如果需要继承，也可以定义为类方法</p><p>调用: 实例对象和类对象都可以调用</p></li><li><p>静态方法</p><p>定义: 使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法</p><p>调用: 实例对象和类对象都可以调用</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;实例方法&lt;/p&gt;
&lt;p&gt;定义: 第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法(也可以传类的属性和方法)，简而言之，实例方法就是类的实例能够使用的方法&lt;/p&gt;
&lt;p&gt;调用: 只能由实例对象调用&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>“并发、并行、异步、同步”的区别</title>
    <link href="http://example.com/2022/01/12/%E2%80%9C%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%90%8C%E6%AD%A5%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/01/12/%E2%80%9C%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%90%8C%E6%AD%A5%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-12T09:30:30.000Z</published>
    <updated>2022-01-12T10:52:59.853Z</updated>
    
    <content type="html"><![CDATA[<p>并发、并行、异步、同步，这些术语之间到底有什么区别和联系呢</p><p><a href="https://imgtu.com/i/7K9ibd"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7K9ibd.png"                      alt="7K9ibd.png"                ></a></p><p>首先并发是一个比较宽泛的概念，<strong>它单纯地代表计算机能够同时执行多项任务</strong></p><p><a href="https://imgtu.com/i/7K9aMF"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7K9aMF.png"                      alt="7K9aMF.png"                ></a></p><p>至于计算机怎么做到“并发”则有许多不同的形式，比如对于一个单核处理器，计算机可以通过分配时间片的方式，让一个任务运行一段时间，然后切换另一个任务，再运行一段时间，不同的任务会这样交替往复地一直执行下去，这个过程也被称作是进程或者线程的上下文切换(context switching)</p><p><a href="https://imgtu.com/i/7KCgkn"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KCgkn.png"                      alt="7KCgkn.png"                ></a></p><p>当然对于多核处理器，情况就有所不同了，我们<strong>可以在不同的核心上真正并行地执行任务，而不用通过分配时间片的方式运行</strong>，这种情况也就是我们所说的并行(parallelism)</p><p><a href="https://imgtu.com/i/7KPlhq"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KPlhq.png"                      alt="7KPlhq.png"                ></a></p><p>至于同步和异步则是两种不同的编程模型，<strong>“同步”代表需要等到必须前一个任务执行完毕之后才能进行下一个任务</strong>，因此在同步中并没有并发或者并行的概念，而<strong>“异步“”则代表不同的任务之间并不会相互等待，也就是说，你在执行任务A的时候，也可以同时运行任务B</strong>，一个典型实现异步的方式则是通过多线程编程，你可以创建多个线程，并且启动它们</p><p><a href="https://imgtu.com/i/7Ki7J1"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7Ki7J1.png"                      alt="7Ki7J1.png"                ></a></p><p>在多核的情况下，每个线程就会被分配到独立的核心上运行，实现真正的“并行”，当然如果你使用的是单核处理器，或者通过设置亲和力(Affinity)强制将线程绑定到某个核心上，操作系统则会通过分配时间片的方式来执行这些线程，这些线程依然是在“并发”地执行，当然像某些编程语言，比如JavaScript本身是没有多线程的概念的，不过通过它的函数回调(function callback)机制，我们依然能做到单线程的“并发”，比如你可以通过fetch()同时访问多个网络资源</p><p><a href="https://imgtu.com/i/7Kk5CR"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7Kk5CR.png"                      alt="7Kk5CR.png"                ></a></p><p>我们在调用fetch()函数的时候，程序并不会等待，而会直接继续执行下去，当获取到网路资源以后</p><p><a href="https://imgtu.com/i/7KAMrT"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KAMrT.png"                      alt="7KAMrT.png"                ></a></p><p>回调函数才会被掉起，需要注意的是，虽然主函数和回调函数看起来是同时进行的</p><p><a href="https://imgtu.com/i/7KAgzt"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KAgzt.png"                      alt="7KAgzt.png"                ></a></p><p>但它们依然是运行在同一个线程中</p><p><a href="https://imgtu.com/i/7KEX9A"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KEX9A.png"                      alt="7KEX9A.png"                ></a></p><p>因此通过这种异步编程方式，我们完全可以做到单线程的“并发”，而且这并不是JavaScript的专利，很多语言也都提供了原生的异步编程方式，比如C#，Rusut，C++2.0中的co_await，Python中的asyncio等等等等</p><p><a href="https://imgtu.com/i/7KVgDf"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KVgDf.png"                      alt="7KVgDf.png"                ></a></p><p><a href="https://imgtu.com/i/7KV2b8"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KV2b8.png"                      alt="7KV2b8.png"                ></a></p><p><a href="https://imgtu.com/i/7KVTvq"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KVTvq.png"                      alt="7KVTvq.png"                ></a></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-12_18-39-15.3sta87zfdyg0.webp"                      alt="Snipaste_2022-01-12_18-39-15"                ></p><p>那到这里你肯定会问，对于多线程编程和这种单线程的异步编程，我们应当如何选择呢，简而言之，对于I/O密集型的应用程序，比如Web应用，就会经常执行网络操作，数据库访问，这类应用就非常适合使用异步编程的方式，反之如果我们使用多线程的方式，则会浪费不少的系统资源，因为每个线程的绝大多数时间都是在等待这些I/O操作，而线程自身会占用额外的内存，线程的切换也会有额外的开销，更不用说线程之间的资源竞争问题</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-12_18-46-30.h7nel7qo0fc.webp"                      alt="Snipaste_2022-01-12_18-46-30"                ></p><p>而多线程编程则非常适合于计算量密集的应用</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-12_18-47-43.4urgzy14uec0.webp"                      alt="Snipaste_2022-01-12_18-47-43"                ></p><p>比如视频图像处理，科学计算等等，它能让每一个CPU核心发挥最大的功效，而不是消耗在空闲的等待上</p><p>纠错:</p><p>关于Python的例子我举得不太恰当，CPython中的GIL会导致Python代码的线程并不能做到真正并发，使用htop查看CPU使用率尽管在多核处理器也不会超过100%</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;并发、并行、异步、同步，这些术语之间到底有什么区别和联系呢&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgtu.com/i/7K9ibd&quot;&gt;&lt;img  
                     lazyload
                     src=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一次性搞懂线程同步机制</title>
    <link href="http://example.com/2022/01/12/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/01/12/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</id>
    <published>2022-01-12T07:11:30.000Z</published>
    <updated>2022-01-12T08:54:59.030Z</updated>
    
    <content type="html"><![CDATA[<p>使用线程，我们可以并发地在各个CPU核心上执行任务，最大化CPU的利用率，但线程也可能导致各种奇怪的资源竞争问题</p><p><a href="https://imgtu.com/i/7uaCgP"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uaCgP.png"                      alt="7uaCgP.png"                ></a></p><p>相信大家一定都看过这个经典案例</p><p><a href="https://imgtu.com/i/7uaMvV"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uaMvV.png"                      alt="7uaMvV.png"                ></a></p><p>用不同的线程去更新同一段内存数据，比如我们这里总共创建10个线程</p><p><a href="https://imgtu.com/i/7uaWxP"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uaWxP.png"                      alt="7uaWxP.png"                ></a></p><p>每个线程累加这个数字1000000次，运行程序你会发现得到的结果并不是预期的10000000，实际显示的数字可能会比它小很多，并且每次输出的结果还都不一样</p><p><a href="https://imgtu.com/i/7uaOx0"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uaOx0.png"                      alt="7uaOx0.png"                ></a></p><p>这里我会向大家解释为什么会出现这种情况，以及各种常见的线程同步机制</p><p><a href="https://imgtu.com/i/7udPi9"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7udPi9.png"                      alt="7udPi9.png"                ></a></p><p>我们先来回顾一下刚才的这段程序，其实问题就出在数字累加的这行代码上，虽然在程序中我们简单地写作n++，但是当程序被编译成机器代码时，n++其实被翻译成三条不同的机器指令(machine code)</p><p><a href="https://imgtu.com/i/7uddij"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uddij.png"                      alt="7uddij.png"                ></a></p><p>它们分别是，将内存中的数据加载到CPU的寄存器eax中，然后将eax中的数据+1，最后再将计算结果写回内存，换句话说，这里的n++并不是原子操作(atomic operation)，原子操作指的是不能被继续拆分、或者被其他操作打断的指令，这里顺带解释一下，寄存器(Registers)是CPU内部的小型存储器</p><p><a href="https://imgtu.com/i/7uwgjP"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uwgjP.png"                      alt="7uwgjP.png"                ></a></p><p>用来临时存放计算数据，CPU中的运算都离不开寄存器，它们的容量非常有限，但读写速度会比内存快很多，回到刚才的代码，如果不同的线程按照顺序依次执行</p><p>比如线程A先将数据5读入寄存器，然后+1得到6并写回内存，然后线程B再将数据6读入寄存器，+1得到7并写回内存，这样没有任何问题，但问题在于线程是并发执行的</p><p><a href="https://imgtu.com/i/7u05qK"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u05qK.png"                      alt="7u05qK.png"                ></a></p><p>可能线程A还未将累加后的数据写会内存，线程B就已经开始读取数据到寄存器，这样线程B就会读到修改之前的旧数据，最后的结果是数据只被累加了一次，这个就是我们平时说的线程资源竞争而导致的数据不一致问题，要解决这个问题，我们需要对线程进行同步，也就是让原先异步的操作依次有序地执行，而锁(lock)是我们接下来要讲的第一种，也是最最基本的线程同步机制，它的概念非常简单，<strong>在同一时间，只有一个线程可以获得(acquire)锁的拥有权(ownership)，此时其他的线程只能干等着，直到这个锁被持有者释放掉(release)</strong></p><p><a href="https://imgtu.com/i/7usuo8"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7usuo8.png"                      alt="7usuo8.png"                ></a></p><p>锁的获取和释放有时候也被叫做上锁(lock)和解锁(unlock)，在不同的语言或者操作系统中，通常会用到不同的锁的实现，比如C++或者Go中的mutex互斥锁</p><p><a href="https://imgtu.com/i/7u2AbR"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u2AbR.png"                      alt="7u2AbR.png"                ></a></p><p><a href="https://imgtu.com/i/7u21rd"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u21rd.png"                      alt="7u21rd.png"                ></a></p><p>java则允许使用synchronized关键字来对某个函数、对象或者代码上锁</p><p><a href="https://imgtu.com/i/7uRQYV"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uRQYV.png"                      alt="7uRQYV.png"                ></a></p><p>当然更底层一些，我们甚至可以调用操作系统的API来实现锁的功能，其他的你可能听过的还包括自旋锁、读写锁等等</p><p><a href="https://imgtu.com/i/7uWpX4"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uWpX4.png"                      alt="7uWpX4.png"                ></a></p><p>总而言之，锁的核心概念是非常简单的</p><p>我们只需要记住在访问共享资源之前上锁，并在结束之后解锁即可</p><p><a href="https://imgtu.com/i/7uWDNq"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uWDNq.png"                      alt="7uWDNq.png"                ></a></p><p>修改运行程序，我们可以看到，这里输出了我们的预期结果10000000，虽然这是一个样例程序，但是频繁加锁和解锁的操作是非常低效的</p><p><a href="https://imgtu.com/i/7uWvVA"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uWvVA.png"                      alt="7uWvVA.png"                ></a></p><p>这样会完全打破线程的并发执行</p><p>其实我们完全可以在线程中创建一个临时变量做计算，然后再将最终的结果累加到全局的共享变量中，这样只有最后一个操作需要同步，而线程的主体仍能并发地执行，另外在使用锁的时候需要格外小心，<strong>多个锁的嵌套使用很可能导致线程的死锁(deadlock)现象</strong></p><p>比如这里有两个线程和两把锁</p><p><a href="https://imgtu.com/i/7uhg0J"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uhg0J.png"                      alt="7uhg0J.png"                ></a></p><p>线程1先获取锁1再获取锁2，线程2刚好相反，先获取锁2在获取锁1，如果这俩个线程同时运行，恰好线程q先获取了锁1，然后线程2获取了锁2，然后线程1继续执行，由于锁2被线程2占用，所以线程1会被阻塞，同时由于锁1被线程1占用，所以线程2也会被阻塞</p><p><a href="https://imgtu.com/i/7u5Zad"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u5Zad.png"                      alt="7u5Zad.png"                ></a></p><p>于是线程1和线程2同时被阻塞，也就造成了线程的死锁，这里关键的问题在于上锁的顺序，如果我们让所有线程都按照同样的顺序上锁，其实是可以避免这种情况的，不过实际情况肯恩远比这个复杂，每个线程会用到不同的锁，并且加锁和解锁的操作分散在代码的各个角落，所以另一种做法是，干脆就用单个锁来保护所有的共享资源</p><p><a href="https://imgtu.com/i/7uoWDO"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uoWDO.png"                      alt="7uoWDO.png"                ></a></p><p>并且仅仅在访问资源的时候再去上锁，虽然这么做会损失掉一部分线程的并发性(concurrency)，但好处在于程序的逻辑会更容易维护</p><p>讲到这里，我们顺便提一下部分语言支持的atomic语法修饰，这是一种不使用锁(如果硬件支持)但依然能够解决资源竞争的方法，比如像之前简单的加减操作，在机器内部会直接翻译成硬件支持的原子操作</p><p><a href="https://imgtu.com/i/7u7Elt"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u7Elt.png"                      alt="7u7Elt.png"                ></a></p><p><a href="https://imgtu.com/i/7u7MkQ"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u7MkQ.png"                      alt="7u7MkQ.png"                ></a></p><p>也就说指令已经是不可拆分的最小步骤，因此不需要同步，它的效率通常比使用锁更高</p><p>另外建立在锁之上，线程中还有其它更复杂、更高级的同步机制，比如信号量、条件变量等等，虽然它们也可以用来保护共享资源，但更主要的用途是在线程中传递信号(signaling)，比如使用条件变量，你可以让线程进入等待，直到某个条件成立后再继续执行，这个条件可能是网络资源被成功加载，或者某项数据准备完毕等等</p><p><a href="https://imgtu.com/i/7uH4VU"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uH4VU.png"                      alt="7uH4VU.png"                ></a></p><p>而信号量则更加灵活一点，你可以先让所有的线程进行等待，但在同一时间内，只让特定数量的线程被唤醒</p><p><a href="https://imgtu.com/i/7ubCRA"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7ubCRA.png"                      alt="7ubCRA.png"                ></a></p><p>在后面我将再向大家详细解释信号量和条件变量的工作原理，因为它们很容易和锁混淆，但实际用途却完全不一样</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用线程，我们可以并发地在各个CPU核心上执行任务，最大化CPU的利用率，但线程也可能导致各种奇怪的资源竞争问题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgtu.com/i/7uaCgP&quot;&gt;&lt;img  
                     lazyload</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>免费的内网穿透工具推荐(win)</title>
    <link href="http://example.com/2022/01/12/%E5%85%8D%E8%B4%B9%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90(win)/"/>
    <id>http://example.com/2022/01/12/%E5%85%8D%E8%B4%B9%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90(win)/</id>
    <published>2022-01-12T01:39:30.000Z</published>
    <updated>2022-01-12T01:40:02.037Z</updated>
    
    <content type="html"><![CDATA[<p>此内容参考自今日头条:<a class="link"   href="https://www.toutiao.com/a7028937143393206815/?log_from=27e046c60a8e6_1641951433723" >https://www.toutiao.com/a7028937143393206815/?log_from=27e046c60a8e6_1641951433723<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此内容参考自今日头条:&lt;a class=&quot;link&quot;   href=&quot;https://www.toutiao.com/a7028937143393206815/?log_from=27e046c60a8e6_1641951433723&quot; &gt;https://www.touti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机操作系统基础笔记</title>
    <link href="http://example.com/2022/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-12T01:34:30.000Z</published>
    <updated>2022-01-12T01:35:15.406Z</updated>
    
    <content type="html"><![CDATA[<p>此内容参考自今日头条:<a class="link"   href="https://www.toutiao.com/a7051472133389713933/?log_from=f0ef8adb57f57_1641951133601" >https://www.toutiao.com/a7051472133389713933/?log_from=f0ef8adb57f57_1641951133601<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此内容参考自今日头条:&lt;a class=&quot;link&quot;   href=&quot;https://www.toutiao.com/a7051472133389713933/?log_from=f0ef8adb57f57_1641951133601&quot; &gt;https://www.touti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP/IP网络通信之Socket编程入门</title>
    <link href="http://example.com/2022/01/11/TCPIP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BSocket%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/11/TCPIP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BSocket%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-11T14:48:30.000Z</published>
    <updated>2022-01-12T06:25:11.031Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，在这里我会为大家讲解socket的基本工作原理，并用它来实现一个简单的服务器，客户端通信</p><p>socket是一套用于不同主机间通信的API，它工作在我们的TCP/IP协议栈上，它的应用无处不在，比如你的手机应用、用于服务器管理的ssh客户端</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_22-53-29.2bfd5buhh5hc.webp"                      alt="Snipaste_2022-01-11_22-53-29"                ></p><p>全都是基于socket实现的，要通过socket与不同主机建立通信，我们只需要指定主机的IP地址和一个端口号</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_22-54-55.18p7ojt6zqyo.webp"                      alt="Snipaste_2022-01-11_22-54-55"                ></p><p>显而易见，IP地址用于唯一标识你的网络设备，那我们为甚需要额外指定一个端口号呢</p><p>如果没有端口号，操作系统则没有办法区分数据到底应该发送到哪一个应用上</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_22-57-27.7d4bueurw3o0.webp"                      alt="Snipaste_2022-01-11_22-57-27"                ></p><p>因此端口主要用于区分主机上的不同应用</p><p>通过socket我们可以建立一条用于不同主机，不同应用之间的虚拟数据通道</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_23-00-47.48fpktp2l5k0.webp"                      alt="Snipaste_2022-01-11_23-00-47"                ></p><p>并且它是点对点(应用对应用)的</p><p>一个形象的比喻是将一条数据线连接在不同应用的插槽上，这也是socket这个名字的由来</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_23-03-17.1rqbqej8xhcw.webp"                      alt="Snipaste_2022-01-11_23-03-17"                ></p><p>这里不得不吐槽下socket的中文翻译”套接字”到底是什么鬼</p><p>我们经常用到的socket有两种类型，名字你们一定听过，TCP和UDP，TCP是我们今天要讲的重点，它主要有两个特点，首先TCP协议是可靠的，它的底层会自动检测并回传丢失的数据包，因此对调用者来说，你发送的数据，对方一定会接收到</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_23-07-19.7jvtwc0mkf80.webp"                      alt="Snipaste_2022-01-11_23-07-19"                ></p><p>其次，发送和接受到的数据顺序是完全一样的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-12_09-50-16.4y27wtj5op80.webp"                      alt="Snipaste_2022-01-12_09-50-16"                ></p><p>比如你发送了一串字符，对方就一定会原封不动地收到同一份字符串，这也是为什么大家说TCP是基于“数据流”的协议</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-12_09-52-21.534a2i9o3es0.webp"                      alt="Snipaste_2022-01-12_09-52-21"                ></p><p>另外需要注意的是，TCP要求收发数据的双方扮演不同的角色:服务器和客户端，服务器会被动等待客户端的连接，它自己不会主动发起请求</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-12_09-54-44.3siqy0r782s0.webp"                      alt="Snipaste_2022-01-12_09-54-44"                ></p><p>与TCP相反UDP正如它的名字，以报文(Datagram)为单位来收发数据，并且UDP不会自动回传丢失的数据包，因此不保证数据一定能被对方接收到</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-12_09-58-03.48taqwynis20.webp"                      alt="Snipaste_2022-01-12_09-58-03"                ></p><p>正是因为缺少了这些检查，UDP通常具有更低的延迟并占用更少的系统资源，它也更适合像视频通话，这种实时性要求较高的应用</p><p>下面我以Python为例来讲解socket编程的部分，但其实你可以完全使用自己喜欢的编程语言，几乎所有的编程语言都支持socket，除了语法不同，它们的用法都是完全一致的，首先我们来创建一个简单的服务器，这个服务器只做一件事，就是将接受到的消息原封不动地发送回去，</p><p>第一行我们导入socket这个库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-12_10-03-50.nfcz13yz6j4.webp"                      alt="Snipaste_2022-01-12_10-03-50"                ></p><p>然后我们调用socket中的socket()来创建一个socket s</p><p>with是Python中的一个语法糖，它单纯代表当代码离开with块的时候自动调用s.close()来销毁这个socket</p><p><a href="https://imgtu.com/i/7nDGPH"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nDGPH.png"                      alt="7nDGPH.png"                ></a></p><p>这里我们需要指定两个参数，第一个参数大家直接填写AF_INEF即可</p><p><a href="https://imgtu.com/i/7nrmFg"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nrmFg.png"                      alt="7nrmFg.png"                ></a></p><p>这个代表我们使用的是IPV4的地址家族(address family)</p><p>第二个参数，SOCK_STREAM代表我们使用的是TCP协议，这里的STREAM也正是代表TCP是个“流式”协议，接下里爱的bind()将我们创建的这个socket关联到我们主机的某一个网卡(又:网络接口/network interface)和端口上，网卡我们可以通过IP地址指定，这里我使用的是0.0.0.0这个特殊的地址，它单纯代表你主机上的任意网卡都可以使用socket进行通信</p><p><a href="https://imgtu.com/i/7nsCAU"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nsCAU.png"                      alt="7nsCAU.png"                ></a></p><p>接下来的listen()将socket置为监听状态，并等待客户端的连接，在下面的accept()会接受来自任意客户端的连接，并返回一个新的socket c，以及客户端的IP地址，需要注意的是这个c是一个与之前s不同的socket，socket s主要用于监听，而socket c则用于与连接的客户端进行通信</p><p><a href="https://imgtu.com/i/7ns33d"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7ns33d.png"                      alt="7ns33d.png"                ></a></p><p>接下来的这几行代码，我们首先打印客户端的IP地址，然后是一个循环，这个循环会一直调用recv()接收客户端传来的信息，这里的1024代表一次性接收数据的最大长度1024个字节，然后只要数据不为空，我们就原封不动地将代码回传给客户端</p><p><a href="https://imgtu.com/i/7nyVPg"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nyVPg.png"                      alt="7nyVPg.png"                ></a></p><p>接下来，我们来简单测试一下这个服务器程序</p><p>我们先运行代码</p><p><a href="https://imgtu.com/i/7nIpHH"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nIpHH.png"                      alt="7nIpHH.png"                ></a></p><p>然后新开一个窗口，这里我们会用到一个命令行工具netcat，它是Linux下非常常用的网络测试工具，可以用来读写TCP/UDP的数据，当然在windows下你也可以找到它的替代版nmap</p><p><a href="https://imgtu.com/i/7nI82V"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nI82V.png"                      alt="7nI82V.png"                ></a></p><p>我们可以输入nc，后面直接跟上服务器的IP地址，127.0.0.1是一个回送地址(loopback address)</p><p><a href="https://imgtu.com/i/7nIBP1"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nIBP1.png"                      alt="7nIBP1.png"                ></a></p><p>代表本地计算机，再后面的1234是端口号，我们按下回车，可以看到服务器接收到了一个新连接</p><p><a href="https://imgtu.com/i/7nIRVH"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nIRVH.png"                      alt="7nIRVH.png"                ></a></p><p>这里我们随便输入字符串，服务器也会原封不动地返回回来</p><p><a href="https://imgtu.com/i/7nIbqg"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nIbqg.png"                      alt="7nIbqg.png"                ></a></p><p>这一步也验证了服务器代码是没有问题的</p><p>接下来我们继续看看客户端的程序</p><p>客户端的代码非常简单，这里我们用同样的方法创建一个socket s</p><p><a href="https://imgtu.com/i/7nIzR0"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nIzR0.png"                      alt="7nIzR0.png"                ></a></p><p>与服务器不同的是，这里我们直接调用connect()函数，并传入服务器的IP地址和端口号</p><p><a href="https://imgtu.com/i/7no3od"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7no3od.png"                      alt="7no3od.png"                ></a></p><p>随后我们调用sendall()函数发送一条消息给服务器，需要注意的是，这里的参数是一个字节序列，并不是字符串，所以千万不要忘记这个b，然后我们调用recv()接受服务器的消息，并将结果打印出来</p><p><a href="https://imgtu.com/i/7nTZ7Q"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nTZ7Q.png"                      alt="7nTZ7Q.png"                ></a></p><p>这里我们新开一个窗口，测试一下客户端的代码，可以看到客户端也成功输出了发送的字符串，然后程序退出，以上我们就讲完了基本服务器和客户端的代码实现，不过这里的服务器有个很大的问题，它只能同时处理一个客户端的请求</p><p><a href="https://imgtu.com/i/7nH1wF"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nH1wF.png"                      alt="7nH1wF.png"                ></a></p><p>要并发地与多个客户端进行通信，这里有几种方法</p><p>我们先来看看最简单的，多线程的服务器</p><p>通过创建线程来响应不同客户端的请求</p><p>首先前面bind和listen的部分和之前的代码完全一样，随后我们写一个循环，然后在循环中不停调用accept()接受来自客户端的连接，为了避免程序的阻塞(block)， 我们直接创建一个新的线程，也就是这里的handle_client()函数，并将客户端的socket c和地址传递给这个线程</p><p><a href="https://imgtu.com/i/7nbtAg"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nbtAg.png"                      alt="7nbtAg.png"                ></a></p><p>然后线程中的代码和之前的完全一样</p><p><a href="https://imgtu.com/i/7nbsBT"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nbsBT.png"                      alt="7nbsBT.png"                ></a></p><p>会不停地回传客户点端发送的信息</p><p>最后我们运行服务器代码，然后新开两个窗口，使用之前讲到的nc命令同时与服务器建立连接，可以看到修改后的服务器可以同时完成这两个客户端的请求</p><p><a href="https://imgtu.com/i/7nqA8s"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nqA8s.png"                      alt="7nqA8s.png"                ></a></p><p>多线程显然能帮我们解决多连接并发的问题，不过它也有自身的局限性，由于GIL的存在，Python中的线程其实做不到真正的并发，并且线程自身也会占用额外的系统资源，除了线程之外，我们还可以使用基于事件驱动的seletors来实现多个连接的并发，或者通过asyncio来实现异步的socket代码</p><p>总结一下:<br>实现一个简单的HTTP服务器，HTTP是TCP协议的一个典型应用，也是浏览器与服务器交互的主要方式，通常服务器会监听80端口，然后等待客户端的连接，客户端在连上服务器以后，首先需要指定要访问的资源，然后客户端会提供一系列额外的信息，每一条都是以冒号分隔的键值对</p><p><a href="https://imgtu.com/i/7nLPL6"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nLPL6.png"                      alt="7nLPL6.png"                ></a></p><p>比如里面包括我们的浏览器的版本等待，这一部分也被称作消息的头部(header)，随后是一个空行，再之后是消息的主体(body)(如果有的话)</p><p><a href="https://imgtu.com/i/7nLBwT"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nLBwT.png"                      alt="7nLBwT.png"                ></a></p><p>服务器在收到消息后，会以同样的格式来响应客户端的请求，首先第一行是一个状态行(status line)，里面包含一个状态码，比如200代表请求成功，404代表请求的资源不存在等等，接着同样是一系列键值对，里面包含了请求资源的类型，服务器信息等等</p><p><a href="https://imgtu.com/i/7nOVBV"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nOVBV.png"                      alt="7nOVBV.png"                ></a></p><p>再后面是一个空行，最后紧跟消息的主体(body)(如果有的话)</p><p><a href="https://imgtu.com/i/7nOQ39"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nOQ39.png"                      alt="7nOQ39.png"                ></a></p><p>在了解了HTTP的基本原理之后，我们可以修改之前的代码来实现这个服务器，首先在handle_client中，我们读取客户端发来的消息，然后我们将消息拆分成一行一行的字符串，存放在header这个列表中，需要注意的是，HTTP标准中定义的换行符是“回车+换行”(CRLF)，这也是我这里用”\r\n”来进行字符串分割的原因，接着我们提取出请求的文件名，和一般的web服务器一样，如果客户请求的是根路径，我们则直接返回index.html</p><p><a href="https://imgtu.com/i/7nOoD0"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nOoD0.png"                      alt="7nOoD0.png"                ></a></p><p>随后我们读取文件内容，并返回一个状态号为200的消息</p><p><a href="https://imgtu.com/i/7uMyNT"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uMyNT.png"                      alt="7uMyNT.png"                ></a></p><p>如果请求的文件不存在则直接返回404</p><p><a href="https://imgtu.com/i/7ulYlQ"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7ulYlQ.png"                      alt="7ulYlQ.png"                ></a></p><p>最后我们运行代码，并在浏览器中输入本机的IP，可以看到这里成功显示了我本地创建的html测试文件</p><p><a href="https://imgtu.com/i/7uQzQJ"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uQzQJ.png"                      alt="7uQzQJ.png"                ></a></p><p>如果我们去访问其他不存在的文件，则会收到一个错误信息</p><p>这里说一句题外话，其实Python的标准库里已经实现了一个简易的HTTP服务器，它主要用在开发和测试中，调用起来也很方便，大家可以直接输入这个命令使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>最后这里附上代码</p><p>socket_test_server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">s.bind((<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">1235</span>))</span><br><span class="line">s.listen()</span><br><span class="line">c, addr = s.accept()</span><br><span class="line"><span class="keyword">with</span> c:</span><br><span class="line"><span class="built_in">print</span>(addr, <span class="string">&quot;connected.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">data = c.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">c.sendall(data)</span><br></pre></td></tr></table></figure><p>socket_test_client.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">s.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1235</span>))</span><br><span class="line">s.sendall(<span class="string">b&quot;hello lhj&quot;</span>)</span><br><span class="line">data = s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received&quot;</span>, <span class="built_in">repr</span>(data))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家好，在这里我会为大家讲解socket的基本工作原理，并用它来实现一个简单的服务器，客户端通信&lt;/p&gt;
&lt;p&gt;socket是一套用于不同主机间通信的API，它工作在我们的TCP/IP协议栈上，它的应用无处不在，比如你的手机应用、用于服务器管理的ssh客户端&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一个10分钟的numpy入门教程</title>
    <link href="http://example.com/2022/01/11/%E4%B8%80%E4%B8%AA10%E5%88%86%E9%92%9F%E7%9A%84numpy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/01/11/%E4%B8%80%E4%B8%AA10%E5%88%86%E9%92%9F%E7%9A%84numpy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</id>
    <published>2022-01-11T08:54:30.000Z</published>
    <updated>2022-01-11T10:46:18.262Z</updated>
    
    <content type="html"><![CDATA[<p>如果你打算在Python中做数据分析、科学运算、数据处理，那你多少会用到numpy这个库，当然你肯定还听过pandas、scipy、PIL、amtplolib等等</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_16-57-09.5ceyiooc2ds0.webp"                      alt="Snipaste_2022-01-11_16-57-09"                ></p><p>这些都是科学运算中非常常用的库，不过这些不是我们现在讲的重点，下面我们来看看numpy</p><p>numpy为我们提供了一个特殊的数组对象<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-01-14.1cbvi5n541mo.webp"                      alt="Snipaste_2022-01-11_17-01-14"                ></p><p>我们可以用它表示普通的一维数组</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-01-39.1esvx0b78s8w.webp"                      alt="Snipaste_2022-01-11_17-01-39"                ></p><p>或者二维的矩阵，或者任意维的数据</p><p>并且它可以对数组中的数据进行非常高效的运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-04-48.6g39zwpe3ik0.webp"                      alt="Snipaste_2022-01-11_17-04-48"                ></p><p>比如用作数据统计，图像处理，线性代数，傅里叶变换等等，我们都知道，Python是一个很慢很慢的语言，而numpy之所以能运行这么快的原因，是因为它底层是用C语言实现的目标代码，当然对于任何想要运算的数据，我们也需要预先将它们表示成numpy数组的形式，也就是所谓的向量化，当然如果你希望将运算速度再提升一个数量级，你甚至可以使用你的GPU来对这些数据做并行运算，那么接下来我们就用实例来讲解下numpy的基本使用叭</p><p>numpy中所有的计算都是围绕着数组进行的，因此在运算之前，我们需要将计算的数据表示成数组的形式，我们首先需要导入numpy这个库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-12-58.zi9xiyf9fk0.webp"                      alt="Snipaste_2022-01-11_17-12-58"                ></p><p>并起一个别名np，然后我们可以用np.array()来创建一个数组</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-14-28.2q2jhsabj5u0.webp"                      alt="Snipaste_2022-01-11_17-14-28"                ></p><p>括号中是数组的初始化数据，当然我们也可以使用np.zeros()创建一个全零的数组</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-15-50.453ael8zi9y0.webp"                      alt="Snipaste_2022-01-11_17-15-50"                ></p><p>这里传入的参数是数组的尺寸，(3, 2)代表一个三行二列的数组，在numpy中，数组可以是一维、二维、甚至是更高维度的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-18-11.65yri3hinhk0.webp"                      alt="Snipaste_2022-01-11_17-18-11"                ></p><p>二维数组可以用于存放矩阵或者表格数据，多维数组通常用来表示更加复杂的数据</p><p>在numpy中，我们会用到shage来获取数组的尺寸，比如这里的3，是数组第一维的尺寸，我们可以理解为行数，2是数组的第二维的尺寸，我们可以理解为列的个数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-21-39.4u9jv1j5c5g0.webp"                      alt="Snipaste_2022-01-11_17-21-39"                ></p><p>类似的，我们可以使用np.ones()创建一个全部是1的数组</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-23-56.2173yd1135ts.webp"                      alt="Snipaste_2022-01-11_17-23-56"                ></p><p>另外我们可以使用np.arange()创建一个递增或递减的数列</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-24-56.1hlws78qq4kg.webp"                      alt="Snipaste_2022-01-11_17-24-56"                ></p><p>类似于Python的range</p><p>np.linspace()会返回介于某个区间等间距分布的数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-26-35.1mw55gpr5zcw.webp"                      alt="Snipaste_2022-01-11_17-26-35"                ></p><p>前面两个是区间范围，第三个参数是输出样本的总数</p><p>另外我们还可以通过np.random.rand(2, 4)生成一个随机的数组，</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-28-52.1dgu3n9e2x8g.webp"                      alt="Snipaste_2022-01-11_17-28-52"                ></p><p>在numpy中，数组默认的数据类型是64位的浮点数，不过我们可以在创建数组时，通过dtype指定其他的数据类型</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-30-55.w1pvp6l81ds.webp"                      alt="Snipaste_2022-01-11_17-30-55"                ></p><p>对于现有的数组，我们也可以通过satype()来转换数据类型</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-33-36.633ytxp40ls0.webp"                      alt="Snipaste_2022-01-11_17-33-36"                ></p><p>在numpy中我们可以轻松地对数组进行常见的数学运算</p><p>两个相同尺寸的数组可以直接进行四则运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-35-41.4g3wh1slfna0.webp"                      alt="Snipaste_2022-01-11_17-35-41"                ></p><p>他会将数组同位置的元素进行加减乘除</p><p>在乘法运算中还有一个np.dot()，他会对两个向量进行点乘运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-39-10.50h9fhfwy1o0.webp"                      alt="Snipaste_2022-01-11_17-39-10"                ><br>另一个 与乘法相关的是@符号，它会进行矩阵的乘法运算，等同于np.matmul()函数，而不是将相对应的元素直接相乘</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-42-14.59up4q3nvkg0.webp"                      alt="Snipaste_2022-01-11_17-42-14"                ></p><p>我们还可以使用np.sqrt对所有数依次求平方根</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-43-11.3jw6y4r76oo0.webp"                      alt="Snipaste_2022-01-11_17-43-11"                ></p><p>使用np.sin()，np.cos()进行三角函数运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-44-27.t8lgwbd91r4.webp"                      alt="Snipaste_2022-01-11_17-44-27"                ></p><p>或者np.log()，log.power()进行对数和指数运算等等</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-45-43.1pidfm0trt7k.webp"                      alt="Snipaste_2022-01-11_17-45-43"                ></p><p>当然你也可以将一个numpy数组与单独的一个数做运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-46-36.65qlair1mqc0.webp"                      alt="Snipaste_2022-01-11_17-46-36"                ></p><p>numpy会分别计算各个元素与这个数的乘积，产生一个同尺寸的新数组，这个操作在numpy里面被称作广播</p><p>比较有意思的是，不同尺寸的数组也可以直接做运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-49-32.25hllfiu7fvk.webp"                      alt="Snipaste_2022-01-11_17-49-32"                ></p><p>在运算之前，numpy会将这两个数组扩展至相同的尺寸，然后再将相同位置的元素相加</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-51-07.3eo83vtonva0.webp"                      alt="Snipaste_2022-01-11_17-51-07"                ></p><p>另外，我们还可以通过min()或者max(),返回数组中最小或者最大的元素</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-54-59.1t9yhooz8lj4.webp"                      alt="Snipaste_2022-01-11_17-54-59"                ></p><p>argmin()和argmax()会返回最小或者最大元素所在的索引</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-56-08.3dnaudluz0o0.webp"                      alt="Snipaste_2022-01-11_17-56-08"                ></p><p>sum会返回所有数据的总和</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-56-57.1nr26ssvus80.webp"                      alt="Snipaste_2022-01-11_17-56-57"                ></p><p>mean()，median()会返回数据的平均值，中位数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-58-17.2uicjrcuwx80.webp"                      alt="Snipaste_2022-01-11_17-58-17"                ></p><p>var()和std()会返回数据的方差和标准方差</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-59-34.7e49ntp51mg0.webp"                      alt="Snipaste_2022-01-11_17-59-34"                ></p><p>对于以上提到的函数，如果你的数组是多维数组，你还可以指定一个额外的参数axis，当axis等于0时，它会将每一行中对应的数据相加，axis=0代表第一个维度，也就是行</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-01-57.5vl6w83pzhw0.webp"                      alt="Snipaste_2022-01-11_18-01-57"                ></p><p>以此类推axis=1则代表第二个维度，也就是列</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-03-18.6le3mtsrez40.webp"                      alt="Snipaste_2022-01-11_18-03-18"                ></p><p>如果你想要获取数组中的元素，你可以使用与Python list非常相似的语法，比如你要获取第1行第2列的元素，你可以使用下表0和1，中间以逗号分隔</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-05-29.4843ax66qg40.webp"                      alt="Snipaste_2022-01-11_18-05-29"                ></p><p>另外，我们还可以通过条件筛选出指定的元素，比如在方括号中输入a&lt;3则会返回所有小于3的元素</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-07-11.54wob0rkj940.webp"                      alt="Snipaste_2022-01-11_18-07-11"                ></p><p>我们还可以通过逻辑运算符组合不同的条件，比如下面这个例子将筛选出大于3并且是偶数的数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-08-37.15dvi0o1w4yo.webp"                      alt="Snipaste_2022-01-11_18-08-37"                ></p><p>这里需要注意的是，“与”运算需要用&amp;符号来表示，“或”运算则需要用竖线表示</p><p>如果你要获取的第一行，但是1-2列的数据，你可以使用0:2这种切片的语法，这个和Python的列表是一样的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-12-33.u3ii8ehuxr4.webp"                      alt="Snipaste_2022-01-11_18-12-33"                ></p><p>如果你要获取第一行，但是所有列的元素，你可以单写一个冒号，然后将冒号前后的范围省略掉，当然你也可以直接把整个冒号给省略掉</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-15-12.6zyf6m35l000.webp"                      alt="Snipaste_2022-01-11_18-15-12"                ></p><p>另外我们可以在冒号的后面再加一个冒号，第二个冒号后面可以跟一个跨度，也就是步长</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-16-48.5f5bofbkq2s0.webp"                      alt="Snipaste_2022-01-11_18-16-48"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-17-51.5jb29wxc4pc.webp"                      alt="Snipaste_2022-01-11_18-17-51"                ></p><p>比较有意思的是，这个跨度还可以取负值，我们可以通过复苏的跨度，从右往左逆向返回这个数组，比如在numpy中会经常看到::-1的写法，其实它做的事情就是将数组翻转一下而已</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-20-21.jnz06abr5j4.webp"                      alt="Snipaste_2022-01-11_18-20-21"                ></p><p>当然说了这么多，光看一堆数字确实也不够直观，不如我们来看一下numpy的一个典型应用图片处理，通常我们可以把一张灰度图看作是一个二维的数组， 数组中的每个元素用来表示像素点的亮度值</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-24-06.dd408en2cnk.webp"                      alt="Snipaste_2022-01-11_18-24-06"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-24-51.70zqmk1v12o0.webp"                      alt="Snipaste_2022-01-11_18-24-51"                ></p><p>对于彩色的图片，我们可以用三维数组来表示</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-25-45.vjekczaykkw.webp"                      alt="Snipaste_2022-01-11_18-25-45"                ></p><p>数组中的第三维分别存储了像素点的红绿蓝分量</p><p>我们可以使用pillow这个库来读取图片文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-29-12.7kmwowkhqh40.webp"                      alt="Snipaste_2022-01-11_18-29-12"                ></p><p>随后我们可以通过np.array(im)将图片转换成一个numpy数组</p><p>可以看到这个图片一共960行，1280列，并且有红绿蓝3个颜色分量，我们可以通过下表来访问某个像素点的颜色</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-32-59.5wq5hppz2rc0.webp"                      alt="Snipaste_2022-01-11_18-32-59"                ></p><p>也可以通过这种方式单独提取出所有像素点的红色分量</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-33-56.3aemdare9z40.webp"                      alt="Snipaste_2022-01-11_18-33-56"                ></p><p>然后图片就成了这样</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-35-04.whh171cqpow.webp"                      alt="Snipaste_2022-01-11_18-35-04"                ></p><p>我们也可以通过这样的方式将两张图按比例混合在一起，这里需要注意的是，运算的结果是浮点数，为了显示图片，我们需要将图片转换成整型数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-39-14.6j6fyv3ub480.webp"                      alt="Snipaste_2022-01-11_18-39-14"                ><br>另外我们可以利用之前讲到的跨度来对图片进行降采样，如果我们想要翻转图片，我们可以选跨度-1</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-40-45.3sllqow2zw60.webp"                      alt="Snipaste_2022-01-11_18-40-45"                ></p><p>这由于我们指定的是第一个维度，因此图片会上下翻转</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-41-50.6jyb4b5pyu00.webp"                      alt="Snipaste_2022-01-11_18-41-50"                ></p><p>如果我们想要裁剪图片的某一部分，我们可以利用之前讲到的切片</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-43-14.101o8kgqlipc.webp"                      alt="Snipaste_2022-01-11_18-43-14"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-43-54.1iaiyje1gk5c.webp"                      alt="Snipaste_2022-01-11_18-43-54"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-44-21.2oxofwlwkjq0.webp"                      alt="Snipaste_2022-01-11_18-44-21"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果你打算在Python中做数据分析、科学运算、数据处理，那你多少会用到numpy这个库，当然你肯定还听过pandas、scipy、PIL、amtplolib等等&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
           </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从0制作树莓派机器人</title>
    <link href="http://example.com/2022/01/11/%E4%BB%8E0%E5%88%B6%E4%BD%9C%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <id>http://example.com/2022/01/11/%E4%BB%8E0%E5%88%B6%E4%BD%9C%E6%A0%91%E8%8E%93%E6%B4%BE%E6%9C%BA%E5%99%A8%E4%BA%BA/</id>
    <published>2022-01-11T06:51:30.000Z</published>
    <updated>2022-01-11T08:48:36.533Z</updated>
    
    <content type="html"><![CDATA[<p>大家一定都听说过树莓派，Arduino，单片机，卡片电脑，嵌入式之类的术语</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_14-53-27.5x5bdjy5m1g0.webp"                      alt="Snipaste_2022-01-11_14-53-27"                ></p><p>这些到底有什么区别呢，并且我们可以用它们能做出哪些有趣的东西呢，今天我来带大家从零制作一个可以远程控制的树莓派机器人</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_14-56-01.2nt7kgo1gq80.webp"                      alt="Snipaste_2022-01-11_14-56-01"                ></p><p>你可以通过手机远程访问，并实时监测家里的安全，当然除此之外，我们也可以用它来做一些有意识的应用，比如你可以把它当做一个可以人脸追踪的摄像头</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_14-58-27.5f9uqgecsfw0.webp"                      alt="Snipaste_2022-01-11_14-58-27"                ></p><p>在你和亲朋好友的视频聊天中让机器人自动跟随你的视角，让你成为通话的焦点</p><p>树莓派其实是一款单板电脑</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_15-00-49.4g81cn4jtno0.webp"                      alt="Snipaste_2022-01-11_15-00-49"                ></p><p>它使用的是博通ARM架构的64位处理器，和大家平时使用的智能手机芯片同属于一种架构，上面集成了可以用作图像渲染的GPU，1-4不等的LPDDR(Low Power DDR)内存，以及USB、HDMI、以太网接口等等，它可以运行包括Linux，甚至WIndows在内的多个操作系统，其实完全可以当做一台低配置电脑来使用，这里顺便提一下，经常拿来和树莓派作比较的Arduino其实是一款单板的微处理器，它的用途和功能相比树莓派来说要简单和纯粹许多，Arduino板搭载的基本是Atmel的8位微处理器，主频在16MHZ，速度还远不及树莓派的百分之一，不过这恰恰是Arduino的优点，造价便宜，耗电量低，由于没有操作系统的束缚，也非常适合拿来做一些实性很高的应用，大家如果玩过无人机，应该听说过这款著名的开源飞控(飞行控制器)APM，它就是基于Arduino开发的</p><p>另外我们经常听到的一个术语是单片机，单片机又被称作微控制器，或者MCU(Microcontaoller Unit)它是将处理器，存储器，内存还有各种io端口都集成在芯片内部的电路上，严格意义上Arduino不能被称作是单片机，不过上面搭载的Ateml微控制器是单片机，树莓派上的博通芯片也不能称作单片机，因为他的复杂程度已经远远超过单片机的范畴，相反它被称作“”芯片上系统“，又叫做SOC(System on Chip),这里我使用树莓派作为主控板的主要原因是因为它开发效率高，工具库全，对新手也非常友好</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_15-23-23.2tmqp5pl4k20.webp"                      alt="Snipaste_2022-01-11_15-23-23"                ></p><p>你想想几乎整个Linux生态的软件、工具库都可以拿来使用，它可以做的事情实在是太多了</p><p>接下来我们来看一看机器人上其他硬件的组成</p><p>电机驱动模块</p><p>大家都知道，微处理器上的IO端口通常只能提供非常有限的电流，以树莓派为例，单个GPIO端口只能提供16mA的最大电流，这个电流用来驱动一个发光二极管(LED)绰绰有余，但直流电机的额定电流通常都比它高出一到两个数量级，直接用IO端口驱动电机是根本不可能实现的，且不谈电机换向的问题，这也为什么我们需要使用外部电路来驱动电机的原因，电机的驱动模块有很多种，比如大家经常听到的价格也很便宜的H桥电机驱动芯片L293D</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_15-32-17.1x2fg8sfjoo0.webp"                      alt="Snipaste_2022-01-11_15-32-17"                ></p><p>我这里使用的是类似的另一种，导通电阻很低，效率远超L293D的驱动芯片TB6612FNG，</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_15-33-54.1xfx2q3n93nk.webp"                      alt="Snipaste_2022-01-11_15-33-54"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_15-34-27.2veuaufaaug0.webp"                      alt="Snipaste_2022-01-11_15-34-27"                ></p><p>主要还是考虑到省电的原因，大家在选择驱动电路时，一定要结合自己的需要，比如你需要同时驱动多少个电机，最大电压和电流是多少，以及芯片待机时的功耗是多少等等，价格最贵的不一定是最合适的</p><p>机器人的电池</p><p>我使用的电池是从旧的移动电源里拆解下来的锂电池，这里的锂电池又叫做聚合物锂离子电池，锂电池的优点有很多: 循环寿命长、重量轻、容量大、并且能量密度高，这也是数码设备无一例外使用锂电池的原因，这里需要注意的是，我们并不能直接将锂电池连接到树莓派和电机驱动电路上</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_15-40-49.5u7uzxvfb8k0.webp"                      alt="Snipaste_2022-01-11_15-40-49"                ></p><p>因为锂电池的标称电压是3.7V，而电机驱动电路和树莓派都工作在5V上下，直接连接是不能够驱动设备的，当然这里还有一个原因是，锂电池都非常脆弱，过充和过放都会导致电池的永久损伤甚至是爆炸，因此，锂电池的使用必须搭配额外的保护电路，这里我使用的是一款带开关，支持microUSB充电的锂电池保护电路，它同时支持向两个USB接口输出2.5A的最大电流，刚好符合我们的要求，通常这类保护电路是为移动电源提供的，它们的功能比较单一，价格也很便宜，所以可以很轻松地在网上购买到</p><p>机器人的运动系统</p><p>机器人的运动系统可以分为很多种，有轮式的，履带式的，关节式的，还有仿生机器人式的，我这里使用的是双轮差速的驱动方式，也是在消费领域应用最广泛的，例如，家里的扫地机器人就是这种方式驱动的，它有两个显著的有点:机械构造简单，并且支持原地的旋转</p><p>电机</p><p>电机的部分，我使用的是型号为N20的直流减速电机，减速电机其实就是在普通电机的基础上，加上了齿轮减速箱，在功率恒定的情况下，虽然降低了电机的转速，但是可以提供了较大的力矩，由于我们的机器人使用的都是小功率的配件，并且安装上电池后会有一定的重量，在这种情况下，使用减速电机是非常适合的</p><p>摄像头</p><p>摄像头我使用的是带红外的USB摄像头</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-07-19.447vn7h8f300.webp"                      alt="Snipaste_2022-01-11_16-07-19"                ></p><p>这样在弱光或是夜间也可以正常使用，我们在使用USB摄像头的时候只需要看摄像头是否支持UVC(USB Video Class)协议即可，现在市面上已经很少见到不使用UVC协议的摄像头了，所以家里面闲置的摄像头，通常也可以直接拿来在树莓派上使用，当然在树莓派上也可以使用MIPI/CSI接口的摄像头模块</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-25-30.4bjgtfpc5fs0.webp"                      alt="Snipaste_2022-01-11_16-25-30"                ></p><p>这个接口在移动设备上会被广泛用到</p><p>主要因为它支持更高带宽，更高分辨率图像的传输</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-26-57.6mwjusq3lu40.webp"                      alt="Snipaste_2022-01-11_16-26-57"                ></p><p>操作系统的安装</p><p>首先，必须要准备一张空白的SD卡，当然读写速度越快越好</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-29-19.792lokpepc00.webp"                      alt="Snipaste_2022-01-11_16-29-19"                ></p><p>然后去树莓派官网下载叫做Respbery Pi OS(Lite)的操作系统</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-30-43.npej6m1qn80.webp"                      alt="Snipaste_2022-01-11_16-30-43"                ></p><p>这个操作系统是基于Debian的，Debian是使用人数最多的Linux发行版之一，比如大家经常听到的Ubuntu就是基于Debian的，然后我们可以根据官网上提供的步骤，另外再下载一个Raspberry Pi Imager的工具，然后将下载的操作系统映像写入SD卡</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-34-12.6d2a0cwrxos0.webp"                      alt="Snipaste_2022-01-11_16-34-12"                ></p><p>写入完毕之后呢，我们只需要将SD卡放回树莓派，接上USB电源启动即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-36-24.2g8ygm0yw8u8.webp"                      alt="Snipaste_2022-01-11_16-36-24"                ></p><p>你可以通过使用外接USB键盘和显示器的方式来使用树莓派，不过这样比较麻烦，因为你还得专门准备一个显示器和键盘，这里我是使用远程操作的方式来使用树莓派的，先让树莓派连接上家里的WiFi，然后用ssh来访问树莓派，ssh(secure shell)在Linux上是一个经常被用到的工具，它是用来和远程服务器通行的一种加密传输协议，在这里呢，我们会利用它从你的PC，Mac或者Linux系统里远程操作你的树莓派</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-41-49.75bicjpv1y00.webp"                      alt="Snipaste_2022-01-11_16-41-49"                ></p><p>启用ssh的方式其实很简单，在操作系统被写入SD卡之后，先不要着急取下SD卡，我们可以在计算机上找到这个叫做boot的分区</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-43-59.4pw3voxtk2s0.webp"                      alt="Snipaste_2022-01-11_16-43-59"                ></p><p>然后新建一个空文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-44-54.6xlua6k9l3o0.webp"                      alt="Snipaste_2022-01-11_16-44-54"                ></p><p>并命名为ssh就好了，配置WiFi信息的方法也很类似，我们同样在这个分区里面创建一个wpa_supplicant.conf文件，然后把下面这段文字粘贴进去</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_16-47-33.5ce9pf4b1do0.webp"                      alt="Snipaste_2022-01-11_16-47-33"                ></p><p>未完待续，参考自:<a class="link"   href="https://www.bilibili.com/video/BV14g4y1q7yf?spm_id_from=333.999.0.0" >https://www.bilibili.com/video/BV14g4y1q7yf?spm_id_from=333.999.0.0<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家一定都听说过树莓派，Arduino，单片机，卡片电脑，嵌入式之类的术语&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
        </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2021 Web开发完全指南</title>
    <link href="http://example.com/2022/01/10/2021%20Web%E5%BC%80%E5%8F%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2022/01/10/2021%20Web%E5%BC%80%E5%8F%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</id>
    <published>2022-01-10T10:10:30.000Z</published>
    <updated>2022-01-11T06:36:11.120Z</updated>
    
    <content type="html"><![CDATA[<p>过去的10年可以说是web技术变革最大，更新迭代最快的10年，如今的web已经不单单是信息展示的渠道，更是各种功能复杂应用的集合，这是一张2021年的web开发路线图</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-14-25.6nx2xv5qn5c0.webp"                      alt="Snipaste_2022-01-10_18-14-25"                ></p><p>可以看到其中囊括的知识点非常细碎和繁杂，可能也让许多刚接触web开发的小伙伴一头雾水，这里呢，我会从整体的角度出发，用实例向大家解释现代web开发中的各种概念以及它们的最佳学习路线</p><p>那么首先web是如何运作的呢，简单来说，当我们在浏览器中输入网址的时候，浏览器会通过一系列网络操作找到我们要访问的服务器</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-19-21.74rteod5kds0.webp"                      alt="Snipaste_2022-01-10_18-19-21"                ></p><p>并向这个服务器发起一个http请求</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-20-33.6afnjrtj54s0.webp"                      alt="Snipaste_2022-01-10_18-20-33"                ></p><p>服务器在收到请求后，会根据请求的类型，将对应的文档返回给浏览器，浏览器会渲染该页面并最终显示在屏幕上，这个页面其实是一个HTML格式的文档</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-23-06.5n3urmq9rvg0.webp"                      alt="Snipaste_2022-01-10_18-23-06"                ></p><p>大家可以通过”!”在vscode中快速创建一个HTML文档</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-24-26.1aosojno1zk0.webp"                      alt="Snipaste_2022-01-10_18-24-26"                ></p><p>HTML文档通常由许多潜逃的标签组成，这些标签决定了我们页面的基本结构，通常一个页面会由头部标签<code>&lt;head&gt;</code>内容标签<code>&lt;body&gt;</code>构成，在````body```下面又可以放置标题、段落、列表、图片、表格、表单等等，你浏览器所做的事情就是去渲染这份HTML文档，并显示在你的电脑屏幕上，现如今，大家看到的绝大多数页面都使用的是HTML5的格式，它除了更加清晰的语法，以及良好的浏览器兼容性之外，还提供原生的音视频格式支持</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-31-10.19pn80aqz2n4.webp"                      alt="Snipaste_2022-01-10_18-31-10"                ></p><p>这也是flash能够逐渐淡出我们视线的原因，当然还有Canvas，WebGL这些图形API的支持，通过它们我们甚至可以在浏览器实现一款画质精良的三维游戏</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-35-38.3cbxua2ngr40.webp"                      alt="Snipaste_2022-01-10_18-35-38"                ></p><p>如果说HTML定义了文档的结构和内容，那css则是用来为页面添加不同的样式风格，也正是它名字“样式表的由来”，为页面添加样式有许多种方法，最简单的我们可以通过在HTML头部加入<code>&lt;style&gt;</code>标签，随后我们可以使用css的选择器(selector)来指定需要修改样式的元素，也就是这里我指定的button对象，后面花括号的每一行允许我们指定边距、边框、字体，背景颜色等等，通过组合css提供的各项属性，我们可以制作出非常漂亮的界面</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-44-39.2n347zfv5xe0.webp"                      alt="Snipaste_2022-01-10_18-44-39"                ></p><p>当然在实际使用中，我们也可以选择现成的css框架帮我们制作专业的跨平台用户界面，除了最广为人知的bootstrap，它可以用来快速实现对移动端友好的响应式布局，你也可以使用Materialize来实现统一的Material界面风格，如果你喜欢轻量级的框架，你还可以尝试只有4KB不到的Pure.css等等，除此之外，css还提供原生的补间动画支持，我们可以利用css的animation属性来定义动画的种类和时长，并利用@keyframes[动画名]{}定义动画中用到的所有关键帧</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-51-16.a3qpvypva0c.webp"                      alt="Snipaste_2022-01-10_18-51-16"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-53-58.72p6isfslp40.webp"                      alt="Snipaste_2022-01-10_18-53-58"                ></p><p>另外值得一提的是css3中加入的新布局方式–FlexBox</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-55-05.mnaqd4bw5cw.webp"                      alt="Snipaste_2022-01-10_18-55-05"                ></p><p>使用它可以轻易的实现传统css中很难实现的这些布局效果</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-56-17.5a7w4dkdb040.webp"                      alt="Snipaste_2022-01-10_18-56-17"                ></p><p>比如像导航栏，表单，大小不一的卡片等等</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_18-58-49.iciggteec3c.webp"                      alt="Snipaste_2022-01-10_18-58-49"                ></p><p>如果说HTML和CSS决定了页面的外观，那JavaScript则允许我们给网页加入动态的行为，比如我们可以通过JavaScript来修改页面的内容，也就是我们平时所得DOM树操作<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-25-14.3qvkkstyhdi0.webp"                      alt="Snipaste_2022-01-11_10-25-14"                ></p><p>或者使用JavaScript对鼠标键盘时间做出相应，JavaScript也可以用于请求远程服务器的数据，也就是我们经常听到的XHR/AJAX技术，它可以根据需要想服务器请求数据，并用来更新页面的部分内容</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-30-36.6c247dshcgg.webp"                      alt="Snipaste_2022-01-11_10-30-36"                ></p><p>通过JavaScript，我们甚至可以通过websocket或者webRTC来替代HTTP请求，他们可以用于实现更低延迟的网络通信，比如用作即时聊天，在线游戏等等，由于WdbGL的存在，我们还可以用JavaScript做三维的实时图像渲染，甚至用于在浏览器中训练深度神经网络，现在被主流浏览器支持的JavaScript版本是ES6，里面包含了类</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-38-04.1ya1r6optrnk.webp"                      alt="Snipaste_2022-01-11_10-38-04"                ></p><p>箭头表达式</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-39-52.llonldf4e40.webp"                      alt="Snipaste_2022-01-11_10-39-52"                ></p><p>Promise</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-40-29.2tyk2a3bxzm0.webp"                      alt="Snipaste_2022-01-11_10-40-29"                ></p><p>模板字符串</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-41-16.1uj5idklghq8.webp"                      alt="Snipaste_2022-01-11_10-41-16"                ></p><p>变量的解构赋值</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-41-53.6fnfaswldxc0.webp"                      alt="Snipaste_2022-01-11_10-41-53"                ></p><p>新的遍历语法</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-42-22.4sp8ahsp3hk0.webp"                      alt="Snipaste_2022-01-11_10-42-22"                ></p><p>新的导入导出语法等等，这些都是应当掌握的并且在实际开发中被广泛用到的新特性，另一个与JavaScript相关，虽然不一定马上用到，但是非常值得去了解的是TypeScript，简单来说它为JavaScript中的每一个对象加入了可选的类型标注，是JavaScript语言的一个超集</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-46-10.mf4iseru1lc.webp"                      alt="Snipaste_2022-01-11_10-46-10"                ></p><p>这样做的好处是能够在编译时做到类型的检查，提前捕捉程序错误</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-47-38.1y2d9nmt677k.webp"                      alt="Snipaste_2022-01-11_10-47-38"                ></p><p>当然这些类型标记也同样给你的IDE提供了额外的类型信息，帮助它完成更好的代码提示和自动补全功能</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-49-18.3qprfukooos0.webp"                      alt="Snipaste_2022-01-11_10-49-18"                ></p><p>既然说到JavaScript，我们就不得不提到Node，Node是一个脱离浏览器运行的JavaScript运行时，它使用与Chrome完全一样的v8引擎，性能是相当地不错，你可以使用Node编写控制台程序，原生的桌面应用，服务器程序等等</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_10-53-10.73gnhsrr7do0.webp"                      alt="Snipaste_2022-01-11_10-53-10"                ></p><p>另外node自带一个包管理器–npm，类似于Python的pip，你可以用它来安装数不胜数的第三方库，这也是Node大获成功的重要原因之一，待会儿我们讲到的React就需要npm来安装，</p><p>按照如今web发展的大趋势，与用户交互的逻辑都逐渐从后端向前端迁移，前端的逻辑通常都非常复杂，为了减轻前端开发的负担，我们往往会选择使用现成的前端界面框架，现在流行的前端界面框架基本是这三种:React、Angular和Vue，这三个框架都会将界面元素组件化，从而提高代码复用，我这里用React来做一个简单的示范</p><p>React允许我们通过函数式编程的方式来渲染用户界面，这里函数的输入是我们要显示的数据，他们被称为“属性”，或者“状态”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-03-48.658v8u5lv880.webp"                      alt="Snipaste_2022-01-11_11-03-48"                ></p><p>函数的输出则是渲染之后的HTML标签，这样做的好处是渲染的结果会由输入的这些数据唯一决定</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-07-06.6cbw11wbsro0.webp"                      alt="Snipaste_2022-01-11_11-07-06"                ></p><p>也就是大家常说的“单向数据流”模式</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-08-14.5j3werh6w5s0.webp"                      alt="Snipaste_2022-01-11_11-08-14"                ></p><p>这种模式从源头上避免了组件之间数据的复杂传递，因此也更易于调试</p><p>说完了前端，我们来看看后端开发</p><p>也就是服务器的部分，后端其实有相当多的语言和框架可供我们选择，我这里以JavaScript以及Express.js为例来介绍一下后端服务器的部分，因为最近这几年在Web开发中有一个逐渐流行的技术栈–MERN，它代表数据库使用的MongoDB服务端的运行环境Node.js</p><p>前端使用的React，以及后端的服务器框架Express.js</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-14-06.42aycnv4l680.webp"                      alt="Snipaste_2022-01-11_11-14-06"                ></p><p>这个技术栈的特点在于它所有的组件全都是使用JavaScript编写的，因此大大降低了开发和维护的成本，后端服务器做的主要事情是响应前端的请求，并向前端提供数据，现代的web应用通常都会通过API的方式与后端进行通信</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-17-20.2mwf6js3pfu0.webp"                      alt="Snipaste_2022-01-11_11-17-20"                ></p><p>API简单来说就是预先商定好的通信协议或者数据格式，比如这里的这个/aip/zodiac用于返回当前的年份和生肖</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-19-29.m5h52mjvfz4.webp"                      alt="Snipaste_2022-01-11_11-19-29"                ></p><p>如果你在浏览器中手动访问这个地址，服务器会将数据以json格式返回</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-21-09.1lu4w96od1fk.webp"                      alt="Snipaste_2022-01-11_11-21-09"                ></p><p>通过API我们可以实现前后端逻辑的分离</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-22-39.1li4fwx7vo1s.webp"                      alt="Snipaste_2022-01-11_11-22-39"                ></p><p>并且如果你的应用同时有安卓，ios客户端的话，也可以复用相同的API</p><p>说到API，我们就不得不提到经典的REST风格的API，简单来说，他会根据不同的HTTP请求类型，来对数据做对应的增删改查操作，这里的jsonplaceholder是一个用于演示的REST API，接下来我们以它为例来快速了解下REST API的基本用法</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-27-14.2tm8z40rnh80.webp"                      alt="Snipaste_2022-01-11_11-27-14"                ></p><p>比如这里我们以GET方法去访问/todos这个地址</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-28-43.3jb4dqbez0o0.webp"                      alt="Snipaste_2022-01-11_11-28-43"                ></p><p>服务器会将所有的“待办事项”以json格式返回</p><p>并且我们可以通过在地址后面加上/10指明只需要返回第十条数据</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-31-23.5db96jv5b280.webp"                      alt="Snipaste_2022-01-11_11-31-23"                ></p><p>或者像这样传入额外的参数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-32-10.68uqpki765s0.webp"                      alt="Snipaste_2022-01-11_11-32-10"                ></p><p>筛选出userid=5的所有数据，如果我们想添加一条新数据，我们可以使用POST方法去请求同一个地址，并将要添加的数据以json格式发送给服务器</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-35-02.4g3pdtwsxoy0.webp"                      alt="Snipaste_2022-01-11_11-35-02"                ></p><p>服务器在成功添加数据之后，会将新添加的数据直接返回给浏览器</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-36-04.12l8t9h0g6gw.webp"                      alt="Snipaste_2022-01-11_11-36-04"                ></p><p>如果我们要更新某条数据，我们可以使用PATCH方法</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-37-59.bx7y3tfx2co.webp"                      alt="Snipaste_2022-01-11_11-37-59"                ></p><p>同样的如果要删除数据，我们可以使用DELETE方法</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-39-00.3iqqmlg15m80.webp"                      alt="Snipaste_2022-01-11_11-39-00"                ></p><p>顺便值得一提的是这几年逐渐流行的另一种API架构–GraphQL</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-40-13.1pqjn6qyr0yo.webp"                      alt="Snipaste_2022-01-11_11-40-13"                ></p><p>GraphQL允许使用一种相当灵活的查询语言，来精确获取你需要的数据</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-42-06.1y60f7ae01k0.webp"                      alt="Snipaste_2022-01-11_11-42-06"                ></p><p>它的灵活性和可扩展性会比REST API高出很多，正因为如此，GraphQL非常适合大型项目的API设计，当然如果你的项目只需要简单固定的API，GraphQL就显得有些大材小用了</p><p>接下来我们来了解下数据库管理系统</p><p>如果你的web应用需要对大规模数据进行并发的读取和修改，同时还要兼顾到数据的完整性和安全性，数据库将会是必不可少的一部分，现在的数据库系统大致可以分为两类，SQL和NoSQL类型的数据库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-46-56.6mhz8m3q2ls0.webp"                      alt="Snipaste_2022-01-11_11-46-56"                ></p><p>SQL指的是传统的关系型数据库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-48-02.1f4stqmmrmn4.webp"                      alt="Snipaste_2022-01-11_11-48-02"                ></p><p>它使用结构化查询语言(SQL)对数据进行查询和修改</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-49-05.2945vff29ztw.webp"                      alt="Snipaste_2022-01-11_11-49-05"                ></p><p>关系型数据库对数据有相当严格的一致性和完整性检查，至今快50年的历史也足以证明它是相当可靠的</p><p>相反，NoSQL的数据库减少了许多的强制检查，通常具有更优的读写性能，并且对数据的格式要求也更加松散，更能够适应日益变化的需求</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-53-22.6r9wajdegis0.webp"                      alt="Snipaste_2022-01-11_11-53-22"                ></p><p>作为SQL和NoSQL的入门，我非常推荐使用PostgreSQL或者MongoDB，这两个数据库都是开源免费的，并且有相当数量的用户群，这里我以MongoDB为例来介绍下JavaScript中数据库的基本使用，我们可以使用一个叫做mongoose的包对mongoDB进行访问，在使用数据库之前，我们需要先定义数据的结构(Schema)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_11-59-36.jju4kxu8bvs.webp"                      alt="Snipaste_2022-01-11_11-59-36"                ></p><p>比如这里的联系人Contact由姓名电话和一些其他信息组成，可以看到name是字符串，并且是必须填写的字段，cteateDate是一个日期对象，它会被自动设置成数据创建时的时间，在定义了数据的结构之后，我们可以利用之前讲到的REST API在POST请求时，我们可以使用new Contact创建一个新的联系人</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_14-22-00.305h9uikdhm0.webp"                      alt="Snipaste_2022-01-11_14-22-00"                ></p><p>并使用save方法将数据保存至数据库，最后将新添加的Contact对象以json格式返回</p><p>此时如果我们访问这个REST API，当数据被成功保存之后，可以看到这里返回的新联系人id以及它的创建时间</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_14-28-16.1lu4w96v1m74.webp"                      alt="Snipaste_2022-01-11_14-28-16"                ></p><p>最后在web开发中还有非常重要的一环，通常我们会听到这么一个词DevOps，它是“开发”和“运维”这两个词的组合</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-11_14-30-18.6uz7tli7mj40.webp"                      alt="Snipaste_2022-01-11_14-30-18"                ></p><p>它所解决的问题是如何将你写的web应用部署运行到最终的服务器上并让所有人访问，不过DevOps会通过各种自动化手段让整个部署流程更省事和可靠</p><p>在最后，我想向大家推荐几个web的学习资源，它们都是GitHub上超高星标的仓库</p><ol><li>Web开发路线图：<a class="link"   href="https://github.com/ccloli/developer-roadmap-zh-CN" >https://github.com/ccloli/developer-roadmap-zh-CN<i class="fas fa-external-link-alt"></i></a></li><li>现代Web开发魔法全书：<a class="link"   href="https://github.com/dexteryy/spellbook-of-modern-webdev" >https://github.com/dexteryy/spellbook-of-modern-webdev<i class="fas fa-external-link-alt"></i></a></li><li>成为Web全栈工程师：<a class="link"   href="https://github.com/bmorelli25/Become-A-Full-Stack-Web-Developer" >https://github.com/bmorelli25/Become-A-Full-Stack-Web-Developer<i class="fas fa-external-link-alt"></i></a></li><li>Awesome列表系列：<a class="link"   href="https://github.com/sindresorhus/awesome" >https://github.com/sindresorhus/awesome<i class="fas fa-external-link-alt"></i></a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;过去的10年可以说是web技术变革最大，更新迭代最快的10年，如今的web已经不单单是信息展示的渠道，更是各种功能复杂应用的集合，这是一张2021年的web开发路线图&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
         </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10个Python编程技巧 让你的代码更上一层楼</title>
    <link href="http://example.com/2022/01/08/10%E4%B8%AAPython%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%20%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%82%E6%A5%BC/"/>
    <id>http://example.com/2022/01/08/10%E4%B8%AAPython%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%20%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E4%B8%8A%E4%B8%80%E5%B1%82%E6%A5%BC/</id>
    <published>2022-01-08T03:40:30.000Z</published>
    <updated>2022-01-10T08:31:56.591Z</updated>
    
    <content type="html"><![CDATA[<p>Python可以说是近十年来增长速度最快、应用最广泛，并且是世界范围内最受欢迎的编程语言之一，今天，我来给大家讲10个我个人觉得非常实用，但可能并不是所有人都知道的Python编程技巧，保持这些良好的编程习惯，可以让我们写出更清晰、更优雅、更易读、更赏心悦目的代码</p><p>Python语言其实在设计之初就有在考虑它语法的简洁性和可读性，可能有人听说过Python之禅(Zen of Python)这其实是Tim Peters在Python中留下的一个彩蛋，如果你进入Python，然后输入import this，你会看到作者留下的一条条编程建议:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_11-54-02.4wecqbxpa320.webp"                      alt="Snipaste_2022-01-08_11-54-02"                ></p><p>其中列出的这20条规制，就是在告诉你Python程序编写的指导方针，另外，大家如果听说过Pythonic这个词，它其实是用Python加上后缀ic创造出来的一个英语单词，它指的也是具有Python独特风格、简介而优雅的代码，最后甚至在Python语言的提案PEP8中也定义了一条条让代码更清晰、更简洁的代码规范，这里我筛选出了10个重要的技巧，接下来我们就用实例来一一讲解下叭:</p><ol><li><p>变量交换</p><p>在很多编程语言中，如果我们需要交换变量a和b中的内容，通常我们可以定义一个临时变量，先将a的内容存放在其中，然后将a设置为b，再将b设置成这个临时变量:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_14-23-34.78erv3xig4w0.webp"                      alt="Snipaste_2022-01-08_14-23-34"                ></p><p>不过，上面这段代码在Python中其实可以被改成这样:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_14-25-13.6oi91vfs7wg0.webp"                      alt="Snipaste_2022-01-08_14-25-13"                ></p><p>这样的话，程序的可读性是不是提高了很多呢</p></li><li><p>字符串格式化(String Formatting)</p><p>通常在程序中我们需要组合或者拼接字符串的话，我们可以用加号来做字符串的连接:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_14-32-12.4w4i9ea66080.webp"                      alt="Snipaste_2022-01-08_14-32-12"                ></p><p>如果只是做两个字符串的拼接，这样写其实没有什么问题，不过如果字符串比较多的话，类似于这种情况:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_14-35-21.znow1ceqdy8.webp"                      alt="Snipaste_2022-01-08_14-35-21"                ></p><p>这样的程序会显得非常杂乱并且不易阅读，而且，当我们在连接整形数据的时候还需要进行类型的转换，不然程序也会报错:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_14-37-45.2ofd4ka17qc0.webp"                      alt="Snipaste_2022-01-08_14-37-45"                ></p><p>其实我们可以把程序写成这个样子:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_14-38-43.4g0gepw1iwi0.webp"                      alt="Snipaste_2022-01-08_14-38-43"                ></p><p>利用Python中的百分号语法来格式化字符串，其中%s代表这里的内容会被替换成一个字符串，这里的s是string的首字母，这里的%d会被替换成一个十进制数，d是decimal的缩写，最后面这个%()中定义了需要被替换的内容，虽然程序写成这样已经好看很多了，我们在这里还可以做的更好一些，我们可以利用Python中的format()函数和花括号语法，把程序写成这样:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_14-43-00.3dg7mi1rlqg0.webp"                      alt="Snipaste_2022-01-08_14-43-00"                ></p><p>format()在这里是字符串对象的一个方法，调用它会返回被格式化后的新字符串，而花括号中的内容会被最终替换成format()函数中传入的各个参数</p><p>使用这种方式的另一个好处是，如果你有重复的需要被替换的内容，你可以在花括号中写入被替换参数的索引，就像这样:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_14-47-36.2bm5qdc6j0ro.webp"                      alt="Snipaste_2022-01-08_14-47-36"                ></p><p>因此这里的两个花括号都会被替换成同一个内容，也就是这里索引为0的第一个参数name，最后如果你使用的是Python3.6以上的版本，这里有一个最简单的写法:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_14-49-37.32cqrdce7600.webp"                      alt="Snipaste_2022-01-08_14-49-37"                ></p><p>也是我最喜欢的，叫做f-string，我们只需要在字符串开头写一个f，花括号中的内容就会被自动替换成指定表达式的值，注意，这里我说的是<strong>表达式</strong>，比如我们可以把这里的age改成age+1,Python将会把表达式运行的结果也就是29替换在字符串中，由于这里可以填写任意的表达式，所以你甚至可以调用一个函数返回一个数值，并替换在字符串中，这也是没有问题的</p></li><li><p>Python中的yield语法</p><p>比如在这里，我们定义了一个函数fibonacci()，来列举斐波那契数列中的前n个数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_17-12-52.fsxvrpqmals.webp"                      alt="Snipaste_2022-01-08_17-12-52"                ></p><p>斐波那契数列大家应该都听说过，简而言之，就是除了最前面两个数之外，其中每个数字都是前两个数字之和，比如这里的5是前面2跟3的和:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_17-15-35.k38fmc3axps.webp"                      alt="Snipaste_2022-01-08_17-15-35"                ></p><p>这个程序里面有两个变量:a和b，他们分别代表前一个数和当前的数，这里的循环会执行n次，而每次循环，程序都会把之前的数存放在一个叫做nums的列表中，然后之前的数会被替换成当前这个数，当前这个数会被替换成前两个数之和，然后程序就会循环往复地执行下去，直到计算出第n个数为止，此时，如果我们使用print()在屏幕上显示这10个数，我们会得到这样的结果:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_17-49-48.33xnlkoxgkq0.webp"                      alt="Snipaste_2022-01-08_17-49-48"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_17-51-26.2arfs94p3v28.webp"                      alt="Snipaste_2022-01-08_17-51-26"                ></p><p>在这里，我们可以修改这个fibonacci()函数来使用Python的yield语法</p><p>我们首先把“list末尾添加元素”的操作替换成yield a</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_18-02-00.6qsylq66e200.webp"                      alt="Snipaste_2022-01-08_18-02-00"                ></p><p>然后删掉这里的nums列表，这样修改后的程序会完成和之前一样的操作:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_18-03-10.1pzeo0xksra8.webp"                      alt="Snipaste_2022-01-08_18-03-10"                ></p><p>这里的yield表示每当我们计算出一个元素，就立马把这个元素给送出去，也就是说外面的for loop中就会立即输出这个数，因此使用yield的好处是，我们并不需要等待整个列表都生成完毕后再来一个一个地输出，yield在英文中的意思是产出，单从字面上来看还是比较抽象的，不过它和return的区别是，当你的函数yield一个数值以后，函数并不会立即停止，而会继续执行下去，yield的优势在于一些非常耗时的操作，比如我们可以写一个函数来从网络上下载一系列文档，并输入每个文档的内容，如果我们使用yield，则可以保证在一个文被下载成功后，就立马输出它的内容，而无需等待所有文档都下载完毕</p></li><li><p>列表解析式(List Comprehension)</p><p>比如在这里我们有一系列水果的名字</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_18-44-27.3dc9u4lbx6g0.webp"                      alt="Snipaste_2022-01-08_18-44-27"                ></p><p>存放在一个叫fruit的列表中，如果我们希望把这些名字都改为大写，这里有很多种办法，比如写一个for loop遍历所有名字，并把他们改写成大写</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_18-46-14.7cl79qyi4co.webp"                                     ></p><p>其实这里有一个更为简单的语法，之前的代码可以直接被改写成这样</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_18-48-02.4ryjocvm98k0.webp"                      alt="Snipaste_2022-01-08_18-48-02"                ></p><p>后面这个方括号语法实际上是在构造一个新的列表，并把它赋值给之前的这个fruit变量，我们可以这样来理解这个语法，方括号的后半部分实际上是在告诉Python我需要枚举fruit变量中的所有元素，而其中的每一个元素的名字叫做x，而方括号里的前半部分x.upper()则是将这里的每个字符串x转换成大写，列表解析式其实还有另外一种应用，筛选或者过滤列表中的元素，比如，如果我们希望挑选出列表里以a开头的水果，那么一种常见的方法是写一个循环，然后挑选出需要的元素存放在一个新列表中，其实利用我们之前讲到的列表解析式，我们可以将程序改写成这样</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_18-54-55.1pliv3vjrqhs.webp"                      alt="Snipaste_2022-01-08_18-54-55"                ></p></li><li><p>Python中关于循环的技巧:Enumerate()函数</p><p>还是使用之前的例子，如果我们需要按顺序输出某一个列表中的所有元素，我们可以使用for…in的语法，如果我们希望同时得到每一个水果在列表中对应的索引值，比如apple的索引是0，pear是1，我们可以使用一个叫做enumerate()的函数，把程序改成这样</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_15-17-55.11pxlhlu3p5s.webp"                      alt="Snipaste_2022-01-10_15-17-55"                ></p><p>这里的enumerate()函数会在每一次循环的过程中提供两个参数。第一个i代表列表元素的索引值，第二个x代表元素中的内容</p></li><li><p>反向遍历</p><p>这个其实是对上一个技巧的延伸，如果我们希望将fruit中的元素后往前依次输出，那么我们应该怎么做呢，其实我们只需要在遍历元素的时候加入reversed()函数就搞定了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_15-36-55.rlf3odyuz2o.webp"                      alt="Snipaste_2022-01-10_15-36-55"                ></p></li><li><p>按顺序遍历</p><p>这里我们再延伸一下，如果我们希望输出的元素是按照水果名字的字典顺序，也就是说名字以a开头的排在最前面，以z开头的排在最后面，应该怎么办呢，这里我们可以使用到Python中的一个内建函数sorted()，将fruit用这个函数括起来就好了，sorted()函数会返回一个新的并经过排序后的列表，因此我们在使用循环输出时，内容就已经被事先排序好了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_15-42-47.wkix30z6leo.webp"                      alt="Snipaste_2022-01-10_15-42-47"                ></p></li><li><p>字典的合并操作</p><p>比如在这里我们有两个字典，其中存放不同用户的用户名和密码</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_15-47-37.5xx6izyno840.webp"                      alt="Snipaste_2022-01-10_15-47-37"                ></p><p>这时候，我们可以写这么一个程序将这两个字典合并成一个字典，也就是这里的c</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_15-49-15.19iy6klu9aqo.webp"                      alt="Snipaste_2022-01-10_15-49-15"                ></p><p>不过我们可以将这里的5行代码，改成更加简洁的形式<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_15-51-49.5pmfw8dnesk0.webp"                      alt="Snipaste_2022-01-10_15-51-49"                ></p><p>他们都会执行完全一样的操作，这里的这两个*在Python中叫做解包(unpacking)，也就是说这里的<code>**a和**b</code>相当于是将字典a和b中的内容直接填写到了这里</p></li><li><p>Python中的三元运算符</p><p>在Python程序中，我们经常会完成这么一项操作:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_16-01-23.3fadnzig1360.webp"                      alt="Snipaste_2022-01-10_16-01-23"                ></p><p>将一个变量设置成不同的值，比如在这个例子中，我们会根据score里面存储的数值是否大于60，来决定s里面的内容是pass还是fail，其实这里的代码可以直接被改成这样</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_16-04-22.1lutpipjotr4.webp"                      alt="Snipaste_2022-01-10_16-04-22"                ></p><p>这里的if…else称为Python中的三元运算符，当if后面的条件满足时，表达式会输出前面的这个值，当条件不满足时，表达式会输出后面这个值，它的功能等价于c或者java中的三元运算符，尽管它们的写法完全不一样</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_16-08-05.1jojo34mquxs.webp"                      alt="Snipaste_2022-01-10_16-08-05"                ></p></li><li><p>Python中序列的解包</p><p>比如我们在这里，我们定义了一个变量name，里面存储了张三同学的姓和名</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_16-12-37.ydom3lly7p.webp"                      alt="Snipaste_2022-01-10_16-12-37"                ></p><p>如果我们想单独提取出它的姓和名，并把它们存放在不同的变量里，我们可以利用字符串对象中的split()方法，把这个字符串按空格分割成多个字符串，然后我们再利用列表的索引提取出对应的姓和名</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_16-15-07.5k8nx16us7g0.webp"                      alt="Snipaste_2022-01-10_16-15-07"                ></p><p>不过这段程序可以被我们改成这个样子:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_16-15-58.6yd0md0o0vc0.webp"                      alt="Snipaste_2022-01-10_16-15-58"                ></p><p>这里，我们直接将split()函数返回的列表中的元素赋值给first_name和last_name,中间以逗号的形式隔开，这个操作在Python中被称作序列解包，需要注意的是，这里的”序列”其实并不一定需要是列表，它也可以是元组，甚至是range，因为它们都代表一系列元素，也就是序列</p></li><li><p>Python中的with语句</p><p>在Python中，如果我们想读取某一个文件的内容，我们可以使用open()函数打开一个文件，并利用返回的这个文件对象f来对文件进行操作</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_16-24-23.2g2y8fusrav4.webp"                      alt="Snipaste_2022-01-10_16-24-23"                ></p><p>不过，当我们完成对文件的读取，不在需要这个对象之后，一定不要忘记调用close()方法来关闭这个文件，如果你忘记关闭这个文件，Python将一直占用这个文件的系统资源，直到你的程序完全退出为止，对于一个小脚本来说，这不是什么大事，但是对于一个需要长时间在服务器里运行的程序，你的系统资源可能很快就被吃光，然后你的程序就会崩溃，所以一个好的习惯是使用Python的with语句，将程序改写成这种形式</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220110/Snipaste_2022-01-10_16-30-16.1ce8ks2vy7z4.webp"                      alt="Snipaste_2022-01-10_16-30-16"                ></p><p>这样写的话，就不需要手动的调用close()函数了，当with语句之后的代码执行完毕之后，这个文件就会自动被Python关闭</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python可以说是近十年来增长速度最快、应用最广泛，并且是世界范围内最受欢迎的编程语言之一，今天，我来给大家讲10个我个人觉得非常实用，但可能并不是所有人都知道的Python编程技巧，保持这些良好的编程习惯，可以让我们写出更清晰、更优雅、更易读、更赏心悦目的代码&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git+Github10分钟完全入门以及Git图形界面GitKraken的基础使用</title>
    <link href="http://example.com/2022/01/07/Git+Github10%E5%88%86%E9%92%9F%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E4%BB%A5%E5%8F%8AGit%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2GitKraken%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/01/07/Git+Github10%E5%88%86%E9%92%9F%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8%E4%BB%A5%E5%8F%8AGit%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2GitKraken%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</id>
    <published>2022-01-07T10:43:30.000Z</published>
    <updated>2022-01-08T03:25:51.500Z</updated>
    
    <content type="html"><![CDATA[<p>大家也许听说过git是一款使用人数众多的分布式版本控制系统，可是到底什么是版本控制系统，git和github又有什么区别和联系呢</p><p>今天，我们来用一个全新的视角来了解这款必备工具，并解密这些被复杂化的概念和生僻术语</p><p>在我们码代码的时候，我们可能经常会有这样的需求，我们可能希望保存源代码的不同版本，当软件出现bug时我们可以回溯到之前的状态，比较版本之间的差别从而找出bug的源头，并且，再多人分工协作的时候，我们也会经常修改到相同的文件，这时候，如果有一个工具能够帮助我们完成修改的合并，也许就可以帮我们节省不少的时间，那么版本控制系统也应运而生:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-07_23-14-51.8yhhkfbk8qo.webp"                      alt="Snipaste_2022-01-07_23-14-51"                ></p><p>如果你只是经常写一些脚本或者简单程序的话，版本控制软件可能用得比较少，但是项目规模一旦大起来，或者涉及到团队协作的时候，版本控制系统可以说是必不可少的，git其实也只是众多版本控制系统中的一种，其它的你可能听过的还包括CVS、Subversion、Mecurial、Perforce、Bazaar等等:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-07_23-19-29.4f2z7jfe3380.webp"                      alt="Snipaste_2022-01-07_23-19-29"                ></p><p>其实它们都有各自的优缺点，并且应用的领域也稍有不同，git可以说是应用最为广泛，并且最适合于中小项目开发的工具之一，而且版本控制的许多概念其实是互通的，如果你还没接触过相关软件的话，我也非常推荐从git这一款入门，另外git本身其实是一款命令行工具，可能很多人更加推崇使用命令行工具而不是图形化工具，这个我觉得是仁者见仁智者见智，这两个我自己平时也都会用到，命令行更方便于写脚本、自动化，图形化工具的操作通常更直观，入门也更加轻松；当然在这里最重要的还是掌握git以及版本控制系统的核心概念,因此作为入门我推荐的是一个叫做GitKraKen的图形化客户端它支持主流的操作系统，界面很漂亮，功能也很全面，并且对个人的开发是完全免费的，大家可以通过下面的链接在官网上下载对应的版本安装：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-06-43.7gjzzr22b0o0.webp"                      alt="Snipaste_2022-01-08_09-06-43"                ></p><p>第一次使用GitKraKen它会提示你进行登录</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-10-58.181dv30lsjsw.webp"                      alt="Snipaste_2022-01-08_09-10-58"                ></p><p>这里我推荐大家用自己的GitHbu账号登录，如果还没有GitHub账号的小伙伴现在可以去注册一个，因为早晚都会用到的，登录完成之后呢，他会提示你输入一些个人信息，比如你的用户名称和邮件地址，这个信息和签名档很像，他会附带在你每一次的代码提交上</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-15-58.7d7vgcfhavs0.webp"                      alt="Snipaste_2022-01-08_09-15-58"                ></p><p>信息填写完毕之后呢，我们就来到了GitKraKen的主界面，接下来的第一步是创建一个代码仓库(Repository)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-21-24.70vdra37tps.webp"                      alt="Snipaste_2022-01-08_09-21-24"                ></p><p>仓库这个术语指的是与项目相关的所有文件，包括源代码、工程文件、资源文件和一些配置信息，它可以是本地的仓库，可以是保存在远程服务器上的仓库，仓库之间可以相互同步，比如你可以把本地计算机上的代码同步到远程的服务器上</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-23-49.3c0m779szp40.webp"                      alt="Snipaste_2022-01-08_09-23-49"                ></p><p>github上就保存了很多远程代码仓库，他也是当今最大的代码托管网站和开源社区</p><p>这里创建代码仓库的时候呢，我们直接一步到位，点击这个按钮创建一个托管在GitHub上的代码仓库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-29-13.2foyvwrqd1us.webp"                      alt="Snipaste_2022-01-08_09-29-13"                ></p><p>待会儿我们就不用再特别设置用于同步的远程服务器了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-34-54.6d1zdiyx7og0.webp"                      alt="Snipaste_2022-01-08_09-34-54"                ></p><p>这里，我们选择之前登录的GitHub账号，给仓库起一个名字</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-36-56.4ec71sp0gqk0.webp"                      alt="Snipaste_2022-01-08_09-36-56"                ></p><p>并附上一个简短的介绍，最后点击下面绿色的按钮完成创建</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-38-22.1dbpryfcyi3k.webp"                      alt="Snipaste_2022-01-08_09-38-22"                ></p><p>中间这个很大的区域显示了代码的所有提交历史，其中的每一项代表一个提交(commit)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-40-30.7300ftd8slg0.webp"                      alt="Snipaste_2022-01-08_09-40-30"                ></p><p>提交这个术语很像是游戏里面的检查点或者是一个快照，在每一次你对代码做出修改之后，你可以提交这一次的所有修改，此时git会保存当前的代码快照，在之后的若干次修改之后，我们也可以轻松地回溯到这一次修改的状态，可以看到，这里唯一的一个提交是在新建代码仓库时候自动创建的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-44-56.3ebx0pmb0s80.webp"                      alt="Snipaste_2022-01-08_09-44-56"                ></p><p>我们选中这个提交后，可以看到这个提交中修改的所有文件，比如这里可以看到有一个新文件README被创建(这里加号所代表的)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-47-29.4azobybk9wo0.webp"                      alt="Snipaste_2022-01-08_09-47-29"                ></p><p>那么接下来，我们新建一个代码文件，并完成一次新的提交，我们可以先点击文件菜单中的“在文件浏览器中打开”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-50-04.4nxwi80zlew0.webp"                      alt="Snipaste_2022-01-08_09-50-04"                ></p><p>然后找到当前代码仓库在本地计算机上存放的位置，这里我们新创建一个文件并命名为hello.c,然后我们在里面随便写一个helloworld程序，保存文件之后，我们回到GitKraKen中，可以看到中间的“提交历史”中多出了一项WIP，代表这个提交”正在施工中”(working in progress)<img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_09-57-29.71s3i1nj6qc0.webp"                      alt="Snipaste_2022-01-08_09-57-29"                ></p><p>在右边我们可以看到多出来了一个我们刚刚创建的源代码文件，点击它也可以看到文件中被修改的具体内容</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-01-12.zr8hz1y0h9s.webp"                      alt="Snipaste_2022-01-08_10-01-12"                ></p><p>接下来，我们来提交这个文件，我们首先点击这里的Stage</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-02-55.5i3nyip114k0.webp"                      alt="Snipaste_2022-01-08_10-02-55"                ></p><p>git要求再对修改的文件提交之前必须将它们Stage，你可以把它想象成提交之前的一个必经阶段，防止你误操作，然后你可以在下面输入你对这次代码提交的一个小总结，这个信息是必填的(在sourcetree不是必须的),你想想如果你面对的是大堆”无名的”历史提交，想从中找出你需要的如同是大海捞针</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-08-23.6mo30e1sayo0.webp"                      alt="Snipaste_2022-01-08_10-08-23"                ></p><p>最后点击下面的提交按钮完成这一次提交</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-10-36.gv1ol5r3dpk.webp"                      alt="Snipaste_2022-01-08_10-10-36"                ></p><p>到目前为止，我们所有操作都是针对你本地计算机上的代码仓库的，如果我们去浏览GitHub上的远程仓库，可以看到还是处于最原始的状态</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-13-09.51ru2pb9pn40.webp"                      alt="Snipaste_2022-01-08_10-13-09"                ></p><p>如果我们希望将所有的提交都同步到远程的GitHub服务器上，让所有人都能看到你的修改的话，我们需要使用到Git中的Push功能</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-15-00.1ur4mqbcmakg.webp"                      alt="Snipaste_2022-01-08_10-15-00"                ></p><p>在GitKraken中我们点工具栏中的Push按钮即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-16-27.54fn2llsods0.webp"                      alt="Snipaste_2022-01-08_10-16-27"                ></p><p>这里的origin通常指的是默认的远程的服务器，推送之后呢，如果我们再次刷新GitHub上的页面，可以看到所有的代码已经成功上传上去了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-19-20.7jf3aqnpiew0.webp"                      alt="Snipaste_2022-01-08_10-19-20"                ></p><p>如果我们点这里的commits也可以看到和本地一样的所有代码的提交历史</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-20-58.6h3pjd3y6mg0.webp"                      alt="Snipaste_2022-01-08_10-20-58"                ></p><p>我们既然可以把本地代码提交推送到远程服务器，就一定可以从远程服务器下载新的提交</p><p>接下来我们来讲一下Git中与Push相对应的Pull(拉取)操作</p><p>比如这里我的一个朋友小罗也往远程服务器上推送了一个提交</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-25-07.2o0oyrpyuq20.webp"                      alt="Snipaste_2022-01-08_10-25-07"                ></p><p>我们点开后发现他对README.md文件进行了一点小修改</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-26-32.3dymhg6kh2y0.webp"                      alt="Snipaste_2022-01-08_10-26-32"                ></p><p>如果我们切换到GitKraken中也可以看到提交历史的最上面多出来了这一条</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-28-12.17j63cr24s68.webp"                      alt="Snipaste_2022-01-08_10-28-12"                ></p><p>左边有两个小标签我们需要注意下，这个写有master并画有电脑图标的标签代表本地仓库中的提交，上面这个则是表示GitHub上远程仓库的提交，这里的master是一个分支branch，我们待会儿会讲到，那这个时候如果我们想把这位同学的修改同步到本地仓库的话我们可以点击GitKraken中的pull按钮</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-33-48.3xdtffu4v2m0.webp"                      alt="Snipaste_2022-01-08_10-33-48"                ></p><p>之后呢这两个图标会重叠在一起，代表本地仓库和远程仓库的提交历史已经完全一样了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-36-00.5j62e5yn6u00.webp"                      alt="Snipaste_2022-01-08_10-36-00"                ></p><p>这时候我们也打开本地仓库中的README.txt文件，也可以看到其中修改的内容，那可能有人问，比如当不同的人去修改相同的文件的时候git会怎么做呢，接下来，我们来看一下git中的合并操作(Merge),也是版本控制工具中非常重要的一环，这里在最新的提交中我们看到小罗同学修改了一下hello.c文件，往里面添加了一个函数multiply()</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-42-54.3ue72f5lfb20.webp"                      alt="Snipaste_2022-01-08_10-42-54"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-43-30.4tk1s7tsm000.webp"                      alt="Snipaste_2022-01-08_10-43-30"                ></p><p>接下来我们在本地也去修改同一个文件，将主函数中输出的字符串修改一下</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-46-14.2q2ceka7q540.webp"                      alt="Snipaste_2022-01-08_10-46-14"                ></p><p>然后按照之前的步骤，在本地提交这一次修改，这里，我们看到提交的历史出现了一个分叉，下面这个显示了远程仓库中小罗同学的提交，上面这个是我刚才创建的本地提交，如果我们希望这两个对hello.c的修改同时应用在你本地的代码仓库中，我们则需要将这两个提交合并起来，合并其实在Git中有很多种方式，我们先讲一种最简单的，就是使用之前提到的Pull功能，git会在获取远程提交的同时将远程的提交合并到本地的提交中，这里我们可以点上面的Pull按钮，可以看到在窗口的最上面，git为我们自动生成了一个新提交，这个提交做的事情就是将之前的两个提交合并起来</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-56-52.3d3icw82c5q0.webp"                      alt="Snipaste_2022-01-08_10-56-52"                ></p><p>这时候如果我们打开hello.c也可以看到这两处的修改已经被git自动合并了<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_10-58-57.6l73yk65li00.webp"                      alt="Snipaste_2022-01-08_10-58-57"                ></p><p>这时候可能有人问了，如果两个人修改代码的同一处位置，git又会怎么做呢，我们一起来研究一下</p><p>这里小罗同学修改了一下这里的字符串，在前面加了一个“Little”,我们也去修改同一行代码，把这里的“Yoyo”改成“Hey”，然后本地提交这一次修改，可以看到这里的提交又开始出现了分叉</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_11-07-53.1nrujo5xdstc.webp"                      alt="Snipaste_2022-01-08_11-07-53"                ></p><p>接下来我们来合并他们，按照之前的做法，我们可以之间点击Pull，不过这次git的自动合并失败了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_11-10-27.e2bg81g09wg.webp"                      alt="Snipaste_2022-01-08_11-10-27"                ></p><p>取而代之的是一个错误信息，告诉我们这里有冲突(conflict)需要我们手动解决，原因很简单，git也不知道应该如何合并了，毕竟我们修改的是同一行代码，我们可以点右边的冲突文件下的这个hello.c文件，左边窗口显示的是我们刚刚的修改，右边显示的是远程仓库上小罗的修改(还记得我们之前说的origin通常代表远程仓库嘛)，下面的这个窗口代表合并之后的结果，是我们手动解决冲突用的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_11-16-45.556mbk8a4j40.webp"                      alt="Snipaste_2022-01-08_11-16-45"                ></p><p>那我们看了代码当然明白，应该该将Yoyo改成Hey，并在后面加一个Little</p><p>修改完成之后我们保存文件回到之前的窗口和之前一样描述一下这次合并的内容并完成这一次提交</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_11-20-00.7igmnguv0000.webp"                      alt="Snipaste_2022-01-08_11-20-00"                ></p><p>软件中对应的命令行指令:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-08_11-21-27.5efff5vc5ks0.webp"                      alt="Snipaste_2022-01-08_11-21-27"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家也许听说过git是一款使用人数众多的分布式版本控制系统，可是到底什么是版本控制系统，git和github又有什么区别和联系呢&lt;/p&gt;
&lt;p&gt;今天，我们来用一个全新的视角来了解这款必备工具，并解密这些被复杂化的概念和生僻术语&lt;/p&gt;
&lt;p&gt;在我们码代码的时候，我们可能经常</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>记一次sourcetree推送代码进度条一直在动可就是推不上去的错误解决方法</title>
    <link href="http://example.com/2022/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1sourcetree%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E8%BF%9B%E5%BA%A6%E6%9D%A1%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%8A%A8%E5%8F%AF%E5%B0%B1%E6%98%AF%E6%8E%A8%E4%B8%8D%E4%B8%8A%E5%8E%BB%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/01/07/%E8%AE%B0%E4%B8%80%E6%AC%A1sourcetree%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E8%BF%9B%E5%BA%A6%E6%9D%A1%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%8A%A8%E5%8F%AF%E5%B0%B1%E6%98%AF%E6%8E%A8%E4%B8%8D%E4%B8%8A%E5%8E%BB%E7%9A%84%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2022-01-07T10:27:30.000Z</published>
    <updated>2022-01-07T10:32:43.496Z</updated>
    
    <content type="html"><![CDATA[<p>今天在某个本地仓库新增了一些数据，然后想着把数据提交一下，然后在使用sourcetree的时候提交进度条在移动然后始终推送不上去，后面在网上查阅资料说可能是安装了git但是没有给surcetree权限:</p><p><a class="link"   href="https://blog.csdn.net/Baron0071/article/details/84062638?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-84062638.pc_agg_new_rank&amp;utm_term=sourcetree%E6%8E%A8%E9%80%81%E4%B8%80%E7%9B%B4%E8%BD%AC&amp;spm=1000.2123.3001.4430" >https://blog.csdn.net/Baron0071/article/details/84062638?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-84062638.pc_agg_new_rank&amp;utm_term=sourcetree%E6%8E%A8%E9%80%81%E4%B8%80%E7%9B%B4%E8%BD%AC&amp;spm=1000.2123.3001.4430<i class="fas fa-external-link-alt"></i></a></p><p>我照着他的步骤执行了一遍发现我确实是这么配置的但是在我点击确定后就能推送上去了，这可能是soucetree的一个小bug叭</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天在某个本地仓库新增了一些数据，然后想着把数据提交一下，然后在使用sourcetree的时候提交进度条在移动然后始终推送不上去，后面在网上查阅资料说可能是安装了git但是没有给surcetree权限:&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;http</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>0.1+02等于0.3嘛，无可避免的浮点误差</title>
    <link href="http://example.com/2022/01/07/0.1+02%E7%AD%89%E4%BA%8E0.3%E5%98%9B%EF%BC%8C%E6%97%A0%E5%8F%AF%E9%81%BF%E5%85%8D%E7%9A%84%E6%B5%AE%E7%82%B9%E8%AF%AF%E5%B7%AE/"/>
    <id>http://example.com/2022/01/07/0.1+02%E7%AD%89%E4%BA%8E0.3%E5%98%9B%EF%BC%8C%E6%97%A0%E5%8F%AF%E9%81%BF%E5%85%8D%E7%9A%84%E6%B5%AE%E7%82%B9%E8%AF%AF%E5%B7%AE/</id>
    <published>2022-01-07T06:49:30.000Z</published>
    <updated>2022-01-07T08:39:16.240Z</updated>
    
    <content type="html"><![CDATA[<p>在我们印象中，计算机总是能高效准确地进行运算:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-52-48.1wye498a9hpc.webp"                      alt="Snipaste_2022-01-07_14-52-48"                ><br>直到有一天你满怀欣喜地打开最喜欢的编程环境，输入0.1+0.2，但计算机却返回这个:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-55-07.6gskzi8s9r80.webp"                      alt="Snipaste_2022-01-07_14-55-07"                ></p><p>你下意识觉得这可能是一个bug，然后在不同语言中反复求证，却一致地得到相同的答案：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-56-53.2ru1tt7usii0.webp"                      alt="Snipaste_2022-01-07_14-56-53"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-58-10.1kaelcxf7wow.webp"                      alt="Snipaste_2022-01-07_14-58-10"                ></p><p>究竟是道德的沦丧还是人性的扭曲</p><p>这一切都要从一个盛行了三十多年的标准IEEE-754讲起，IEEE-754定义了浮点数的格式、存储和运算：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-01-45.e7tycge22rc.webp"                      alt="Snipaste_2022-01-07_15-01-45"                ></p><p>它对浮点数的表示和我们熟知的科学计数法如出一辙</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-04-49.4t9wogbsbgc0.webp"                      alt="Snipaste_2022-01-07_15-04-49"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-05-24.2vmwyt2bqae0.webp"                      alt="Snipaste_2022-01-07_15-05-24"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-06-02.1utl8yp4rmlc.webp"                      alt="Snipaste_2022-01-07_15-06-02"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-06-37.4jlfyyrr3uw0.webp"                      alt="Snipaste_2022-01-07_15-06-37"                ></p><p>一个浮点数会被分成两部分存储,第一部分尾数(mantissa)也叫做有效数字(signigicand)，也就是下图用红色高亮的部分，第二部分指数(exponent)也就是这里黄色高亮的部分：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-10-09.6x5lemv66k40.webp"                      alt="Snipaste_2022-01-07_15-10-09"                ></p><p>由于尾数和指数分开存储，使得浮点数天生可以表示很大范围的数字，你可以用它表示整个星系的大小，也可以表示微观粒子的半径，并且现代计算机对浮点数做了大量优化，能够在很短时间内进行相当复杂的运算，一个典型的例子就图形渲染，每秒60帧的画面，每帧几百万的像素点同时参与光照计算，大家可以想想这个计算量</p><p>为了了解计算机中的浮点数，我们先来看看十进制世界的我们是如何表示小数的</p><p>首先在整数部分，我们有个位，十位，百位，千位，同样在小数部分我们有1/10,1/100,1/1000等等：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-23-17.j7q4ml5ek5c.webp"                      alt="Snipaste_2022-01-07_15-23-17"                ></p><p>比如我们写上在个位写0，在小数部分的1/10上写1就可以精确表示0.1，但是计算机使用的是二进制，每一位只能是0或者1，并且逢二进一，因此整数位分别表示有多少个一，多少个二，多少个四多少个八，其实这对应着2的一次方，2的二次方，2的三次方等等，小数部分则表示1/2,1/4,1/8,1/16等等：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-29-55.5hw30ljq2pc0.webp"                      alt="Snipaste_2022-01-07_15-29-55"                ></p><p>在二进制中，我们可以轻易地表示1/2,1/4或者3/4没有任何问题，但是二进制中没有1/10,求出的答案与1十分接近但却不等于1:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-34-27.2vftqxmqm720.webp"                      alt="Snipaste_2022-01-07_15-34-27"                ></p><p>虽然计算机不总是能精确地表示小数，但在大多数情况下这并不是问题，比如在物理引擎中，我们会用到浮点数来计算物体的坐标，假设误差导致每一帧中物体的位置偏离0.00001，由于这个量实在太小，即便累加一秒，可能还不及一个像素点的长度，用户根本无法察觉，但是另一方面如果银行使用浮点数来表示货币，每存入0.1块钱，由于浮点误差的存在，导致账号中会多累加这么多钱:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-43-32.30x8voh3a4o0.webp"                      alt="Snipaste_2022-01-07_15-43-32"                ></p><p>在频繁的交易下，这种误差积少成多对银行来说就是巨大的损失</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-44-51.76dilr2t0c00.webp"                      alt="Snipaste_2022-01-07_15-44-51"                ></p><p>要解决这个问题，最容易想到的就是用整型来替代浮点数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_15-48-03.388qiargpu20.webp"                      alt="Snipaste_2022-01-07_15-48-03"                ></p><p>比如1块钱当作整型数100来存储，这样1分钱就可以准确无误地用数值1来表示，最后我们只需要在显示货币的时候除以一百即可：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_16-13-09.lomzvbjhtb4.webp"                      alt="Snipaste_2022-01-07_16-13-09"                ></p><p>另外现代的编程语言或者数据库中都提供一个特殊的数据类型decimal(十进制定点数),专门用来表示任意精度的十进制数：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_16-15-25.fip8e9p4pdc.webp"                      alt="Snipaste_2022-01-07_16-15-25"                ></p><p>用它来进行运算不会产生任何的精度问题</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_16-20-24.26roiloj8s5c.webp"                      alt="Snipaste_2022-01-07_16-20-24"                ></p><p>当然在大多数时候，我们依然会用到浮点数，因为浮点数能高效地进行运算，并且节省内存空间，只要我们心里有数，知道程序出现误差可能会导致出现逻辑错误，并且加以防范就好了，比如直接用等号去判断两个浮点数是否相等，这种用操作是很不可靠的，正确的做法应当是去计算这两个数的差别是否小于某个误差范围：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_16-27-52.1lv7vyc5fty8.webp"                      alt="Snipaste_2022-01-07_16-27-52"                ></p><p>在现代的编程语言中大多都内置了判断浮点数是否相等的工具函数，比如python中的isclose：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_16-29-56.2wyo5cb3gki0.webp"                      alt="Snipaste_2022-01-07_16-29-56"                ></p><p>使用他们可以规避很多由浮点误差而导致的程序逻辑错误：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_16-31-01.31h8gdlny0y0.webp"                      alt="Snipaste_2022-01-07_16-31-01"                ></p><p>浮点数的这些奇怪特性可能一开始让很多人摸不着头脑，但在了解之后发现他不过是一个基本的数学概念，科学计数法的二进制版本，仅此而已：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_16-33-16.2p49xq738jc0.webp"                      alt="Snipaste_2022-01-07_16-33-16"                ></p><p>由于0.1在二进制中是无限循环小数，计算机没有办法精确表示，从而丢失了精度，也就造就了为什么我们输入0.1+0.2但计算机返回的却不是0.3的情况：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_16-37-39.15r619y0x0sg.webp"                      alt="Snipaste_2022-01-07_16-37-39"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们印象中，计算机总是能高效准确地进行运算:&lt;br&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux系统启动过程</title>
    <link href="http://example.com/2022/01/07/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2022/01/07/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2022-01-07T01:19:30.000Z</published>
    <updated>2022-01-07T01:36:06.166Z</updated>
    
    <content type="html"><![CDATA[<p>按下系统的电源开关，过一会儿就可以看到Linux的登录界面，你是否想过，从按下电源开关到登录界面的出现，这后面到底发生了什么?</p><p>我们先来看看一个整体的流程图:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-21-28.5sqouvy7v7g0.webp"                      alt="Snipaste_2022-01-07_09-21-28"                ></p><p>Linux系统在启动过程中，首先是固件(PC上大多是CMOS/BIOS)的物理检测，诸如检测系统的显卡，CPU和硬盘等，可从系统按下电源键后看到此检测信息；检测没有问题后，将读取硬盘的MBR(主引导记录)中的自举程序，Linux中常用的自举程序如LILO和GRUB。自举程序GRUB在系统启动期间只有一个作用，就是启动内核，内核在引导期间有两个主要的作用，一个是驱动系统硬件，另一个是启动系统init，init进程将读取其配置文件/etc/initab完成后继续所有的引导。</p><p>整个过程基本可以分为六个步骤:BIOS–&gt;MBR(GRUB)–&gt;Kernel–&gt;Init–&gt;Runlevel:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-30-19.10of2bn2nfrk.webp"                      alt="Snipaste_2022-01-07_09-30-19"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-31-22.tv1ntom0xc0.webp"                      alt="Snipaste_2022-01-07_09-31-22"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-32-05.1kg0n3aym7s0.webp"                      alt="Snipaste_2022-01-07_09-32-05"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-32-47.7h1x4nh4sps0.webp"                      alt="Snipaste_2022-01-07_09-32-47"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-33-50.7ab7flt0yr40.webp"                      alt="Snipaste_2022-01-07_09-33-50"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-34-15.157a06qsnr4w.webp"                      alt="Snipaste_2022-01-07_09-34-15"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-35-46.7ub8ya0rze4.webp"                      alt="Snipaste_2022-01-07_09-35-46"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;按下系统的电源开关，过一会儿就可以看到Linux的登录界面，你是否想过，从按下电源开关到登录界面的出现，这后面到底发生了什么?&lt;/p&gt;
&lt;p&gt;我们先来看看一个整体的流程图:&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
      </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mac终端美化教程</title>
    <link href="http://example.com/2022/01/07/mac%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/01/07/mac%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/</id>
    <published>2022-01-07T01:08:30.000Z</published>
    <updated>2022-01-07T01:11:02.352Z</updated>
    
    <content type="html"><![CDATA[<p>mac终端美化请参考:<a class="link"   href="https://www.wolai.com/fishc/exwe9Srj8St6THjGE6YVyz" >https://www.wolai.com/fishc/exwe9Srj8St6THjGE6YVyz<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;mac终端美化请参考:&lt;a class=&quot;link&quot;   href=&quot;https://www.wolai.com/fishc/exwe9Srj8St6THjGE6YVyz&quot; &gt;https://www.wolai.com/fishc/exwe9Srj8St6THjGE6YVy</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10分钟彻底搞懂“动态规划”算法</title>
    <link href="http://example.com/2022/01/06/10%E5%88%86%E9%92%9F%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E2%80%9C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%9D%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/01/06/10%E5%88%86%E9%92%9F%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E2%80%9C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%9D%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-06T14:48:35.000Z</published>
    <updated>2022-01-07T06:38:24.257Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划是计算机中解决最优化问题的一种方法，它通常给我们的印象是效率高，速度快，但对于初学者来说，可能并不是那么容易理解，今天，我们抛开所有的数学公式，用实例给大家彻底讲懂动态规划算法。</p><p>首先我们来看一个经典的动态规划问题:</p><p>给你一个无序的数组，要求我们找出其中最长的递增的子序列:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_22-54-02.aqz9oufebo0.webp"                      alt="Snipaste_2022-01-06_22-54-02"                ></p><p>比如这里的1，2，4就是其中一个:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_22-55-38.6vj3uoidmbo0.webp"                      alt="Snipaste_2022-01-06_22-55-38"                ></p><p>1，2，3是另外一个答案:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_22-56-38.3s8er174pko0.webp"                      alt="Snipaste_2022-01-06_22-56-38"                ></p><p>这里我们再对这个问题做一些简化，我们要求这个算法只返回最长序列的”长度”就好了:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_22-58-07.5xu4n3s593o0.webp"                      alt="Snipaste_2022-01-06_22-58-07"                ></p><p>也就是3:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_22-59-30.3h6t8hadilc0.webp"                      alt="Snipaste_2022-01-06_22-59-30"                ></p><p>如果是你，你会怎么去求解这个问题呢？</p><p>其实最容易想到的办法是暴力枚举，或者叫暴力搜索；比如从1出发，下一个数字可以取5，2，4或者3，因为他们都是递增的:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-08-04.2yknz8xay5c0.webp"                      alt="Snipaste_2022-01-06_23-08-04"                ></p><p>假如我们第二个数字选5的话，再下一个数字就取不了了，因为剩下的2，4，3都比5小，不能构成一个递增序列:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-11-05.1nizitt9nbc0.webp"                      alt="Snipaste_2022-01-06_23-11-05"                ></p><p>那如果第二个数字选2的话，下一个数字可以是4，也可以是3，此时构成的递增序列长度为3:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-17-13.53bgtzf85u80.webp"                      alt="Snipaste_2022-01-06_23-17-13"                ></p><p>以此类推，如果第三个数字取4，下一个数字依然不能选，因为3比4小：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-18-44.334b9zirnag0.webp"                      alt="Snipaste_2022-01-06_23-18-44"                ></p><p>算法就这样一直循环往复地执行下去，直到我们把每个子序列都找了个遍：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-21-18.1aoayhtnv0o0.webp"                      alt="Snipaste_2022-01-06_23-21-18"                ></p><p>并且在遍历过程中，我们实时记录最长的子序列长度，最后可以知道，最长的子序列长度为3:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-24-06.1qamrhmrgcio.webp"                      alt="Snipaste_2022-01-06_23-24-06"                ></p><p>最后，我们按照同样的方法计算”从5出发”，”从2出发”，”从4出发”，”从3出发”的序列长度，选出最长的那个，算法结束：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-26-44.59pocn5asgs0.webp"                      alt="Snipaste_2022-01-06_23-26-44"                ></p><p>那么我们应该如何去实现这个算法呢？</p><p>我们可以定义一个函数L，这个函数会返回从数组第i个数字开始的最长子序列长度：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-28-43.2gu1109n9do0.webp"                      alt="Snipaste_2022-01-06_23-28-43"                ></p><p>然后我们检查i后面的所有数字，我们将索引记为j，只要这个数比当前数大(也就是说可以构成递增序列),我们就递归地调用函数自身，去计算从j开始的最长子序列长度:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-03-26.2ztd9w5f1d60.webp"                      alt="Snipaste_2022-01-07_10-03-26"                ></p><p>然后加1得到目前这个序列的总长度:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-04-43.5hi04glvyrs0.webp"                      alt="Snipaste_2022-01-07_10-04-43"                ></p><p>接着我们只需要遍历所有的j，然后选出最长的子序列长度返回即可:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-08-10.44dhoxp0v2g0.webp"                      alt="Snipaste_2022-01-07_10-08-10"                ></p><p>当然这个递归函数不能永无止境地调用下去，当i取到最后一个数字的时候，由于它后面已经没有其他数字与它构成子序列了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-11-04.6vuby5artm40.webp"                      alt="Snipaste_2022-01-07_10-11-04"                ></p><p>所以我们直接返回长度1:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-13-14.33isck7sr0y0.webp"                      alt="Snipaste_2022-01-07_10-13-14"                ></p><p>接下来我们只需要对数组中的每一个数i依次调用L函数，然后选出长度最长的那个返回即可：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-17-37.28hbi1yxvgkk.webp"                      alt="Snipaste_2022-01-07_10-17-37"                ></p><p>我们可以带入之前的数据进行测试:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-23-39.1po30y692ce8.webp"                      alt="Snipaste_2022-01-07_10-23-39"                ></p><p>可以看到这个算法成功返回了3:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-24-40.1aja6f2rd61s.webp"                      alt="Snipaste_2022-01-07_10-24-40"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-26-47.567n4occkr00.webp"                      alt="Snipaste_2022-01-07_10-26-47"                ></p><p>这个算法虽然能够帮我们算出答案，不过它最大的问题在于时间复杂度，假设数组的长度为n，那就一共存在2^n个子序列，而每一个子序列我们都需要去遍历一次(判断是否是递增序列)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-29-50.6oyhxexemsg0.webp"                      alt="Snipaste_2022-01-07_10-29-50"                ></p><p>很显然这是一个指数级别的算法，最慢的算法之一，如果我们用长度为100的数组做测试，可以看到程序运行了整整5秒才算出答案：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-43-11.3bx9ohe2xbq0.webp"                      alt="Snipaste_2022-01-07_10-43-11"                ></p><p>我这自己重写了一遍半分钟还没出结果：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-41-45.twmdko5ggz4.webp"                      alt="Snipaste_2022-01-07_10-41-45"                ></p><p>那有没有可能对算法进行一些优化呢，如果我们观察这个遍历树，会发现里面存在大量的重复计算：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-45-12.79jqgli36jo0.webp"                      alt="Snipaste_2022-01-07_10-45-12"                ></p><p>比如我们在遍历子序列1，2， 4的时候就已经计算过“从4开始的最大子序列的长度”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-07-56.4t0mkodkqlc.webp"                      alt="Snipaste_2022-01-07_11-07-56"                ></p><p>后面遍历1,4的时候又重复计算了一次</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-08-53.2su6qfxq1ww0.webp"                      alt="Snipaste_2022-01-07_11-08-53"                ></p><p>为了避免重复的计算，我们可以在第一次计算的时候将结果保存下来，之后遍历到相同的节点我们就不用再重复计算了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-13-56.1kfbttr1lccg.webp"                      alt="Snipaste_2022-01-07_11-13-56"                ></p><p>直接将之前的结果返回</p><p>这里我们可以用一个字典(哈希表)memo记录下“从i开始最长的子序列长度”也就是代码中的max_len，然后我们在函数的开头检查之前是否保存过这个答案，如果是，直接返回结果，否则再去计算答案：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-17-59.7cavz7n0nms0.webp"                      alt="Snipaste_2022-01-07_11-17-59"                ></p><p>可以看到经过修改的代码，只用了1毫秒就计算出了结果</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-19-10.8r03984lxkw.webp"                      alt="Snipaste_2022-01-07_11-19-10"                ></p><p>相比较之前的5秒是巨大的速度提升，动态规划正是通过避免重复节点的计算，来加速整个计算的过程，由于用到了字典(哈希表)来保存了计算的中间结果，因此我们也称之为“记忆化”搜索，这也是大家经常会说动态规划是“空间”换“时间”,当然也有人叫它“带备忘录”的递归或者叫递归树的“剪枝”，它们都是同一个意思，因为我们不需要对这些树子节点进行重复计算了：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-24-27.293klrn0sev4.webp"                      alt="Snipaste_2022-01-07_11-24-27"                ></p><p>有了递归的算法，我们还可以尝试将它改写成非递归，或者也叫迭代的形式，这样我们可以更加直观地去分析算法的时间复杂度，并且避免了递归时候的函数调用开销：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-27-25.dqw9jcvhfuo.webp"                      alt="Snipaste_2022-01-07_11-27-25"                ></p><p>从之前的算法我们知道，要计算出从“1”开始的最长子序列长度，我们需要依次检查它后面的所有数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-29-57.6haeksrc4l80.webp"                      alt="Snipaste_2022-01-07_11-29-57"                ></p><p>由于1可以和5，2，4，3构成递增序列，所以我们需要递归地计算从5,2,4,3开始的最长子序列长度，然后选出最长的那个，然后加1得到与第一个数构成的最长子序列长度：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-40-40.bvjoqqjium8.webp"                      alt="Snipaste_2022-01-07_11-40-40"                ></p><p>同样的，要计算从“5”出发的最长子序列，我们也需要先检查它后面的数：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-41-53.37n9rgkxuvi0.webp"                      alt="Snipaste_2022-01-07_11-41-53"                ></p><p>然后进行同样的计算</p><p>这里很显然，因为后面没有数可以与它构成递增序列，所以结果直接是1：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-43-22.6ei62hbkezs0.webp"                      alt="Snipaste_2022-01-07_11-43-22"                ></p><p>我们这样以此类推下去，直到最后一个数，由于从3出发的子序列之能是它自己，所以长度直接是1:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-45-50.380d7i5aex40.webp"                      alt="Snipaste_2022-01-07_11-45-50"                ></p><p>从这里的公式中可以发现，我们只要从后往前依次计算，就能把所有的答案给推算出来，大家是不是觉得很像数学归纳法：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-48-54.2qian9yzd440.webp"                      alt="Snipaste_2022-01-07_11-48-54"                ></p><p>最后我们根据列出的式子来实现这个迭代算法：<br>这里我们可以通过两个循环，外面的循环代表从下往上的依次计算：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-50-25.68ykybvgk5c0.webp"                      alt="Snipaste_2022-01-07_11-50-25"                ></p><p>里面的循环用于遍历括号中的这些数值:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-53-23.563eph2lxvc0.webp"                      alt="Snipaste_2022-01-07_11-53-23"                ></p><p>运算的结果我们可以存放在一个数组中，我们直接叫它L：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-52-30.19y42eppuzpc.webp"                      alt="Snipaste_2022-01-07_11-52-30"                ></p><p>接下来只要后面的数比当前数大(能构成递增序列)，我们就按同样的方法来计算这个L(i):<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-56-13.3uifhme2bxk0.webp"                      alt="Snipaste_2022-01-07_11-56-13"                ></p><p>最后我们返回L数组中最大的那个即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-57-24.49g1ko485ha0.webp"                      alt="Snipaste_2022-01-07_11-57-24"                ></p><p>这个该写的迭代算法同样可以帮我们计算出最终答案，并且由于这里只用了两个循环，每个循环最多执行n次，因此算法的时间复杂度是o(n^2)和之前的指数级别的算法是天壤之别</p><p>最后我们来总结下动态规划的一般思路：</p><ol><li>穷举法/暴力搜索</li><li>记忆化搜索/剪枝</li><li>改写成迭代形式</li></ol><p>首先，我们可以先简单粗暴地将所有答案穷举出来</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-22-51.4l3i0hy9xyg0.webp"                      alt="Snipaste_2022-01-07_14-22-51"                ></p><p>并画出递归树</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-23-40.4fj03dcx40w.webp"                      alt="Snipaste_2022-01-07_14-23-40"                ></p><p>尝试写一个递归函数来求解，如果发现遍历中存在大量的重复计算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-24-55.1pjr24yy59ls.webp"                      alt="Snipaste_2022-01-07_14-24-55"                ></p><p>我们可以尝试用哈希表将数据缓存下来</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-26-19.13sgxrh6buqo.webp"                      alt="Snipaste_2022-01-07_14-26-19"                ></p><p>之后遍历到相同的节点就直接查表，避免重复的计算</p><p>最后，我们可以将计算的过程表示出来，然后观察公式求解的顺序</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-30-14.2kvr6ufise60.webp"                      alt="Snipaste_2022-01-07_14-30-14"                ></p><p>并尝试将递归形式改写成更简洁高效的迭代形式:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-32-06.78cb8vh642k0.webp"                      alt="Snipaste_2022-01-07_14-32-06"                ></p><p>如果大家搞懂了之前的内容，不如我们来试试另一个经典的动态规划问题，给你一个数组，要求我们要找出其中连续子序列的最大和:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-36-02.3w8d3wi51z00.webp"                      alt="Snipaste_2022-01-07_14-36-02"                ></p><p>比如这里的[2, -1, 2, 6]和最大:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-36-49.6lb1qxlm9lc0.webp"                      alt="Snipaste_2022-01-07_14-36-49"                ></p><p>这个问题又如何求解呢</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;动态规划是计算机中解决最优化问题的一种方法，它通常给我们的印象是效率高，速度快，但对于初学者来说，可能并不是那么容易理解，今天，我们抛开所有的数学公式，用实例给大家彻底讲懂动态规划算法。&lt;/p&gt;
&lt;p&gt;首先我们来看一个经典的动态规划问题:&lt;/p&gt;
&lt;p&gt;给你一个无序的数组，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Puppeteer10分钟快速上手</title>
    <link href="http://example.com/2022/01/06/Puppeteer10%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>http://example.com/2022/01/06/Puppeteer10%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2022-01-06T08:28:30.000Z</published>
    <updated>2022-01-06T10:55:21.045Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫，它就像是一只在互联网删爬行的蜘蛛，会根据我们实现定义好的规制为我们抓取需要的信息，以Python为例，你可以使用urllib或者requests发起一个http请求，并使用beautifulsoup或者lxml来分析返回的html文档，从中提取你需要的信息:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-32-53.ll3dxkbon5c.webp"                      alt="Snipaste_2022-01-06_16-32-53"                ></p><p>当然你也可以使用Scrapy这种专门为爬虫设计的框架，帮你完成从数据抓取，解析，存储以及调试的所有流程，Scrapy这类框架的优点自然是功能全，速度快，灵活性高，扩展性强，但是由于现在大多数网站都是动态加载的，前端呈现的内容可能由极其复杂的JavaScript程序控制，遇到加密混淆的程序，可能自己还得去逆向分析很久，今天我为大家介绍另一种，基于puppeteer的爬虫思路， 虽然他的效率不是最高的，但一定能让你在最短的时间内快速实现一个爬虫，并帮你抓取到需要的信息</p><ol><li><p>首先来介绍下puppeteer</p><p>puppeteer是一款强大web自动化工具，相比较selenium，phantomjs这些老牌的框架，puppeteer绝对是后起之秀，如果你写了一个web应用，你需要对页面的功能进行测试，譬如检测某个按钮是否会唤醒对话框界面，puppeter就完全可以胜任这个任务，由于它可以对浏览器进行操控，获取页面数据，自然也可以用它来做爬虫，爬虫不过是它众多应用中的其中一种，其实对于任何自动化的操作，我们都可以用它来完成，谷歌官方的puppeteer是通过JavaScript调用的，但是它在Python，Ruby，Go上都有对应的移植版本，如果你使用Python，你可以下载一个叫做pyppeteer的包，其中所有的API都是一致的，除了少数语法的不同，这里以JavaScript作为演示：</p></li><li><p>JavaScript演示puppeteer</p><p>首先确保你计算机中安装了Node.js：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-59-36.15i3x7qnyjcw.webp"                      alt="Snipaste_2022-01-06_16-59-36"                ></p><p>然后创建一个目录来保存我们这个项目(也就是这里的web-scraping-node)：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-04-26.3ba14obuhzc0.webp"                      alt="Snipaste_2022-01-06_17-04-26"                ></p><p>然后使用npm init 初始化工程:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-09-51.19lpfmo9zrkw.webp"                      alt="Snipaste_2022-01-06_17-09-51"                ></p><p>最后使用命令npm i puppeteer:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-11-44.1caw222u7jr4.webp"                      alt="Snipaste_2022-01-06_17-11-44"                ></p><p>这过程会持续一段时间，取决于你的网速</p><p>接着我们在文档的入门指南中找到这样一段样例程序，我们直接将代码复制到编辑器中，在它的基础上做修改:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-19-06.15ycsr9yxgqo.webp"                      alt="Snipaste_2022-01-06_17-19-06"                ></p><p>这是修改前的代码:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-32-34.365szkzldym0.webp"                      alt="Snipaste_2022-01-06_17-32-34"                ></p><p>这10行代码非常简单:</p><p>这是创建一个浏览器对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br></pre></td></tr></table></figure><p>打开一个新页面:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br></pre></td></tr></table></figure><p>然后转到example.com</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.goto(<span class="string">&#x27;https://example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>保存一张截图后退出:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">&#x27;example.png&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p>如果你运行代码，在短暂的等待之后，程序会当前目录下保存一张截图文件:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-46-02.3pgyll8rvx40.webp"                      alt="Snipaste_2022-01-06_17-46-02"                ></p><p>这里我们稍做修改，首先在创建浏览器对象的时候传入一个新参数headless: false,因为puppeteer默认运行在无头(headless)模式下，也就是说浏览器窗口并不会显示出来，这里我们通过这个参数关闭无头模式，接着我们将网址改为百度，并且删除后面的screenshot()和borwser.close(),保存程序，运行程序，可以看到puppeteer成功打开了百度并显示在新创建的浏览器窗口中，需要注意的是，这里窗口边缘的空白是一个feature，并不是一个bug:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-58-33.6xoeg0pu0h80.webp"                      alt="Snipaste_2022-01-06_17-58-33"                ></p></li><li><p>用puppeteer写爬虫</p><p>将bilibili上的音乐的热门信息给提取出来</p><p>以下是实施的步骤:<br>我们打开浏览器的控制台，然后我们可以在这里输入任何JavaScript表达式来做测试，比如:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-10-05.508av10kcpc0.webp"                      alt="Snipaste_2022-01-06_18-10-05"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-10-44.2hli00kc8jk0.webp"                      alt="Snipaste_2022-01-06_18-10-44"                ></p><p>如果我们想要在页面中提取相似的元素，我们可以用到selector(选择器)或者xpath，选择器的语法更为简单些，这里我们以选择器为例，比如你想要的匹配页面中的所有链接，可以在控制台中输入$$(‘a’),如果你想要匹配所有li元素下的a标签则可以输入$$(‘li &gt; a’),这里我们想找出能匹配这个视频标题的选择器，其实chrome给我们提供了一个便利，我们可以在标题上点右键，选择下方的检查，选中的元素就会以高亮的形式显示在右边:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-19-28.3x23lxbfiau0.webp"                      alt="Snipaste_2022-01-06_18-19-28"                ></p><p>我们点击右键，选择这里的复制选择器：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-21-25.1g3gk847wwtc.webp"                      alt="Snipaste_2022-01-06_18-21-25"                ></p><p>接下来我们只需要稍作修改，比如删掉这里多余的部分，做一些简化:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-22-55.7ed889q968g0.webp"                      alt="Snipaste_2022-01-06_18-22-55"                ></p><p>就可以提取出所有的标题元素了：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-24-09.1rx7v1w0alog.webp"                      alt="Snipaste_2022-01-06_18-24-09"                ></p><p>然后我们可以遍历返回的每个元素，将标题文字给提取出来:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-28-30.4z12qiuvgac0.webp"                      alt="Snipaste_2022-01-06_18-28-30"                ></p><p>我们可以先记下这段选择器，待会儿我们就会用到，我们先将浏览器中的网址直接拷贝过来,接下来使用page对象的$$eval函数来获取所有的视频标题：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-32-56.owj42n0njnk.webp"                      alt="Snipaste_2022-01-06_18-32-56"                ></p><p>这里的第一个参数是选择器，就是我之前测试时用于提取标题的选择器，第二个参数要求你传入一个函数，这个函数会直接在网页的上下文中运行，筛选出你需要的数据并返回给puppeteer，这里我做的是遍历所有的a标签,并将其中的文本给提取出来，我们可以调用log函数将结果打印出来：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-37-55.5pupnewbfcg0.webp"                      alt="Snipaste_2022-01-06_18-37-55"                ></p><p>运行程序，我们可以看到这样的结果：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-38-57.7867h3djf1c0.webp"                      alt="Snipaste_2022-01-06_18-38-57"                ></p><p>这里为了让程序更健壮，我们可以在获取标题之前，先等待标题元素的出现，这样可以避免页面加载期，无法找到元素而报错的现象:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-41-27.18gudqzv34o0.webp"                      alt="Snipaste_2022-01-06_18-41-27"                ></p><p>后面的代码直接上，我们限定了数据的时间，然后以json的数据格式保存下来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&quot;puppeteer&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> data = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    <span class="attr">headless</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">userDataDir</span>: <span class="string">&quot;./data&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> mo = <span class="number">1</span>; mo &lt; <span class="number">12</span>; mo++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> pg = <span class="number">1</span>; pg &lt;= <span class="number">10</span>; pg++) &#123;</span><br><span class="line">      mo = mo.toString().padStart(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">      <span class="keyword">await</span> page.goto(</span><br><span class="line">        <span class="string">&quot;https://www.bilibili.com/v/music/cover/?spm_id_from=333.5.b_7375626e6176.3#&quot;</span> +</span><br><span class="line">          <span class="string">`/all/click/0/<span class="subst">$&#123;pg&#125;</span>/2020-<span class="subst">$&#123;mo&#125;</span>-01,2020-<span class="subst">$&#123;mo&#125;</span>-29`</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> page.waitForSelector(<span class="string">&quot;.vd-list-cnt &gt; ul &gt; li &gt; div &gt; div.r &gt; a&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> titles = <span class="keyword">await</span> page.$$eval(</span><br><span class="line">        <span class="string">&quot;.vd-list-cnt &gt; ul &gt; li &gt; div &gt; div.r &gt; a&quot;</span>,</span><br><span class="line">        <span class="function">(<span class="params">links</span>) =&gt;</span> links.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x.innerText)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(titles);</span><br><span class="line">      data = data.concat(titles);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs.writeFile(<span class="string">&quot;data.json&quot;</span>, <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="string">&quot;\t&quot;</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>最后我想提一个大家可能经常会遇到的问题</p><p>我们每次运行脚本的时候，puppteteer磨人都会为我们创建一个崭新的实例，也就是像网页的缓存、cookie都会在脚本退出之后自动销毁：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-48-16.2hvjk63hyf60.webp"                      alt="Snipaste_2022-01-06_18-48-16"                ></p><p>像网站的登录信息也不会被保存下来，而通常我们并不希望每次运行脚本都去登录一次，这里我们可以给launch指定另外一个参数，他会将浏览器的数据保存在这个指定的路径下，因此所有的浏览器实例都会共享这些数据：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-50-57.2uf3kn93xve0.webp"                      alt="Snipaste_2022-01-06_18-50-57"                ></p><p>登录信息也会被保存下来</p><p>其实用puppteteer来做爬虫确实是一种不错的选择，要知道现在大多数网站都是使用了前端的JavaScript程序来做渲染的，相比于http层的爬虫工具，puppteteer更像是一个模拟网页操作的机器人，他用起来直观很多，也帮我们省去了不少分析前端代码的时间，不过想scrapy还是很强大的，尤其是他的速度和性能</p><p>源码：<a class="link"   href="https://github.com/rossning92/web-scraping" >https://github.com/rossning92/web-scraping<i class="fas fa-external-link-alt"></i></a></p><p>Puppeteer 中文文档：<a class="link"   href="https://zhaoqize.github.io/puppeteer-api-zh_CN/" >https://zhaoqize.github.io/puppeteer-api-zh_CN/<i class="fas fa-external-link-alt"></i></a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;爬虫，它就像是一只在互联网删爬行的蜘蛛，会根据我们实现定义好的规制为我们抓取需要的信息，以Python为例，你可以使用urllib或者requests发起一个http请求，并使用beautifulsoup或者lxml来分析返回的html文档，从中提取你需要的信息:&lt;br&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
