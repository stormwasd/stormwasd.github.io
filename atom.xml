<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-15T14:19:41.345Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Goland编辑器配置GOROOT时报错The selected directory is not a valid home for Go SDK的解决方法</title>
    <link href="http://example.com/2022/01/15/Goland%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AEGOROOT%E6%97%B6%E6%8A%A5%E9%94%99The%20selected%20directory%20is%20not%20a%20valid%20home%20for%20Go%20SDK%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/01/15/Goland%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AEGOROOT%E6%97%B6%E6%8A%A5%E9%94%99The%20selected%20directory%20is%20not%20a%20valid%20home%20for%20Go%20SDK%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2022-01-15T14:20:28.509Z</published>
    <updated>2022-01-15T14:19:41.345Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统: win10</p><p>Go版本: 1.17.3</p><p>集成开发环境版本: GoLand 2019.3</p><p>GoLand指定Go版本报错: The selected directory is not a valid home for Go SDK</p><p>解决方法:</p><p>打开Go的安装目录，我这里的是: C:\Program Files\Go</p><p>然后进入这个文件: src\runtime\internal\sys\zversion.go</p><p>添加一条</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const TheVersion = `go1.17.3`</span><br></pre></td></tr></table></figure><p>然后即可添加，添加C:\Program Files\Go这个路径即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;操作系统: win10&lt;/p&gt;
&lt;p&gt;Go版本: 1.17.3&lt;/p&gt;
&lt;p&gt;集成开发环境版本: GoLand 2019.3&lt;/p&gt;
&lt;p&gt;GoLand指定Go版本报错: The selected directory is not a valid home for Go S</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js逆向百度翻译(小白练手案例)</title>
    <link href="http://example.com/2022/01/14/js%E9%80%86%E5%90%91%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91(%E5%B0%8F%E7%99%BD%E7%BB%83%E6%89%8B%E6%A1%88%E4%BE%8B)/"/>
    <id>http://example.com/2022/01/14/js%E9%80%86%E5%90%91%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91(%E5%B0%8F%E7%99%BD%E7%BB%83%E6%89%8B%E6%A1%88%E4%BE%8B)/</id>
    <published>2022-01-14T09:51:30.000Z</published>
    <updated>2022-01-15T09:59:08.141Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们打开<a class="link"   href="https://fanyi.baidu.com/" >百度翻译<i class="fas fa-external-link-alt"></i></a>然后按F12打开抓包工具，我们点击Fetch/XHR，然后我们随便输入一个中文，点击翻译，我们需要关注的是v2transapiform=zh&amp;to=en这个post请求</p><p>首先我们输入你好然后回车(或者点击翻译触发)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220114/Snipaste_2022-01-14_17-57-25.75uih5lkygg0.webp"                      alt="Snipaste_2022-01-14_17-57-25"                ></p><p>我们再翻译一个他们</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220114/Snipaste_2022-01-14_17-59-20.2ajraqbd1ajo.webp"                      alt="Snipaste_2022-01-14_17-59-20"                ></p><p>再翻译一个我们</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220114/Snipaste_2022-01-14_18-00-49.112slao8x7y8.webp"                      alt="Snipaste_2022-01-14_18-00-49"                ></p><p>这个过程中我们不难发现，formdata中变的就两个，一个是query，另一个是sign</p><p>现在我们知道了要构造请求的参数，以及变化且需要破解的参数，我们就可以着手去做了</p><p>我们先全局搜索下sign这个参数，我们发现搜索出来的东西很多，但是我定睛一看，发现有一个js文件中出现了很多的sign字样，其他的出现得比较少而且很多assign混在其中，这使我有想法去看看这个js文件(或者试试搜索/v2transapi，这个搜出来应该只有一个，而且可以很快定位表单数据)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220114/Snipaste_2022-01-14_18-13-14.14mi2mf1urb4.webp"                      alt="Snipaste_2022-01-14_18-13-14"                ></p><p>那么我是如何定位到这个js文件的呢，首先看下面这个红框，我会记住这个js文件的名字和路径然后点击工具栏中的source，根据刚刚的路径就能快速定位到这个js文件</p><p>定位到之后，这个js文件的排版是很乱的，我们可以点击左下角的花括号去做一次排版，使我们看得更舒服，然后我们同样在这个js文件中做一次搜索，CTRL+F，然后搜索sign，会发现一共有13个，我们一个一个筛选，最终发现了第10个是最符合我们预期的，因为它最完整，和前面的formdata都一一对上了</p><p>我们在这个sign所在的行打上一个断点</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220114/Snipaste_2022-01-14_18-19-45.54fn2luukw40.webp"                      alt="Snipaste_2022-01-14_18-19-45"                ></p><p>然后在网页中翻译一个词语，回车后会发现程序断在了刚刚打断点的前面，然后我们鼠标悬停在L(e)函数上，会出现一个悬浮框，然后我们点击悬浮框中的e(r)函数跳转进入e(r)函数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220114/Snipaste_2022-01-14_18-25-32.639vii0gnec0.webp"                      alt="Snipaste_2022-01-14_18-25-32"                ></p><p>跳转进e(r)函数是这样的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220114/Snipaste_2022-01-14_18-27-16.773t1gfdjbk0.webp"                      alt="Snipaste_2022-01-14_18-27-16"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220115/Snipaste_2022-01-15_14-57-10.71lax0bd91c0.webp"                      alt="Snipaste_2022-01-15_14-57-10"                ></p><p>这里我们发现e(r)中牵扯到了其他两个函数，一个是a(r)，另一个是n(r, o)，所以这两个三个函数都要扣出来，然后我们发现还有一个未知的是window[1]</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220115/Snipaste_2022-01-15_15-14-47.66u2pvh2u500.webp"                      alt="Snipaste_2022-01-15_15-14-47"                ></p><p>这里有一句关键的代码我们来分析下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = <span class="literal">null</span> !== i ? i : (i = <span class="built_in">window</span>[l] || <span class="string">&quot;&quot;</span>) || <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 这是一个js中的三元表达式，而我们看到下面定义了var i = null;所以null !== i 为假所以u的值为(i = window[l] || &quot;&quot;)，u的值也就是window[1]</span></span><br></pre></td></tr></table></figure><p>我们经过多次调试发现这个u是一个确定的值，u=320305.131321201，我们可以直接用一个变量代替</p><p>下面就是我们抠出来的js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">jsCode = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    function a(r) &#123;</span></span><br><span class="line"><span class="string">        if (Array.isArray(r)) &#123;</span></span><br><span class="line"><span class="string">            for (var o = 0, t = Array(r.length); o &lt; r.length; o++)</span></span><br><span class="line"><span class="string">                t[o] = r[o];</span></span><br><span class="line"><span class="string">            return t</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return Array.from(r)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    function n(r, o) &#123;</span></span><br><span class="line"><span class="string">        for (var t = 0; t &lt; o.length - 2; t += 3) &#123;</span></span><br><span class="line"><span class="string">            var a = o.charAt(t + 2);</span></span><br><span class="line"><span class="string">            a = a &gt;= &quot;</span>a<span class="string">&quot; ? a.charCodeAt(0) - 87 : Number(a),</span></span><br><span class="line"><span class="string">            a = &quot;</span>+<span class="string">&quot; === o.charAt(t + 1) ? r &gt;&gt;&gt; a : r &lt;&lt; a,</span></span><br><span class="line"><span class="string">            r = &quot;</span>+<span class="string">&quot; === o.charAt(t) ? r + a &amp; 4294967295 : r ^ a</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return r</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var i = null;</span></span><br><span class="line"><span class="string">    function e(r) &#123;</span></span><br><span class="line"><span class="string">        var t = r.length;</span></span><br><span class="line"><span class="string">        t &gt; 30 &amp;&amp; (r = &quot;</span><span class="string">&quot; + r.substr(0, 10) + r.substr(Math.floor(t / 2) - 5, 10) + r.substr(-10, 10))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var u = void 0, l = &quot;</span><span class="string">&quot; + String.fromCharCode(103) + String.fromCharCode(116) + String.fromCharCode(107);</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        u = null !== i ? i : (i = &#x27;320305.131321201&#x27; || &quot;</span><span class="string">&quot;) || &quot;</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">        for (var d = u.split(&quot;</span>.<span class="string">&quot;), m = Number(d[0]) || 0, s = Number(d[1]) || 0, S = [], c = 0, v = 0; v &lt; r.length; v++) &#123;</span></span><br><span class="line"><span class="string">            var A = r.charCodeAt(v);</span></span><br><span class="line"><span class="string">            128 &gt; A ? S[c++] = A : (2048 &gt; A ? S[c++] = A &gt;&gt; 6 | 192 : (55296 === (64512 &amp; A) &amp;&amp; v + 1 &lt; r.length &amp;&amp; 56320 === (64512 &amp; r.charCodeAt(v + 1)) ? (A = 65536 + ((1023 &amp; A) &lt;&lt; 10) + (1023 &amp; r.charCodeAt(++v)),</span></span><br><span class="line"><span class="string">            S[c++] = A &gt;&gt; 18 | 240,</span></span><br><span class="line"><span class="string">            S[c++] = A &gt;&gt; 12 &amp; 63 | 128) : S[c++] = A &gt;&gt; 12 | 224,</span></span><br><span class="line"><span class="string">            S[c++] = A &gt;&gt; 6 &amp; 63 | 128),</span></span><br><span class="line"><span class="string">            S[c++] = 63 &amp; A | 128)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        for (var p = m, F = &quot;</span><span class="string">&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(97) + (&quot;</span><span class="string">&quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(54)), D = &quot;</span><span class="string">&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(51) + (&quot;</span><span class="string">&quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(98)) + (&quot;</span><span class="string">&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(102)), b = 0; b &lt; S.length; b++)</span></span><br><span class="line"><span class="string">            p += S[b],</span></span><br><span class="line"><span class="string">            p = n(p, F);</span></span><br><span class="line"><span class="string">        return p = n(p, D),</span></span><br><span class="line"><span class="string">        p ^= s,</span></span><br><span class="line"><span class="string">        0 &gt; p &amp;&amp; (p = (2147483647 &amp; p) + 2147483648),</span></span><br><span class="line"><span class="string">        p %= 1e6,</span></span><br><span class="line"><span class="string">        p.toString() + &quot;</span>.<span class="string">&quot; + (p ^ m)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line">query = <span class="string">&#x27;汉语中文&#x27;</span></span><br><span class="line">sign = execjs.compile(jsCode).call(<span class="string">&quot;e&quot;</span>, query)</span><br><span class="line">print(sign)</span><br></pre></td></tr></table></figure><p>执行结果如下</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220115/Snipaste_2022-01-15_15-45-22.1whcvuiqyf5s.webp"                      alt="Snipaste_2022-01-15_15-45-22"                ></p><p>接下就简单了，构造一个post请求然后解析json数据，拿到翻译结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> test_baidu_jscode <span class="keyword">import</span> get_word_sign</span><br><span class="line"><span class="keyword">import</span> jsonpath</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://fanyi.baidu.com/v2transapi?from=zh&amp;to=en&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua&#x27;</span>: <span class="string">&#x27;&quot; Not;A Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;97&quot;, &quot;Chromium&quot;;v=&quot;97&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>: <span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;Chrome/97.0.4692.71 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-platform&#x27;</span>: <span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;https://fanyi.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://fanyi.baidu.com/?aldtype=16047&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;BIDUPSID=CF86A0FA51038D0CA02DA9FC43B164F5; PSTM=1639146064; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;BAIDUID=CF86A0FA51038D0CFFCCCD08415508DA:FG=1; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;__yjs_duid=1_689d947b2f957f0b0d895ae63c66114f1639229602485; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;BAIDUID_BFESS=3A9FDFF925D6EA302A897713757BE825:FG=1; BDRCVFR[iqrboYocJ-C]=kRxlD0AvOmRPjIMTz4WUvY; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;BDRCVFR[fq555l35Iot]=EBD6F1bEM2tXZKdrHn8mvqV; delPer=0; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;BDRCVFR[3lgytkvnri6]=mk3SLVN4HKm; H_PS_PSSID=; REALTIME_TRANS_SWITCH=1; FANYI_WORD_SWITCH=1; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;HISTORY_SWITCH=1; SOUND_PREFER_SWITCH=1; SOUND_SPD_SWITCH=1; APPGUIDE_10_0_2=1; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1642227471,1642227478; PSINO=6; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;BA_HECTOR=2hag052ha52h010lkt1gu4ujh0r; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1642233008; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;ab_sr=1.0&#x27;</span></span><br><span class="line">              <span class="string">&#x27;.1_NjI2ZDk1Y2JmYzQ2ZTBiNTZmNWIyZjllNTU4ZjE4MmM1ZTI2ZmVjMjAyNmJhN2E5NGJhNWVjYmM2OWFmMTRjOTE0ZDQ2M2Y5MmY5N2RmNDUzNzYwNGJjZmZlYmVhZjZjMjgzYWI5YjhhZDJlNzg0NTNiZjRmNjhmMzU5ZDIxNzhkNzhiNDlmYTQyODhhMmZmOGM3MmM2NzhhMTlhZDU2NQ==; __yjs_st=2_NTA2ZGI3NzkyZGNmMzE4M2JkNzk0MTNkMWRmMzBkZmQwNjBlOTYzMDRhZjZmOTJhZGYzOGFjZWRlMTE1NjU4ZTA5ZDljMGQyMjA3Nzk0OWE3NmZhNThjY2YzYTBmMjVhMzAxYmQyZmFkM2VhMTc0YjE5MmJlM2VmZGZlMjhiMzkxMTQzMWY4NGYyNzZkNjM1YjE2ZjNhYjA4M2ViZmNmZDU2YWQzMzc0N2YzMGFiZGVhZTY5NzRiMjc0MzdlMjdjYTM2MGU2OGJmYTJhM2VhZWJiNzIxYWEyODc1ODZlZTBlOGYwOTM1ZWNkMjE4YzM0ZDFiMTY1YjgwMDNmZjhjZV83X2NjZDQ3NTdj &#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_word_means</span>():</span></span><br><span class="line">    query = <span class="built_in">input</span>(<span class="string">&#x27;Please input you query words:&#x27;</span>)</span><br><span class="line">    sign = get_word_sign(query)</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&quot;from&quot;</span>: <span class="string">&quot;zh&quot;</span>,</span><br><span class="line">        <span class="string">&quot;to&quot;</span>: <span class="string">&quot;en&quot;</span>,</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: query,</span><br><span class="line">        <span class="string">&quot;transtype&quot;</span>: <span class="string">&quot;translang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;simple_means_flag&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sign&quot;</span>: sign,</span><br><span class="line">        <span class="string">&quot;token&quot;</span>: <span class="string">&quot;cb25a0d7b1d3837fe7864c5c87559d98&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, headers=headers, data=data)</span><br><span class="line">    json_result = response.json()</span><br><span class="line">    result = jsonpath.jsonpath(json_result, <span class="string">&quot;$..word_means&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_word_means()</span><br></pre></td></tr></table></figure><p>下面附上完整代码:</p><p>js_reverse_baidufanyi:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line">jsCode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    function a(r) &#123;</span></span><br><span class="line"><span class="string">        if (Array.isArray(r)) &#123;</span></span><br><span class="line"><span class="string">            for (var o = 0, t = Array(r.length); o &lt; r.length; o++)</span></span><br><span class="line"><span class="string">                t[o] = r[o];</span></span><br><span class="line"><span class="string">            return t</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return Array.from(r)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    function n(r, o) &#123;</span></span><br><span class="line"><span class="string">        for (var t = 0; t &lt; o.length - 2; t += 3) &#123;</span></span><br><span class="line"><span class="string">            var a = o.charAt(t + 2);</span></span><br><span class="line"><span class="string">            a = a &gt;= &quot;a&quot; ? a.charCodeAt(0) - 87 : Number(a),</span></span><br><span class="line"><span class="string">            a = &quot;+&quot; === o.charAt(t + 1) ? r &gt;&gt;&gt; a : r &lt;&lt; a,</span></span><br><span class="line"><span class="string">            r = &quot;+&quot; === o.charAt(t) ? r + a &amp; 4294967295 : r ^ a</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return r</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    var i = null;</span></span><br><span class="line"><span class="string">    function e(r) &#123;</span></span><br><span class="line"><span class="string">        var t = r.length;</span></span><br><span class="line"><span class="string">        t &gt; 30 &amp;&amp; (r = &quot;&quot; + r.substr(0, 10) + r.substr(Math.floor(t / 2) - 5, 10) + r.substr(-10, 10))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        var u = void 0, l = &quot;&quot; + String.fromCharCode(103) + String.fromCharCode(116) + String.fromCharCode(107);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        u = null !== i ? i : (i = &#x27;320305.131321201&#x27; || &quot;&quot;) || &quot;&quot;;</span></span><br><span class="line"><span class="string">        for (var d = u.split(&quot;.&quot;), m = Number(d[0]) || 0, s = Number(d[1]) || 0, S = [], c = 0, v = 0; v &lt; r.length; v++) &#123;</span></span><br><span class="line"><span class="string">            var A = r.charCodeAt(v);</span></span><br><span class="line"><span class="string">            128 &gt; A ? S[c++] = A : (2048 &gt; A ? S[c++] = A &gt;&gt; 6 | 192 : (55296 === (64512 &amp; A) &amp;&amp; v + 1 &lt; r.length &amp;&amp; 56320 === (64512 &amp; r.charCodeAt(v + 1)) ? (A = 65536 + ((1023 &amp; A) &lt;&lt; 10) + (1023 &amp; r.charCodeAt(++v)),</span></span><br><span class="line"><span class="string">            S[c++] = A &gt;&gt; 18 | 240,</span></span><br><span class="line"><span class="string">            S[c++] = A &gt;&gt; 12 &amp; 63 | 128) : S[c++] = A &gt;&gt; 12 | 224,</span></span><br><span class="line"><span class="string">            S[c++] = A &gt;&gt; 6 &amp; 63 | 128),</span></span><br><span class="line"><span class="string">            S[c++] = 63 &amp; A | 128)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        for (var p = m, F = &quot;&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(97) + (&quot;&quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(54)), D = &quot;&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(51) + (&quot;&quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(98)) + (&quot;&quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(102)), b = 0; b &lt; S.length; b++)</span></span><br><span class="line"><span class="string">            p += S[b],</span></span><br><span class="line"><span class="string">            p = n(p, F);</span></span><br><span class="line"><span class="string">        return p = n(p, D),</span></span><br><span class="line"><span class="string">        p ^= s,</span></span><br><span class="line"><span class="string">        0 &gt; p &amp;&amp; (p = (2147483647 &amp; p) + 2147483648),</span></span><br><span class="line"><span class="string">        p %= 1e6,</span></span><br><span class="line"><span class="string">        p.toString() + &quot;.&quot; + (p ^ m)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_word_sign</span>(<span class="params">query</span>):</span></span><br><span class="line">    sign = execjs.<span class="built_in">compile</span>(jsCode).call(<span class="string">&quot;e&quot;</span>, query)</span><br><span class="line">    <span class="keyword">return</span> sign</span><br></pre></td></tr></table></figure><p>test_baidu_jscode:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> test_baidu_jscode <span class="keyword">import</span> get_word_sign</span><br><span class="line"><span class="keyword">import</span> jsonpath</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://fanyi.baidu.com/v2transapi?from=zh&amp;to=en&quot;</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua&#x27;</span>: <span class="string">&#x27;&quot; Not;A Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;97&quot;, &quot;Chromium&quot;;v=&quot;97&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;*/*&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-mobile&#x27;</span>: <span class="string">&#x27;?0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &#x27;</span></span><br><span class="line">                  <span class="string">&#x27;Chrome/97.0.4692.71 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;sec-ch-ua-platform&#x27;</span>: <span class="string">&#x27;&quot;Windows&quot;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;https://fanyi.baidu.com&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;empty&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://fanyi.baidu.com/?aldtype=16047&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;BIDUPSID=CF86A0FA51038D0CA02DA9FC43B164F5; PSTM=1639146064; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;BAIDUID=CF86A0FA51038D0CFFCCCD08415508DA:FG=1; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;__yjs_duid=1_689d947b2f957f0b0d895ae63c66114f1639229602485; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;BAIDUID_BFESS=3A9FDFF925D6EA302A897713757BE825:FG=1; BDRCVFR[iqrboYocJ-C]=kRxlD0AvOmRPjIMTz4WUvY; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;BDRCVFR[fq555l35Iot]=EBD6F1bEM2tXZKdrHn8mvqV; delPer=0; BDORZ=FFFB88E999055A3F8A630C64834BD6D0; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;BDRCVFR[3lgytkvnri6]=mk3SLVN4HKm; H_PS_PSSID=; REALTIME_TRANS_SWITCH=1; FANYI_WORD_SWITCH=1; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;HISTORY_SWITCH=1; SOUND_PREFER_SWITCH=1; SOUND_SPD_SWITCH=1; APPGUIDE_10_0_2=1; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;Hm_lvt_64ecd82404c51e03dc91cb9e8c025574=1642227471,1642227478; PSINO=6; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;BA_HECTOR=2hag052ha52h010lkt1gu4ujh0r; Hm_lpvt_64ecd82404c51e03dc91cb9e8c025574=1642233008; &#x27;</span></span><br><span class="line">              <span class="string">&#x27;ab_sr=1.0&#x27;</span></span><br><span class="line">              <span class="string">&#x27;.1_NjI2ZDk1Y2JmYzQ2ZTBiNTZmNWIyZjllNTU4ZjE4MmM1ZTI2ZmVjMjAyNmJhN2E5NGJhNWVjYmM2OWFmMTRjOTE0ZDQ2M2Y5MmY5N2RmNDUzNzYwNGJjZmZlYmVhZjZjMjgzYWI5YjhhZDJlNzg0NTNiZjRmNjhmMzU5ZDIxNzhkNzhiNDlmYTQyODhhMmZmOGM3MmM2NzhhMTlhZDU2NQ==; __yjs_st=2_NTA2ZGI3NzkyZGNmMzE4M2JkNzk0MTNkMWRmMzBkZmQwNjBlOTYzMDRhZjZmOTJhZGYzOGFjZWRlMTE1NjU4ZTA5ZDljMGQyMjA3Nzk0OWE3NmZhNThjY2YzYTBmMjVhMzAxYmQyZmFkM2VhMTc0YjE5MmJlM2VmZGZlMjhiMzkxMTQzMWY4NGYyNzZkNjM1YjE2ZjNhYjA4M2ViZmNmZDU2YWQzMzc0N2YzMGFiZGVhZTY5NzRiMjc0MzdlMjdjYTM2MGU2OGJmYTJhM2VhZWJiNzIxYWEyODc1ODZlZTBlOGYwOTM1ZWNkMjE4YzM0ZDFiMTY1YjgwMDNmZjhjZV83X2NjZDQ3NTdj &#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_word_means</span>():</span></span><br><span class="line">    query = <span class="built_in">input</span>(<span class="string">&#x27;Please input you query words:&#x27;</span>)</span><br><span class="line">    sign = get_word_sign(query)</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&quot;from&quot;</span>: <span class="string">&quot;zh&quot;</span>,</span><br><span class="line">        <span class="string">&quot;to&quot;</span>: <span class="string">&quot;en&quot;</span>,</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: query,</span><br><span class="line">        <span class="string">&quot;transtype&quot;</span>: <span class="string">&quot;translang&quot;</span>,</span><br><span class="line">        <span class="string">&quot;simple_means_flag&quot;</span>: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;sign&quot;</span>: sign,</span><br><span class="line">        <span class="string">&quot;token&quot;</span>: <span class="string">&quot;cb25a0d7b1d3837fe7864c5c87559d98&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.request(<span class="string">&quot;POST&quot;</span>, url, headers=headers, data=data)</span><br><span class="line">    json_result = response.json()</span><br><span class="line">    result = jsonpath.jsonpath(json_result, <span class="string">&quot;$..word_means&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_word_means()</span><br></pre></td></tr></table></figure><p>运行效果:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220115/Snipaste_2022-01-15_17-53-39.2t4fdto41e00.webp"                      alt="Snipaste_2022-01-15_17-53-39"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先我们打开&lt;a class=&quot;link&quot;   href=&quot;https://fanyi.baidu.com/&quot; &gt;百度翻译&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;然后按F12打开抓包工具，我们点击Fetch/XHR，然后我们随</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解Python asyncio原理和简洁使用方式</title>
    <link href="http://example.com/2022/01/14/%E7%90%86%E8%A7%A3Python%20asyncio%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E6%B4%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2022/01/14/%E7%90%86%E8%A7%A3Python%20asyncio%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E6%B4%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2022-01-14T07:08:30.000Z</published>
    <updated>2022-01-14T09:20:00.256Z</updated>
    
    <content type="html"><![CDATA[<p>异步IO是个好东西，在网络读写场景中可以大大提高程序的并发能力，比如爬虫、web服务等；这样好的东西自然也要用到Python中，不过，在漫长的Python2时代，官方并没有推出一个自己的异步IO库，到了Python3.4才推出；我们先来看看异步IO在Python中的发展历史</p><p><strong>Python2的异步IO库</strong></p><p>Python2时代官方并没有异步IO的支持，但是有几个第三方库通过事件或者事件循环(Event Loop)实现了异步IO，它们是:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220114/Snipaste_2022-01-14_15-14-33.4lfwna8nmx60.webp"                      alt="Snipaste_2022-01-14_15-14-33"                ></p><p><strong>Python3官方的异步IO库</strong></p><p>Python 3.4 加入了asyncio 库，使得Python有了支持异步IO的官方库。这个库，底层是事件循环(EventLoop)，上层是协程和任务。asyncio自从3.4 版本加入到最新的 3.7版一直在改进中，Python 3.4 刚开始的asyncio的协程还是基于生成器的，通过 yield from 语法实现，可以通过装饰器 @asyncio.coroutine (已过时)装饰一个函数来定义一个协程</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220114/Snipaste_2022-01-14_15-21-07.5q7wn2pm54s0.webp"                      alt="Snipaste_2022-01-14_15-21-07"                ></p><p>Python 3.5 引入了两个新的关键字 await 和 async 用来替换 @asyncio.coroutine 和 yield from ，从语言本身来支持异步IO。从而使得异步编程更加简洁，并和普通的生成器区别开来.</p><p>注意： 对基于生成器的协程的支持已弃用，并计划在 Python 3.10 中移除。所以，写异步IO程序时只需使用 async 和 await 即可</p><p>Python 3.7 又进行了优化，把API分组为高层级API和低层级API。我们先看看下面的代码，发现与上面的有什么不同？</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220114/Snipaste_2022-01-14_15-22-28.78a59h5g84w0.webp"                      alt="Snipaste_2022-01-14_15-22-28"                ></p><p>除了用 async 替换 @asyncio.coroutine 和用 await 替换 yield from 外，最大的变化就是关于eventloop的代码不见了，只有一个 async.run()。这就是 3.7 的改进，把eventloop相关的API归入到低层级API，新引进run()作为高层级API让写应用程序的开发者调用，而不用再关心eventloop。除非你要写异步库（比如MySQL异步库）才会和eventloop打交道</p><p><strong>理解asyncio</strong></p><p>理解asyncio并不难，关键是要动起手来，接下来我们以下面代码为例动手实践一番，通过实践来理解它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">msg, sec</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;enter hi(), &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"><span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;exit hi() &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"><span class="keyword">return</span> sec</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main() begin at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line"><span class="keyword">await</span> hi(i, i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main() end at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这段代码很简单，我们定义了两个协程函数(在def前面加上async)，其中hi()我们把它叫做功能函数，通过一个asyncio.sleep()来模拟一个耗时的异步IO操作，(比如下载网页)，main函数叫做入口函数，其实就是在main()里面调用hi()函数，通过不断改变main()的行为来理解异步IO()来理解异步IO(协程函数的调用)的运行过程</p><p><strong>1. 协程函数如何运行？</strong></p><p>首先我们要明确一个道理，hi()是一个协程函数，直接调用它返回的是一个协程对象，并没有真正运行它，把main函数改成如下，我们来仔细看看协程函数hi()的运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">msg, sec</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;enter hi(), &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"><span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;exit hi() &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"><span class="keyword">return</span> sec</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main() begin at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">a = hi(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a is:&#x27;</span>, a)</span><br><span class="line">b = <span class="keyword">await</span> a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b is:&#x27;</span>, b)</span><br><span class="line"><span class="comment"># for i in range(1, 5):</span></span><br><span class="line"><span class="comment"># await hi(i, i)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main() end at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>下面是运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main() begin at <span class="number">15</span>:<span class="number">56</span>:<span class="number">58</span></span><br><span class="line">a <span class="keyword">is</span>: &lt;coroutine <span class="built_in">object</span> hi at <span class="number">0x0000000002D6A9C8</span>&gt;</span><br><span class="line">enter hi(), a @<span class="number">15</span>:<span class="number">56</span>:<span class="number">58</span></span><br><span class="line">exit hi() a @<span class="number">15</span>:<span class="number">56</span>:<span class="number">59</span></span><br><span class="line">b <span class="keyword">is</span>: <span class="number">1</span></span><br><span class="line">main() end at <span class="number">15</span>:<span class="number">56</span>:<span class="number">59</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>代码12行，我们像运行普通函数一样运行hi()，得到的a只是一个协程对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">is</span>: &lt;coroutine <span class="built_in">object</span> hi at <span class="number">0x0000000002D6A9C8</span>&gt;</span><br></pre></td></tr></table></figure><p>这个协程对象a虽然生成了，但是还没有运行，它需要一个时机，也就是asyncio的时间循环正在运行main函数，还没有空去运行它，代码第14行，通过await关键字告诉event_loop(时间循环)，main协程停在这里，你去运行其他协程叭，这时候envent_loop就去执行a协程，也就是去执行hi()函数里面的代码，等hi()运行完，event_loop再回到main协程继续从14行开始执行，把hi()的返回值赋值给b，这个时候b的值是1</p><p><strong>enve_loop在整个异步IO的过程中扮演着一个管家的角色，在不同的协程之间切换运行代码，切换是通过事件来进行的，通过await离开当前协程，当await的协程完成后又回到之前的协程对应的地方继续执行</strong></p><p><strong>2. 协程函数如何并发</strong></p><p>异步IO的好处就是并发，但如何实现呢?我们先来看一个不是并发的栗子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">msg, sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;enter hi(), &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;exit hi() &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">return</span> sec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main() begin at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        b = <span class="keyword">await</span> hi(i, i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;b is:&quot;</span>, b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main() end at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这次，我们把main修改成一个for循环执行4次，看看它运行的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main() begin at <span class="number">16</span>:<span class="number">20</span>:<span class="number">22</span></span><br><span class="line">enter hi(), <span class="number">1</span> @<span class="number">16</span>:<span class="number">20</span>:<span class="number">22</span></span><br><span class="line">exit hi() <span class="number">1</span> @<span class="number">16</span>:<span class="number">20</span>:<span class="number">23</span></span><br><span class="line">b <span class="keyword">is</span>: <span class="number">1</span></span><br><span class="line">enter hi(), <span class="number">2</span> @<span class="number">16</span>:<span class="number">20</span>:<span class="number">23</span></span><br><span class="line">exit hi() <span class="number">2</span> @<span class="number">16</span>:<span class="number">20</span>:<span class="number">25</span></span><br><span class="line">b <span class="keyword">is</span>: <span class="number">2</span></span><br><span class="line">enter hi(), <span class="number">3</span> @<span class="number">16</span>:<span class="number">20</span>:<span class="number">25</span></span><br><span class="line">exit hi() <span class="number">3</span> @<span class="number">16</span>:<span class="number">20</span>:<span class="number">28</span></span><br><span class="line">b <span class="keyword">is</span>: <span class="number">3</span></span><br><span class="line">enter hi(), <span class="number">4</span> @<span class="number">16</span>:<span class="number">20</span>:<span class="number">28</span></span><br><span class="line">exit hi() <span class="number">4</span> @<span class="number">16</span>:<span class="number">20</span>:<span class="number">32</span></span><br><span class="line">b <span class="keyword">is</span>: <span class="number">4</span></span><br><span class="line">main() end at <span class="number">16</span>:<span class="number">20</span>:<span class="number">32</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>整个过程从16:20:22到16:20:32结束，用了10秒，而hi()的执行时间分别是1秒，2秒，3秒，4秒总共10秒，也就是4个hi()虽然是异步的，但是是顺序执行的，没有并发</p><p>接下来，就到了真正并发实现了，通过asyncio.creat_task()即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">msg, sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;enter hi(), &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;exit hi() &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">return</span> sec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main() begin at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    tasks = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        t = asyncio.create_task(hi(i, i))</span><br><span class="line">        tasks.append(t)</span><br><span class="line">        <span class="comment"># b = await hi(i, i)</span></span><br><span class="line">        <span class="comment"># print(&quot;b is:&quot;, b)</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> tasks:</span><br><span class="line">        b = <span class="keyword">await</span> t</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;b is:&quot;</span>, b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main() end at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>通过create_task()我们在for循环里面生成了4个task(也就是协程对象)，但是这4个协程任务并没有被执行，他们需要等待一个时机:当前携程(main)遇到await</p><p>第二个for循环开始逐一await协程，此时event_loop就可以空出手来去执行那4个协程，过程大致如下:</p><p>先执行hi(1, 1) ，打印“enter hi(), 1 @16:30:18”，遇到await asyncio.sleep(1)，当前协程挂起；</p><p>接着执行 hi(2, 2)，执行打印命令，遇到await asyncio.sleep(2) ，当前协程挂起；</p><p>接着执行 hi(3, 3)，执行打印命令，遇到await asyncio.sleep(3) ，当前协程挂起；</p><p>接着执行 hi(4, 4)，执行打印命令，遇到await asyncio.sleep(4) ，当前协程挂起；</p><p>以上4步只是协程的切换和打印语句，执行非常快，我们可以任务它们是同时执行起来的。</p><p>1秒后，hi(1,1)的sleep结束它会发出事件告诉 event_loop 我await结束了，过来执行我，event_loop 此时空闲就来执行它，继续执行sleep后面的打印语句；</p><p>2秒后，hi(2,2)的sleep结束它会发出事件告诉 event_loop 我await结束了，过来执行我，event_loop 此时空闲就来执行它，继续执行sleep后面的打印语句；</p><p>3秒后，hi(3,3)的sleep结束它会发出事件告诉 event_loop 我await结束了，过来执行我，event_loop 此时空闲就来执行它，继续执行sleep后面的打印语句；</p><p>4秒后，hi(4,4)的sleep结束它会发出事件告诉 event_loop 我await结束了，过来执行我，event_loop 此时空闲就来执行它，继续执行sleep后面的打印语句；</p><p>4秒后，生成的4个协程任务就都执行完毕。总耗时4秒，也就是我们的4个任务并发完成了。</p><p>上面代码的运行结果为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">main() begin at <span class="number">16</span>:<span class="number">30</span>:<span class="number">17</span></span><br><span class="line">enter hi(), <span class="number">1</span> @<span class="number">16</span>:<span class="number">30</span>:<span class="number">17</span></span><br><span class="line">enter hi(), <span class="number">2</span> @<span class="number">16</span>:<span class="number">30</span>:<span class="number">17</span></span><br><span class="line">enter hi(), <span class="number">3</span> @<span class="number">16</span>:<span class="number">30</span>:<span class="number">17</span></span><br><span class="line">enter hi(), <span class="number">4</span> @<span class="number">16</span>:<span class="number">30</span>:<span class="number">17</span></span><br><span class="line">exit hi() <span class="number">1</span> @<span class="number">16</span>:<span class="number">30</span>:<span class="number">18</span></span><br><span class="line">b <span class="keyword">is</span>: <span class="number">1</span></span><br><span class="line">exit hi() <span class="number">2</span> @<span class="number">16</span>:<span class="number">30</span>:<span class="number">19</span></span><br><span class="line">b <span class="keyword">is</span>: <span class="number">2</span></span><br><span class="line">exit hi() <span class="number">3</span> @<span class="number">16</span>:<span class="number">30</span>:<span class="number">20</span></span><br><span class="line">b <span class="keyword">is</span>: <span class="number">3</span></span><br><span class="line">exit hi() <span class="number">4</span> @<span class="number">16</span>:<span class="number">30</span>:<span class="number">21</span></span><br><span class="line">b <span class="keyword">is</span>: <span class="number">4</span></span><br><span class="line">main() end at <span class="number">16</span>:<span class="number">30</span>:<span class="number">21</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>3. 错误的运行</strong></p><p>上面的并发很完美，但有时候你可能会犯错，比如下面的main()，你可能只是并发hi()，但不需要返回它的结果，于是就有了下面的main()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">msg, sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;enter hi(), &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;exit hi() &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">return</span> sec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main() begin at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        asyncio.create_task(hi(i, i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main() end at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>下面是运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main() begin at <span class="number">16</span>:<span class="number">45</span>:<span class="number">42</span></span><br><span class="line">main() end at <span class="number">16</span>:<span class="number">45</span>:<span class="number">42</span></span><br><span class="line">enter hi(), <span class="number">1</span> @<span class="number">16</span>:<span class="number">45</span>:<span class="number">42</span></span><br><span class="line">enter hi(), <span class="number">2</span> @<span class="number">16</span>:<span class="number">45</span>:<span class="number">42</span></span><br><span class="line">enter hi(), <span class="number">3</span> @<span class="number">16</span>:<span class="number">45</span>:<span class="number">42</span></span><br><span class="line">enter hi(), <span class="number">4</span> @<span class="number">16</span>:<span class="number">45</span>:<span class="number">42</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>main()的for循环只是生成了4个task协程，然后就退出了，event_loop收到main退出的事件就空出来去执行了那4个协程，进去了但都碰到了sleep，然后envent_loop就空闲了，这个时候run()就收到了main()执行完毕的事件信号，run()就执行完了，最后执行print，整个程序就退出了，从main退出到整个程序退出那就是一瞬间的事情，那4个协程还在傻傻地睡着，如果把它们也加入任务列表就不会这样了，如果不加入，那默认任务列表就只有main函数，其他的只是微微带过，如果main函数结束了，它们也会立马结束</p><p>我们如果在main()中加入一个sleep会出现什么结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hi</span>(<span class="params">msg, sec</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;enter hi(), &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sec)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;exit hi() &#123;&#125; @&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(msg, time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">return</span> sec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main() begin at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        asyncio.create_task(hi(i, i))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;mian() sleep at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main() end at &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(time.strftime(<span class="string">&#x27;%H:%M:%S&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main() begin at <span class="number">17</span>:06:<span class="number">59</span></span><br><span class="line">mian() sleep at <span class="number">17</span>:06:<span class="number">59</span></span><br><span class="line">enter hi(), <span class="number">1</span> @<span class="number">17</span>:06:<span class="number">59</span></span><br><span class="line">enter hi(), <span class="number">2</span> @<span class="number">17</span>:06:<span class="number">59</span></span><br><span class="line">enter hi(), <span class="number">3</span> @<span class="number">17</span>:06:<span class="number">59</span></span><br><span class="line">enter hi(), <span class="number">4</span> @<span class="number">17</span>:06:<span class="number">59</span></span><br><span class="line">exit hi() <span class="number">1</span> @<span class="number">17</span>:07:<span class="number">00</span></span><br><span class="line">exit hi() <span class="number">2</span> @<span class="number">17</span>:07:01</span><br><span class="line">main() end at <span class="number">17</span>:07:01</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>可以看到这边main函数sleep了两秒就让两次hi函数执行完毕，如果我们让main函数sleep更长时间那就4个hi函数都会执行完毕</p><p>说明，功能函数如果不加入任务列表，那就要求入口函数有足够长的执行时间，因为在入口函数的长执行时间中就会有机会去执行功能函数</p><p><strong>4. 如何判断是否要把函数定义为协程函数</strong></p><p>定义一个协程函数很简单，在def前面加async即可，那么如何判断一个函数该不该定义为协程函数呢?</p><p>记住一个原则: 如果该函数是要进行IO操作(读写网络、读写文件、读写数据库等)，就把它定义为协程函数，否则就是普通函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;异步IO是个好东西，在网络读写场景中可以大大提高程序的并发能力，比如爬虫、web服务等；这样好的东西自然也要用到Python中，不过，在漫长的Python2时代，官方并没有推出一个自己的异步IO库，到了Python3.4才推出；我们先来看看异步IO在Python中的发展历史</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python 中__new__和__init__的异同点</title>
    <link href="http://example.com/2022/01/14/Python%20%E4%B8%AD__new__%E5%92%8C__init__%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9/"/>
    <id>http://example.com/2022/01/14/Python%20%E4%B8%AD__new__%E5%92%8C__init__%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9/</id>
    <published>2022-01-14T03:50:30.000Z</published>
    <updated>2022-01-14T07:01:13.653Z</updated>
    
    <content type="html"><![CDATA[<p>同: 二者均是Python面向对象语言中的函数，__new__比较少用，__init__则用的比较多</p><p>异: </p><ul><li><code>__new__</code>是在实例创建之前被调用的，因为它的任务就是创建实例然后直接返回该实例对象，是个<strong>静态方法</strong></li><li><code>__init__</code>是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，通常在初始化一个类实例的时候被调用，是一个<strong>实例方法</strong></li></ul><p>总结来说也就是: <code>__new__</code>先被调用，<code>__init__</code>后被调用，<code>__new__</code>的返回值（实例）将传递给<code>__init__</code>方法的第一个参数，然后<code>__init__</code>给这个实例设置一些参数</p><p>一些说明:</p><ol><li>继承自object的新式类才有<code>__new__</code></li><li><code>__new__</code>至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别</li><li><code>__new__</code><strong>必须要有返回值</strong>，返回实例化出来的实例，这点在自己实现<code>__new__</code>时要特别注意，可以return父类<code>__new__</code>出来的实例，或者是直接object<code>__new__</code>出来的 实例</li><li><code>__init__</code>有一个参数self，这个就是<code>__new__</code>返回的实例，<code>__init__</code>在<code>__new__</code>的基础上可以完成一些其它初始化的操作，<code>__init__</code><strong>不需要返回值</strong></li><li>如果<code>__new__</code>创建的是当前类的实例，会自动调用<code>__init__</code>函数，通过return语句里面调用的<code>__new__</code>函数的第一个参数是cls来保证是当前类实例，如果是其它类的类名，那么实际创建返回的就是其他类的实例</li><li>在定义子类时没有重新定义<code>__new__</code>时，Python默认是调用该类的直接父类的<code>__new__</code>来构造该类的实例，如果该类的父类也没有重写<code>__new__</code>，那么将一直按此规矩追溯至object的<code>__new__</code>方法，因为object是所有新式类的基类</li><li>而如果子类中重写了<code>__new__</code>，那么你可以自由选择任意一个的其他新式类(必定要是新式类，只有新式类必定都有<code>__new__</code>，因为所有新式类都是object的后代，而经典类则没有<code>__new__</code>方法)的<code>__new__</code>方法来制造实例</li><li>对于子类的<code>__init__</code>，其调用规制跟<code>__new__</code>是一致的，当然如果子类和父类的<code>__init__</code>都想调用，可以在子类的<code>__init__</code>中加入对父类<code>__init__</code>的调用</li><li>我们在使用时，尽量使用<code>__init__</code>，不要去自定义<code>__new__</code>，因为这两者在继承派生时的特性还是很不一样的</li><li><strong>将类比作制造商，<code>__new__</code>方法就是前期的原料购买环节，<code>__init__</code>方法就是在原有材料的基础上加工、初始化商品化环节</strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;同: 二者均是Python面向对象语言中的函数，__new__比较少用，__init__则用的比较多&lt;/p&gt;
&lt;p&gt;异: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__new__&lt;/code&gt;是在实例创建之前被调用的，因为它的任务就是创建实例然后直接返回该实例对象，是个&lt;st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JS逆向的时候Python如何调用JavaScript代码呢</title>
    <link href="http://example.com/2022/01/14/JS%E9%80%86%E5%90%91%E7%9A%84%E6%97%B6%E5%80%99Python%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8JavaScript%E4%BB%A3%E7%A0%81%E5%91%A2/"/>
    <id>http://example.com/2022/01/14/JS%E9%80%86%E5%90%91%E7%9A%84%E6%97%B6%E5%80%99Python%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8JavaScript%E4%BB%A3%E7%A0%81%E5%91%A2/</id>
    <published>2022-01-14T03:35:30.000Z</published>
    <updated>2022-01-14T03:37:04.471Z</updated>
    
    <content type="html"><![CDATA[<p>今天在逛崔庆才博客的时候发现这个讲得还不错，是关于Python如何调用JS代码的，点击<a class="link"   href="https://cuiqingcai.com/9581.html" >这里<i class="fas fa-external-link-alt"></i></a>调转阅读</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天在逛崔庆才博客的时候发现这个讲得还不错，是关于Python如何调用JS代码的，点击&lt;a class=&quot;link&quot;   href=&quot;https://cuiqingcai.com/9581.html&quot; &gt;这里&lt;i class=&quot;fas fa-external-link-al</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python爬虫登录的恩恩怨怨</title>
    <link href="http://example.com/2022/01/14/Python%E7%88%AC%E8%99%AB%E7%99%BB%E5%BD%95%E7%9A%84%E6%81%A9%E6%81%A9%E6%80%A8%E6%80%A8/"/>
    <id>http://example.com/2022/01/14/Python%E7%88%AC%E8%99%AB%E7%99%BB%E5%BD%95%E7%9A%84%E6%81%A9%E6%81%A9%E6%80%A8%E6%80%A8/</id>
    <published>2022-01-14T02:58:30.000Z</published>
    <updated>2022-01-14T03:08:33.838Z</updated>
    
    <content type="html"><![CDATA[<p>曾几何时，登录是一件很简单的事情，一个账户及其密码，POST给服务器，服务器验证通过即可。那是一个美好的朴素年代，服务器不设防，用户不贪婪。然而，时过境迁，人心变了。越来越多的人想要收集数据，爬虫也就越来越多；而网站就有了网络请求压力，也有了死守数据私心。天下熙熙，皆为利来；天下攘攘，皆为利往。现在的互联网，就成了一个利字当头、魔高一尺道高一丈的战场</p><p>如今，各种网站都设置了复杂的登录这堵高高的墙来阻止爬虫大量甚至全部获取网站的数据。比如，12306的验证码是点选图片，微博是变形的字母验证码，知乎是点选倒立的汉字，哔哩哔哩通过拖动滑块拼图来验证。这些<em>变态的验证</em>过程都是加入人的交互来防止爬虫自动登录，从而阻止爬虫自动化的大批量抓取</p><p>小猿们都已经知道，HTTP协议是无状态的，用户登录的状态靠cookies在浏览器和服务器之间来回传送来记录。完成登录后，cookies在一定时间范围内是保持不变的，直接获得这个cookies给爬虫用，就可以让爬虫有了登录的状态，进而进行后面的抓取，当然，这个抓取只能持续到cookies过期之前</p><p>在这里我们来看看爬虫登录的三种层次，完成登录这个过程，最好是程序自动化实现，那么你写好程序就可以一边玩去了，然而好多时候，事情不是那么让人省心，登录还需要人工参与一下下；总结下来，实现登陆有以下三种层次:</p><ol><li>简单的PODT账户密码就可以实现自动化登录</li><li>通过程序可以模拟出登录流程实现自动化登录</li><li>登录需要人工智能介入，人工智能实现自动化登录</li></ol><p>第一个层次，使用requests模块加一两行代码就可以实现，关键是现如今很少有这样的良心网站了</p><p>第二个层次，是很有挑战性的，也是爬虫界人士力求达到的层次</p><p>第三个层次，就需要接入人工智能，利用人工智能识别验证码</p><p>由此看来，登录状态的cookies的获取，主要还是靠模拟登录流程或者人工智能识别验证码为主</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;曾几何时，登录是一件很简单的事情，一个账户及其密码，POST给服务器，服务器验证通过即可。那是一个美好的朴素年代，服务器不设防，用户不贪婪。然而，时过境迁，人心变了。越来越多的人想要收集数据，爬虫也就越来越多；而网站就有了网络请求压力，也有了死守数据私心。天下熙熙，皆为利来</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python中eval函数的用法</title>
    <link href="http://example.com/2022/01/14/Python%E4%B8%ADeval%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2022/01/14/Python%E4%B8%ADeval%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2022-01-14T02:46:30.000Z</published>
    <updated>2022-01-14T02:49:54.758Z</updated>
    
    <content type="html"><![CDATA[<p>eval()函数用来执行一个字符串表达式，并返回表达式的值</p><p>以下是eval()函数的语法:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(expression[, <span class="built_in">globals</span>[, <span class="built_in">locals</span>]])</span><br></pre></td></tr></table></figure><p>实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;x = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>( <span class="string">&#x27;3 * x&#x27;</span> )</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;pow(2,2)&#x27;</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&#x27;2 + 2&#x27;</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n=<span class="number">81</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">eval</span>(<span class="string">&quot;n + 4&quot;</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;eval()函数用来执行一个字符串表达式，并返回表达式的值&lt;/p&gt;
&lt;p&gt;以下是eval()函数的语法:&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python中format函数的用法</title>
    <link href="http://example.com/2022/01/14/Python%E4%B8%ADformat%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2022/01/14/Python%E4%B8%ADformat%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</id>
    <published>2022-01-14T02:36:30.000Z</published>
    <updated>2022-01-14T02:45:06.381Z</updated>
    
    <content type="html"><![CDATA[<p>Python2.6开始便新增了一种格式化字符串的str.format()函数，基本语法是通过<code>&#123;&#125;</code>和<code>:</code>来代替以前的<code>%</code></p><p>format函数可以接受不限个数的参数，位置可以不按顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br></pre></td></tr></table></figure><p>也可以设置参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;菜鸟教程&quot;</span>, url=<span class="string">&quot;www.runoob.com&quot;</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过字典设置参数</span></span><br><span class="line">site = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;菜鸟教程&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;www.runoob.com&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="built_in">format</span>(**site))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过列表索引设置参数</span></span><br><span class="line">my_list = [<span class="string">&#x27;菜鸟教程&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;</span>.<span class="built_in">format</span>(my_list))  <span class="comment"># &quot;0&quot; 是必须的</span></span><br></pre></td></tr></table></figure><p>也可以向str.format()传入对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssignValue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">my_value = AssignValue(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;value 为: &#123;0.value&#125;&#x27;</span>.<span class="built_in">format</span>(my_value))  <span class="comment"># &quot;0&quot; 是可选的</span></span><br></pre></td></tr></table></figure><p>format还可以进行数字格式化，这个用到的不多</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python2.6开始便新增了一种格式化字符串的str.format()函数，基本语法是通过&lt;code&gt;&amp;#123;&amp;#125;&lt;/code&gt;和&lt;code&gt;:&lt;/code&gt;来代替以前的&lt;code&gt;%&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;format函数可以接受不限个数的参数，位置可</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python十大高级用法</title>
    <link href="http://example.com/2022/01/13/Python%E5%8D%81%E5%A4%A7%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2022/01/13/Python%E5%8D%81%E5%A4%A7%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</id>
    <published>2022-01-13T09:44:01.936Z</published>
    <updated>2022-01-13T09:43:48.237Z</updated>
    
    <content type="html"><![CDATA[<p>参考自:<a class="link"   href="https://syjun.vip/archives/185.html" >https://syjun.vip/archives/185.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考自:&lt;a class=&quot;link&quot;   href=&quot;https://syjun.vip/archives/185.html&quot; &gt;https://syjun.vip/archives/185.html&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js混淆-动态cookie题目详解</title>
    <link href="http://example.com/2022/01/13/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/01/13/js%E6%B7%B7%E6%B7%86-%E5%8A%A8%E6%80%81cookie%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-01-13T08:11:30.000Z</published>
    <updated>2022-01-13T09:40:28.394Z</updated>
    
    <content type="html"><![CDATA[<p>第二题是js混线，动态cookie，这也是提取全部5页的数据，题目链接:<a class="link"   href="https://match.yuanrenxue.com/match/2" >https://match.yuanrenxue.com/match/2<i class="fas fa-external-link-alt"></i></a></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-13-29.3z6b7ki67ye0.webp"                      alt="Snipaste_2022-01-13_16-13-29"                ></p><p>我们先来抓下包叭，打开F12同样会在断点处断住，然后我们只需要右键点击Never parsed here即可，随后我们可以看到第一页的十条数据</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-19-31.7krfqxq74xc0.webp"                      alt="Snipaste_2022-01-13_16-19-31"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-21-02.2xas5aqu4jm0.webp"                      alt="Snipaste_2022-01-13_16-21-02"                ></p><p>这是个xhr请求，而且它只有一个参数page</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-22-37.38mf806puvs0.webp"                      alt="Snipaste_2022-01-13_16-22-37"                ></p><p>实际上这个题它这边已经说了是个动态cookie，所以是一定要有cookie才能去访问的，然后，一般情况下，如果我们碰到一个类似的网页，如果只是当时即时使用的话可以直接复制这个cookie去拿数据，但我们都知道cookie是具有一定时效性的，时间久了这种操作是不可取的，所以我们就需要去分析cookie是怎么来的，是本地生成的还是服务器返回的一个set-cookie，如果是服务器返回的，那就可以模拟浏览器的请求去开一个session即可，如果是本地生成的话就得分析cookie是怎么本地生成的，然后把这个cookie给它凑出来，扣js或者是怎么样把这个cookie给生成出来，如果是两种方法都有的话那就两种方法结合起来用</p><p>我们继续抓一下包，点击第二页会弹出一个框说cookie失效，说明合格cookie的有效期是比较短的，点击确定后就会获取一个新的cookie，然后进入页面，以下是第一页抓到的包，我们看到这边是有cookie的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-39-04.184fqz9f177g.webp"                      alt="Snipaste_2022-01-13_16-39-04"                ></p><p>然后我们要拿到的数据就是它返回的数据，也就是Preview中的数据</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_16-43-10.4q3e6sbq69w0.webp"                      alt="Snipaste_2022-01-13_16-43-10"                ></p><p>未完待续</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第二题是js混线，动态cookie，这也是提取全部5页的数据，题目链接:&lt;a class=&quot;link&quot;   href=&quot;https://match.yuanrenxue.com/match/2&quot; &gt;https://match.yuanrenxue.com/match/2&lt;i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2022-1-13每日英语</title>
    <link href="http://example.com/2022/01/13/2022-1-13%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD/"/>
    <id>http://example.com/2022/01/13/2022-1-13%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD/</id>
    <published>2022-01-13T07:03:30.000Z</published>
    <updated>2022-01-14T01:08:45.302Z</updated>
    
    <content type="html"><![CDATA[<ol><li>interval n. 间隔，间隙；幕间休息；[ˈɪntərvl]</li><li>query n. 疑问，询问；问号；v. 质疑，对…表示疑问；询问，提问；[ˈkwɪri]</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;interval n. 间隔，间隙；幕间休息；[ˈɪntərvl]&lt;/li&gt;
&lt;li&gt;query n. 疑问，询问；问号；v. 质疑，对…表示疑问；询问，提问；[ˈkwɪri]&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js混淆-源码乱码题目详解</title>
    <link href="http://example.com/2022/01/13/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/01/13/js%E6%B7%B7%E6%B7%86-%E6%BA%90%E7%A0%81%E4%B9%B1%E7%A0%81%E9%A2%98%E7%9B%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-01-13T03:16:30.000Z</published>
    <updated>2022-01-13T07:11:35.202Z</updated>
    
    <content type="html"><![CDATA[<p>我们打开猿人学的刷题网站:<a class="link"   href="https://match.yuanrenxue.com/list" >https://match.yuanrenxue.com/list<i class="fas fa-external-link-alt"></i></a></p><p>我们先来看第一题，第一题是关于js混淆的，这题目看着就比较有意思，我们来看看</p><p>首先我们打开一题，然后按F12打开调试，发现这边一打开就有个断点</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_14-43-50.41jvk3e1uyw0.webp"                      alt="Snipaste_2022-01-13_14-43-50"                ></p><p>然后我们可以在设置间隔的函数中把debugger给跳过(右键点击Never pause here)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_14-52-31.5g4rrskb28g0.webp"                      alt="Snipaste_2022-01-13_14-52-31"                ></p><p>我们过掉这个debug之后，重新抓下包，可以看到1到3页都是有的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_14-57-38.1zslirmzf2bk.webp"                      alt="Snipaste_2022-01-13_14-57-38"                ></p><p>点击第四页就会弹出一个弹窗</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_14-58-42.76ac9zzw4as.webp"                      alt="Snipaste_2022-01-13_14-58-42"                ></p><p>可以看到这边有个payload，我们主要要解这m参数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_15-07-26.3pmquafpveg.webp"                      alt="Snipaste_2022-01-13_15-07-26"                ></p><p>这个参数的话竖线后面是一个时间戳</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们打开猿人学的刷题网站:&lt;a class=&quot;link&quot;   href=&quot;https://match.yuanrenxue.com/list&quot; &gt;https://match.yuanrenxue.com/list&lt;i class=&quot;fas fa-external-link-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件构建CMake 快速入门</title>
    <link href="http://example.com/2022/01/13/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BACMake%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/13/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BACMake%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-13T01:26:20.000Z</published>
    <updated>2022-01-13T03:12:31.744Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来讲一下软件构建工具，无论你用的是什么平台、什么编程语言，构建(Build)都是软件开发中必不可少的一个步骤</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-28-51.4r66svbqwbs0.webp"                      alt="Snipaste_2022-01-13_09-28-51"                ></p><p>如果你的项目只有一个源文件，我们当然可以用一行命令完成编译、链接的整个过程</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-32-52.llvqtbn80cg.webp"                      alt="Snipaste_2022-01-13_09-32-52"                ></p><p>但如果你面对的是一个复杂的项目，其中包含不同的模块、组件，每个组件由若干个源文件组成，里面还用到了不少的第三方库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-35-14.37bgecfd1z80.webp"                      alt="Snipaste_2022-01-13_09-35-14"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-35-43.69948jblt2o0.webp"                      alt="Snipaste_2022-01-13_09-35-43"                ></p><p>这时候如果我们再去手动编译链接，将会非常的低效，而软件构建所做的就是全自动完成代码编译、链接、打包的整个过程，并且还能管理不同组件、甚至包括第三方库的关联，我们平时使用的IDE大多都内置了构建系统，只是我们没有留意罢了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-39-11.6ihfm3a2r600.webp"                      alt="Snipaste_2022-01-13_09-39-11"                ></p><p>每一个构建工具通常有各自擅长的领域，如果你在VS中做C++开发，那么多半用到的是微软自己的MSBuild</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-41-13.48jcqdensgo0.webp"                      alt="Snipaste_2022-01-13_09-41-13"                ></p><p>如果你使用Android Stuiod写移动端的程序，那么多半用到的是Gradle等等</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-42-27.50s3cij5n1k0.webp"                      alt="Snipaste_2022-01-13_09-42-27"                ></p><p>当然还有一些更复杂、更万能的构建系统，比如Bazel、BUCK</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-43-44.26b508ka13gg.webp"                      alt="Snipaste_2022-01-13_09-43-44"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-44-13.5gr7yq3g6yg0.webp"                      alt="Snipaste_2022-01-13_09-44-13"                ></p><p>它们试图使用单个工具来完成各种语言在不同环境下的构建，今天我会以CMake为例专门介绍一下C和C++程序的构建</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-46-02.1ya1r6riui2o.webp"                      alt="Snipaste_2022-01-13_09-46-02"                ></p><p>它是一个被广泛使用的、开源免费使用并且完全跨平台的构建工具，如果你希望在不同平台上编译运行你的软件，以后就不再需要手动配置Makefile，vs或者Xcode工程了，我们今天讲到的CMake会自动帮你做到这一切</p><p> 首先我们看看CMake的安装，我们可以直接在官网下载最新的安装包</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-51-20.3nd1mselb9o0.webp"                      alt="Snipaste_2022-01-13_09-51-20"                ></p><p>也可以使用操作系统自带的包管理工具</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-51-20.3nd1mselb9o0.webp"                      alt="Snipaste_2022-01-13_09-51-20"                ></p><p>随后可以试着在命令行中输入CMake命令</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-53-54.6mcka3o1hq80.webp"                      alt="Snipaste_2022-01-13_09-53-54"                ></p><p>这里如果找不到命令的话可能还需要手动配置安装路径到PATH环境变量下</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-13_09-54-33.5syfzrje21k.webp"                      alt="Snipaste_2022-01-13_09-54-33"                ></p><p>另外我们要确保计算机上安装有C++的编译工具，比如windows下的MSBuild工具链或者直接安装Visual Studio，在Linux下则需要安装gcc或者clang等等，这是因为CMake自身是不带编译工具的，他会根据你编写的构建规则，也就是我们马上要讲道德CMakeLists文件，来自动生成目标平台下的原生工程文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_09-59-25.7e55kb6z1yc0.webp"                      alt="Snipaste_2022-01-13_09-59-25"                ></p><p>比如windows下的VS工程或者Linux下的Makefile等等，因此要顺利完成编译，C++工具链是必不可少的，接下来我会从最简单的，只有单个源文件的例子来介绍CMake的基本用法，最后我会用之前视频中创建的一个黑洞渲染的工程，来讲解相对复杂一点的情况，刚好这个工程包含多个源文件、图片资源还会有一些第三方库，因此更加贴近与实际项目一些</p><p>首先我们要做的第一件事是在项目的根目录下创建一个CMakeLists.txt文件，对于一个最简单的、只有一个源文件的工程，这三行代码是必不可少的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-07-17.6e4og08tza00.webp"                      alt="Snipaste_2022-01-13_10-07-17"                ></p><p>首先第一行指定了构建项目所需的最低CMake版本，第二行指定了工程的名字，我们随后输出的可执行文件也会和它同一个名称</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-09-44.4prnh08hhf0.webp"                      alt="Snipaste_2022-01-13_10-09-44"                ></p><p>第三行表示我们的项目需要构建一个可执行文件，并且它由main.cpp编译而成</p><p>随后我们需要根据这个CMakeList文件生成目标平台下的原生工程，这个过程在CMake中叫做”配置”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-11-50.5lh2kup3dm80.webp"                      alt="Snipaste_2022-01-13_10-11-50"                ></p><p>我们可以在菜单中找到CMake Configure命令</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-14-39.6gbnapdrz6w0.webp"                      alt="Snipaste_2022-01-13_10-14-39"                ></p><p>或者VScode在打开项目时会自动提示你进行项目“配置”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-15-56.60lvfdsl9cg0.webp"                      alt="Snipaste_2022-01-13_10-15-56"                ></p><p>我们只需要选择平台原生的C++构建工具然后等待配置完成即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-17-41.xscb8wyamy8.webp"                      alt="Snipaste_2022-01-13_10-17-41"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-19-13.4hyns6v2b8c0.webp"                      alt="Snipaste_2022-01-13_10-19-13"                ></p><p>接下来到了真正构建环节</p><p>这里我们可以使用快捷键F7，或者在菜单中运行CMake: Build命令</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-21-37.6r7j7wyyoeo0.webp"                      alt="Snipaste_2022-01-13_10-21-37"                ></p><p>如果一切顺利的话，面板中会输出成功编译的可执行文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-22-40.3ssas4n706k0.webp"                      alt="Snipaste_2022-01-13_10-22-40"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-23-18.un7g3s9i5cg.webp"                      alt="Snipaste_2022-01-13_10-23-18"                ></p><p>另外我们所做的“配置”和“构建”操作都有对应的命令行指令，我们也可以在输出面板中找到它们</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-24-58.2gwvtoonrl40.webp"                      alt="Snipaste_2022-01-13_10-24-58"                ></p><p>在通常情况下，使用菜单或者图形界面自然更方便一些，但入股哦我们想在服务器上做持续继承(CI)，进行自动化的编译和测试，这里的命令行就格外有用了</p><p>接下来，我们来看第二个相对复杂一点的工程配置，之前我们讲到这个工程包含了多个源文件、图片资源还有一些第三方库，因此这里的CmakeLists也会相对复杂一些</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-30-09.5w098ggtap40.webp"                      alt="Snipaste_2022-01-13_10-30-09"                ></p><p>首先前两行和我们之前讲到的完全一样，它们定义了CMake最低版本和工程文件名，随后映入眼帘的是一系列的find_package()命令，它会在你的计算机中寻找符合要求的第三方库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-33-08.i325z0d4cg0.webp"                      alt="Snipaste_2022-01-13_10-33-08"                ></p><p>首先你需要确保计算机中事先安装好了它们</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-34-24.757o3s9eb4k0.webp"                      alt="Snipaste_2022-01-13_10-34-24"                ></p><p>关于库的安装我后面再说</p><p>其次这些库也需要支持用CMake进行构建，这个一般没有问题，因为大多数常见的C++库都提供了CMake的支持，这个命令的第一个参数是各个库的名字，后面的REQUIRED代表这个库是必须的，如果计算机中没有安装则会直接报错</p><p>我们继续来看后面这个命令，由于这个项目由多个源文件组成，所以我们先调用file GLOB命令通过通配符匹配所有的C++源文件，并将它存放在变量SRC_FILE中，随后我们调用相同的add_executable()命令来构建一个可执行文件，第一个参数是工程文件的名字，这里的CMAKE_PROJECT_NAME是一个宏，会被自动替换成这里的工程名Blackhole，第二个禅师则是我们之前匹配的所有源文件</p><p>由于我们项目用到了一些第三方库，所以自然少不了链接(Link)库的操作</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-49-11.40jxqoj5oli0.webp"                      alt="Snipaste_2022-01-13_10-49-11"                ></p><p>如果忘记了这个步骤，那么你应该会遇到经典的符号无法解析的错误</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-50-31.5fqvyvhzjdk0.webp"                      alt="Snipaste_2022-01-13_10-50-31"                ></p><p>并且由于我们项目用到了C++17以上的语法，所以这里需要通过target_compile_fetures()打开对C++17的支持，最后我们用到这个命令add_custom_command</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-53-45.73e3byhz3s80.webp"                      alt="Snipaste_2022-01-13_10-53-45"                ></p><p>这里的POST_BUILD也就是字面意思代表编译之后要执行的操作，我们会调用CMake命令将根目录下的assets文件夹拷贝到输出路径下</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-57-02.1yww4k1wrcqo.webp"                      alt="Snipaste_2022-01-13_10-57-02"                ></p><p>这一步只是一个简单的自动化，避免了文件的手动复制，这样在构建完成之后我们可以在输出路径下找到应用所需所有文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_10-58-46.38dd3y0fzhe0.webp"                      alt="Snipaste_2022-01-13_10-58-46"                ></p><p>在最后我们来讲下C++第三方库的安装</p><p>由于CMake只是一个构建工具，它并不包含库的安装和管理，如果我们的项目用到了第三方库，则需要确保计算机中事先安装好了它们，常见的安装方式有直接下载库的源文件，然后手动构建并指定CMake库的路径，当然对于Linux和mac我们也可以直接通过包管理工具安装，不过缺点是，每安装一个库都需要执行许多繁琐的步骤，并且不同平台下的配置过程也不太一样，因此这里推荐一个微软的开源工具vcpkg</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_11-05-25.2s4onmlme0o0.webp"                      alt="Snipaste_2022-01-13_11-05-25"                ></p><p>虽然名字叫vcpkg，不过它是一个跨平台的C++库管理工具，类似Python的pip，你要做的是先调用vcpkg install 安装第三方库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_11-07-26.65cbb60k54w0.webp"                      alt="Snipaste_2022-01-13_11-07-26"                ></p><p>然后在CMake构建的时候指定vcpkg工具链即可，如果你用过的是命令行，只需要额外传递一个参数CMAKE_TOOLCHAIN_FILE</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_11-09-04.a738lwx508g.webp"                      alt="Snipaste_2022-01-13_11-09-04"                ></p><p>如果你用的是vscode插件，那么在设置中添加这个路径即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220113/Snipaste_2022-01-13_11-10-02.3kbngsv7tv40.webp"                      alt="Snipaste_2022-01-13_11-10-02"                ></p><p>关于vcpkg的安装步骤大家可以参考官方详细的文档</p><p>CMake其实是一个非常灵活但也非常复杂的工具，这个最好还是边学边用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天我们来讲一下软件构建工具，无论你用的是什么平台、什么编程语言，构建(Build)都是软件开发中必不可少的一个步骤&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python实例方法、类方法、静态方法的区别与作用</title>
    <link href="http://example.com/2022/01/13/Python%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2022/01/13/Python%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8/</id>
    <published>2022-01-13T01:08:30.000Z</published>
    <updated>2022-01-13T01:16:33.997Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>实例方法</p><p>定义: 第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法(也可以传类的属性和方法)，简而言之，实例方法就是类的实例能够使用的方法</p><p>调用: 只能由实例对象调用</p></li><li><p>类方法</p><p>定义: 使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法(不能传实例的属性和方法)，原则上，类方法是将类本身作为对象进行操作的方法。假设有个方法，且这个方法在逻辑上采用类本身作为对象来调用更合理，那么这个方法就可以定义为类方法。另外，如果需要继承，也可以定义为类方法</p><p>调用: 实例对象和类对象都可以调用</p></li><li><p>静态方法</p><p>定义: 使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法</p><p>调用: 实例对象和类对象都可以调用</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;实例方法&lt;/p&gt;
&lt;p&gt;定义: 第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法(也可以传类的属性和方法)，简而言之，实例方法就是类的实例能够使用的方法&lt;/p&gt;
&lt;p&gt;调用: 只能由实例对象调用&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>“并发、并行、异步、同步”的区别</title>
    <link href="http://example.com/2022/01/12/%E2%80%9C%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%90%8C%E6%AD%A5%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/01/12/%E2%80%9C%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81%E5%BC%82%E6%AD%A5%E3%80%81%E5%90%8C%E6%AD%A5%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-12T09:30:30.000Z</published>
    <updated>2022-01-12T10:52:59.853Z</updated>
    
    <content type="html"><![CDATA[<p>并发、并行、异步、同步，这些术语之间到底有什么区别和联系呢</p><p><a href="https://imgtu.com/i/7K9ibd"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7K9ibd.png"                      alt="7K9ibd.png"                ></a></p><p>首先并发是一个比较宽泛的概念，<strong>它单纯地代表计算机能够同时执行多项任务</strong></p><p><a href="https://imgtu.com/i/7K9aMF"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7K9aMF.png"                      alt="7K9aMF.png"                ></a></p><p>至于计算机怎么做到“并发”则有许多不同的形式，比如对于一个单核处理器，计算机可以通过分配时间片的方式，让一个任务运行一段时间，然后切换另一个任务，再运行一段时间，不同的任务会这样交替往复地一直执行下去，这个过程也被称作是进程或者线程的上下文切换(context switching)</p><p><a href="https://imgtu.com/i/7KCgkn"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KCgkn.png"                      alt="7KCgkn.png"                ></a></p><p>当然对于多核处理器，情况就有所不同了，我们<strong>可以在不同的核心上真正并行地执行任务，而不用通过分配时间片的方式运行</strong>，这种情况也就是我们所说的并行(parallelism)</p><p><a href="https://imgtu.com/i/7KPlhq"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KPlhq.png"                      alt="7KPlhq.png"                ></a></p><p>至于同步和异步则是两种不同的编程模型，<strong>“同步”代表需要等到必须前一个任务执行完毕之后才能进行下一个任务</strong>，因此在同步中并没有并发或者并行的概念，而<strong>“异步“”则代表不同的任务之间并不会相互等待，也就是说，你在执行任务A的时候，也可以同时运行任务B</strong>，一个典型实现异步的方式则是通过多线程编程，你可以创建多个线程，并且启动它们</p><p><a href="https://imgtu.com/i/7Ki7J1"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7Ki7J1.png"                      alt="7Ki7J1.png"                ></a></p><p>在多核的情况下，每个线程就会被分配到独立的核心上运行，实现真正的“并行”，当然如果你使用的是单核处理器，或者通过设置亲和力(Affinity)强制将线程绑定到某个核心上，操作系统则会通过分配时间片的方式来执行这些线程，这些线程依然是在“并发”地执行，当然像某些编程语言，比如JavaScript本身是没有多线程的概念的，不过通过它的函数回调(function callback)机制，我们依然能做到单线程的“并发”，比如你可以通过fetch()同时访问多个网络资源</p><p><a href="https://imgtu.com/i/7Kk5CR"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7Kk5CR.png"                      alt="7Kk5CR.png"                ></a></p><p>我们在调用fetch()函数的时候，程序并不会等待，而会直接继续执行下去，当获取到网路资源以后</p><p><a href="https://imgtu.com/i/7KAMrT"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KAMrT.png"                      alt="7KAMrT.png"                ></a></p><p>回调函数才会被掉起，需要注意的是，虽然主函数和回调函数看起来是同时进行的</p><p><a href="https://imgtu.com/i/7KAgzt"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KAgzt.png"                      alt="7KAgzt.png"                ></a></p><p>但它们依然是运行在同一个线程中</p><p><a href="https://imgtu.com/i/7KEX9A"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KEX9A.png"                      alt="7KEX9A.png"                ></a></p><p>因此通过这种异步编程方式，我们完全可以做到单线程的“并发”，而且这并不是JavaScript的专利，很多语言也都提供了原生的异步编程方式，比如C#，Rusut，C++2.0中的co_await，Python中的asyncio等等等等</p><p><a href="https://imgtu.com/i/7KVgDf"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KVgDf.png"                      alt="7KVgDf.png"                ></a></p><p><a href="https://imgtu.com/i/7KV2b8"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KV2b8.png"                      alt="7KV2b8.png"                ></a></p><p><a href="https://imgtu.com/i/7KVTvq"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7KVTvq.png"                      alt="7KVTvq.png"                ></a></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-12_18-39-15.3sta87zfdyg0.webp"                      alt="Snipaste_2022-01-12_18-39-15"                ></p><p>那到这里你肯定会问，对于多线程编程和这种单线程的异步编程，我们应当如何选择呢，简而言之，对于I/O密集型的应用程序，比如Web应用，就会经常执行网络操作，数据库访问，这类应用就非常适合使用异步编程的方式，反之如果我们使用多线程的方式，则会浪费不少的系统资源，因为每个线程的绝大多数时间都是在等待这些I/O操作，而线程自身会占用额外的内存，线程的切换也会有额外的开销，更不用说线程之间的资源竞争问题</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-12_18-46-30.h7nel7qo0fc.webp"                      alt="Snipaste_2022-01-12_18-46-30"                ></p><p>而多线程编程则非常适合于计算量密集的应用</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220112/Snipaste_2022-01-12_18-47-43.4urgzy14uec0.webp"                      alt="Snipaste_2022-01-12_18-47-43"                ></p><p>比如视频图像处理，科学计算等等，它能让每一个CPU核心发挥最大的功效，而不是消耗在空闲的等待上</p><p>纠错:</p><p>关于Python的例子我举得不太恰当，CPython中的GIL会导致Python代码的线程并不能做到真正并发，使用htop查看CPU使用率尽管在多核处理器也不会超过100%</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;并发、并行、异步、同步，这些术语之间到底有什么区别和联系呢&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgtu.com/i/7K9ibd&quot;&gt;&lt;img  
                     lazyload
                     src=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一次性搞懂线程同步机制</title>
    <link href="http://example.com/2022/01/12/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/01/12/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%87%82%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</id>
    <published>2022-01-12T07:11:30.000Z</published>
    <updated>2022-01-12T08:54:59.030Z</updated>
    
    <content type="html"><![CDATA[<p>使用线程，我们可以并发地在各个CPU核心上执行任务，最大化CPU的利用率，但线程也可能导致各种奇怪的资源竞争问题</p><p><a href="https://imgtu.com/i/7uaCgP"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uaCgP.png"                      alt="7uaCgP.png"                ></a></p><p>相信大家一定都看过这个经典案例</p><p><a href="https://imgtu.com/i/7uaMvV"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uaMvV.png"                      alt="7uaMvV.png"                ></a></p><p>用不同的线程去更新同一段内存数据，比如我们这里总共创建10个线程</p><p><a href="https://imgtu.com/i/7uaWxP"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uaWxP.png"                      alt="7uaWxP.png"                ></a></p><p>每个线程累加这个数字1000000次，运行程序你会发现得到的结果并不是预期的10000000，实际显示的数字可能会比它小很多，并且每次输出的结果还都不一样</p><p><a href="https://imgtu.com/i/7uaOx0"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uaOx0.png"                      alt="7uaOx0.png"                ></a></p><p>这里我会向大家解释为什么会出现这种情况，以及各种常见的线程同步机制</p><p><a href="https://imgtu.com/i/7udPi9"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7udPi9.png"                      alt="7udPi9.png"                ></a></p><p>我们先来回顾一下刚才的这段程序，其实问题就出在数字累加的这行代码上，虽然在程序中我们简单地写作n++，但是当程序被编译成机器代码时，n++其实被翻译成三条不同的机器指令(machine code)</p><p><a href="https://imgtu.com/i/7uddij"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uddij.png"                      alt="7uddij.png"                ></a></p><p>它们分别是，将内存中的数据加载到CPU的寄存器eax中，然后将eax中的数据+1，最后再将计算结果写回内存，换句话说，这里的n++并不是原子操作(atomic operation)，原子操作指的是不能被继续拆分、或者被其他操作打断的指令，这里顺带解释一下，寄存器(Registers)是CPU内部的小型存储器</p><p><a href="https://imgtu.com/i/7uwgjP"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uwgjP.png"                      alt="7uwgjP.png"                ></a></p><p>用来临时存放计算数据，CPU中的运算都离不开寄存器，它们的容量非常有限，但读写速度会比内存快很多，回到刚才的代码，如果不同的线程按照顺序依次执行</p><p>比如线程A先将数据5读入寄存器，然后+1得到6并写回内存，然后线程B再将数据6读入寄存器，+1得到7并写回内存，这样没有任何问题，但问题在于线程是并发执行的</p><p><a href="https://imgtu.com/i/7u05qK"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u05qK.png"                      alt="7u05qK.png"                ></a></p><p>可能线程A还未将累加后的数据写会内存，线程B就已经开始读取数据到寄存器，这样线程B就会读到修改之前的旧数据，最后的结果是数据只被累加了一次，这个就是我们平时说的线程资源竞争而导致的数据不一致问题，要解决这个问题，我们需要对线程进行同步，也就是让原先异步的操作依次有序地执行，而锁(lock)是我们接下来要讲的第一种，也是最最基本的线程同步机制，它的概念非常简单，<strong>在同一时间，只有一个线程可以获得(acquire)锁的拥有权(ownership)，此时其他的线程只能干等着，直到这个锁被持有者释放掉(release)</strong></p><p><a href="https://imgtu.com/i/7usuo8"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7usuo8.png"                      alt="7usuo8.png"                ></a></p><p>锁的获取和释放有时候也被叫做上锁(lock)和解锁(unlock)，在不同的语言或者操作系统中，通常会用到不同的锁的实现，比如C++或者Go中的mutex互斥锁</p><p><a href="https://imgtu.com/i/7u2AbR"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u2AbR.png"                      alt="7u2AbR.png"                ></a></p><p><a href="https://imgtu.com/i/7u21rd"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u21rd.png"                      alt="7u21rd.png"                ></a></p><p>java则允许使用synchronized关键字来对某个函数、对象或者代码上锁</p><p><a href="https://imgtu.com/i/7uRQYV"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uRQYV.png"                      alt="7uRQYV.png"                ></a></p><p>当然更底层一些，我们甚至可以调用操作系统的API来实现锁的功能，其他的你可能听过的还包括自旋锁、读写锁等等</p><p><a href="https://imgtu.com/i/7uWpX4"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uWpX4.png"                      alt="7uWpX4.png"                ></a></p><p>总而言之，锁的核心概念是非常简单的</p><p>我们只需要记住在访问共享资源之前上锁，并在结束之后解锁即可</p><p><a href="https://imgtu.com/i/7uWDNq"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uWDNq.png"                      alt="7uWDNq.png"                ></a></p><p>修改运行程序，我们可以看到，这里输出了我们的预期结果10000000，虽然这是一个样例程序，但是频繁加锁和解锁的操作是非常低效的</p><p><a href="https://imgtu.com/i/7uWvVA"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uWvVA.png"                      alt="7uWvVA.png"                ></a></p><p>这样会完全打破线程的并发执行</p><p>其实我们完全可以在线程中创建一个临时变量做计算，然后再将最终的结果累加到全局的共享变量中，这样只有最后一个操作需要同步，而线程的主体仍能并发地执行，另外在使用锁的时候需要格外小心，<strong>多个锁的嵌套使用很可能导致线程的死锁(deadlock)现象</strong></p><p>比如这里有两个线程和两把锁</p><p><a href="https://imgtu.com/i/7uhg0J"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uhg0J.png"                      alt="7uhg0J.png"                ></a></p><p>线程1先获取锁1再获取锁2，线程2刚好相反，先获取锁2在获取锁1，如果这俩个线程同时运行，恰好线程q先获取了锁1，然后线程2获取了锁2，然后线程1继续执行，由于锁2被线程2占用，所以线程1会被阻塞，同时由于锁1被线程1占用，所以线程2也会被阻塞</p><p><a href="https://imgtu.com/i/7u5Zad"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u5Zad.png"                      alt="7u5Zad.png"                ></a></p><p>于是线程1和线程2同时被阻塞，也就造成了线程的死锁，这里关键的问题在于上锁的顺序，如果我们让所有线程都按照同样的顺序上锁，其实是可以避免这种情况的，不过实际情况肯恩远比这个复杂，每个线程会用到不同的锁，并且加锁和解锁的操作分散在代码的各个角落，所以另一种做法是，干脆就用单个锁来保护所有的共享资源</p><p><a href="https://imgtu.com/i/7uoWDO"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uoWDO.png"                      alt="7uoWDO.png"                ></a></p><p>并且仅仅在访问资源的时候再去上锁，虽然这么做会损失掉一部分线程的并发性(concurrency)，但好处在于程序的逻辑会更容易维护</p><p>讲到这里，我们顺便提一下部分语言支持的atomic语法修饰，这是一种不使用锁(如果硬件支持)但依然能够解决资源竞争的方法，比如像之前简单的加减操作，在机器内部会直接翻译成硬件支持的原子操作</p><p><a href="https://imgtu.com/i/7u7Elt"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u7Elt.png"                      alt="7u7Elt.png"                ></a></p><p><a href="https://imgtu.com/i/7u7MkQ"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7u7MkQ.png"                      alt="7u7MkQ.png"                ></a></p><p>也就说指令已经是不可拆分的最小步骤，因此不需要同步，它的效率通常比使用锁更高</p><p>另外建立在锁之上，线程中还有其它更复杂、更高级的同步机制，比如信号量、条件变量等等，虽然它们也可以用来保护共享资源，但更主要的用途是在线程中传递信号(signaling)，比如使用条件变量，你可以让线程进入等待，直到某个条件成立后再继续执行，这个条件可能是网络资源被成功加载，或者某项数据准备完毕等等</p><p><a href="https://imgtu.com/i/7uH4VU"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uH4VU.png"                      alt="7uH4VU.png"                ></a></p><p>而信号量则更加灵活一点，你可以先让所有的线程进行等待，但在同一时间内，只让特定数量的线程被唤醒</p><p><a href="https://imgtu.com/i/7ubCRA"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7ubCRA.png"                      alt="7ubCRA.png"                ></a></p><p>在后面我将再向大家详细解释信号量和条件变量的工作原理，因为它们很容易和锁混淆，但实际用途却完全不一样</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用线程，我们可以并发地在各个CPU核心上执行任务，最大化CPU的利用率，但线程也可能导致各种奇怪的资源竞争问题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgtu.com/i/7uaCgP&quot;&gt;&lt;img  
                     lazyload</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>免费的内网穿透工具推荐(win)</title>
    <link href="http://example.com/2022/01/12/%E5%85%8D%E8%B4%B9%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90(win)/"/>
    <id>http://example.com/2022/01/12/%E5%85%8D%E8%B4%B9%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90(win)/</id>
    <published>2022-01-12T01:39:30.000Z</published>
    <updated>2022-01-12T01:40:02.037Z</updated>
    
    <content type="html"><![CDATA[<p>此内容参考自今日头条:<a class="link"   href="https://www.toutiao.com/a7028937143393206815/?log_from=27e046c60a8e6_1641951433723" >https://www.toutiao.com/a7028937143393206815/?log_from=27e046c60a8e6_1641951433723<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此内容参考自今日头条:&lt;a class=&quot;link&quot;   href=&quot;https://www.toutiao.com/a7028937143393206815/?log_from=27e046c60a8e6_1641951433723&quot; &gt;https://www.touti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机操作系统基础笔记</title>
    <link href="http://example.com/2022/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-12T01:34:30.000Z</published>
    <updated>2022-01-12T01:35:15.406Z</updated>
    
    <content type="html"><![CDATA[<p>此内容参考自今日头条:<a class="link"   href="https://www.toutiao.com/a7051472133389713933/?log_from=f0ef8adb57f57_1641951133601" >https://www.toutiao.com/a7051472133389713933/?log_from=f0ef8adb57f57_1641951133601<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此内容参考自今日头条:&lt;a class=&quot;link&quot;   href=&quot;https://www.toutiao.com/a7051472133389713933/?log_from=f0ef8adb57f57_1641951133601&quot; &gt;https://www.touti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP/IP网络通信之Socket编程入门</title>
    <link href="http://example.com/2022/01/11/TCPIP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BSocket%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/11/TCPIP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B9%8BSocket%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-11T14:48:30.000Z</published>
    <updated>2022-01-12T06:25:11.031Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，在这里我会为大家讲解socket的基本工作原理，并用它来实现一个简单的服务器，客户端通信</p><p>socket是一套用于不同主机间通信的API，它工作在我们的TCP/IP协议栈上，它的应用无处不在，比如你的手机应用、用于服务器管理的ssh客户端</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_22-53-29.2bfd5buhh5hc.webp"                      alt="Snipaste_2022-01-11_22-53-29"                ></p><p>全都是基于socket实现的，要通过socket与不同主机建立通信，我们只需要指定主机的IP地址和一个端口号</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_22-54-55.18p7ojt6zqyo.webp"                      alt="Snipaste_2022-01-11_22-54-55"                ></p><p>显而易见，IP地址用于唯一标识你的网络设备，那我们为甚需要额外指定一个端口号呢</p><p>如果没有端口号，操作系统则没有办法区分数据到底应该发送到哪一个应用上</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_22-57-27.7d4bueurw3o0.webp"                      alt="Snipaste_2022-01-11_22-57-27"                ></p><p>因此端口主要用于区分主机上的不同应用</p><p>通过socket我们可以建立一条用于不同主机，不同应用之间的虚拟数据通道</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_23-00-47.48fpktp2l5k0.webp"                      alt="Snipaste_2022-01-11_23-00-47"                ></p><p>并且它是点对点(应用对应用)的</p><p>一个形象的比喻是将一条数据线连接在不同应用的插槽上，这也是socket这个名字的由来</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_23-03-17.1rqbqej8xhcw.webp"                      alt="Snipaste_2022-01-11_23-03-17"                ></p><p>这里不得不吐槽下socket的中文翻译”套接字”到底是什么鬼</p><p>我们经常用到的socket有两种类型，名字你们一定听过，TCP和UDP，TCP是我们今天要讲的重点，它主要有两个特点，首先TCP协议是可靠的，它的底层会自动检测并回传丢失的数据包，因此对调用者来说，你发送的数据，对方一定会接收到</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-11_23-07-19.7jvtwc0mkf80.webp"                      alt="Snipaste_2022-01-11_23-07-19"                ></p><p>其次，发送和接受到的数据顺序是完全一样的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-12_09-50-16.4y27wtj5op80.webp"                      alt="Snipaste_2022-01-12_09-50-16"                ></p><p>比如你发送了一串字符，对方就一定会原封不动地收到同一份字符串，这也是为什么大家说TCP是基于“数据流”的协议</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-12_09-52-21.534a2i9o3es0.webp"                      alt="Snipaste_2022-01-12_09-52-21"                ></p><p>另外需要注意的是，TCP要求收发数据的双方扮演不同的角色:服务器和客户端，服务器会被动等待客户端的连接，它自己不会主动发起请求</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-12_09-54-44.3siqy0r782s0.webp"                      alt="Snipaste_2022-01-12_09-54-44"                ></p><p>与TCP相反UDP正如它的名字，以报文(Datagram)为单位来收发数据，并且UDP不会自动回传丢失的数据包，因此不保证数据一定能被对方接收到</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-12_09-58-03.48taqwynis20.webp"                      alt="Snipaste_2022-01-12_09-58-03"                ></p><p>正是因为缺少了这些检查，UDP通常具有更低的延迟并占用更少的系统资源，它也更适合像视频通话，这种实时性要求较高的应用</p><p>下面我以Python为例来讲解socket编程的部分，但其实你可以完全使用自己喜欢的编程语言，几乎所有的编程语言都支持socket，除了语法不同，它们的用法都是完全一致的，首先我们来创建一个简单的服务器，这个服务器只做一件事，就是将接受到的消息原封不动地发送回去，</p><p>第一行我们导入socket这个库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-12_10-03-50.nfcz13yz6j4.webp"                      alt="Snipaste_2022-01-12_10-03-50"                ></p><p>然后我们调用socket中的socket()来创建一个socket s</p><p>with是Python中的一个语法糖，它单纯代表当代码离开with块的时候自动调用s.close()来销毁这个socket</p><p><a href="https://imgtu.com/i/7nDGPH"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nDGPH.png"                      alt="7nDGPH.png"                ></a></p><p>这里我们需要指定两个参数，第一个参数大家直接填写AF_INEF即可</p><p><a href="https://imgtu.com/i/7nrmFg"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nrmFg.png"                      alt="7nrmFg.png"                ></a></p><p>这个代表我们使用的是IPV4的地址家族(address family)</p><p>第二个参数，SOCK_STREAM代表我们使用的是TCP协议，这里的STREAM也正是代表TCP是个“流式”协议，接下里爱的bind()将我们创建的这个socket关联到我们主机的某一个网卡(又:网络接口/network interface)和端口上，网卡我们可以通过IP地址指定，这里我使用的是0.0.0.0这个特殊的地址，它单纯代表你主机上的任意网卡都可以使用socket进行通信</p><p><a href="https://imgtu.com/i/7nsCAU"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nsCAU.png"                      alt="7nsCAU.png"                ></a></p><p>接下来的listen()将socket置为监听状态，并等待客户端的连接，在下面的accept()会接受来自任意客户端的连接，并返回一个新的socket c，以及客户端的IP地址，需要注意的是这个c是一个与之前s不同的socket，socket s主要用于监听，而socket c则用于与连接的客户端进行通信</p><p><a href="https://imgtu.com/i/7ns33d"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7ns33d.png"                      alt="7ns33d.png"                ></a></p><p>接下来的这几行代码，我们首先打印客户端的IP地址，然后是一个循环，这个循环会一直调用recv()接收客户端传来的信息，这里的1024代表一次性接收数据的最大长度1024个字节，然后只要数据不为空，我们就原封不动地将代码回传给客户端</p><p><a href="https://imgtu.com/i/7nyVPg"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nyVPg.png"                      alt="7nyVPg.png"                ></a></p><p>接下来，我们来简单测试一下这个服务器程序</p><p>我们先运行代码</p><p><a href="https://imgtu.com/i/7nIpHH"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nIpHH.png"                      alt="7nIpHH.png"                ></a></p><p>然后新开一个窗口，这里我们会用到一个命令行工具netcat，它是Linux下非常常用的网络测试工具，可以用来读写TCP/UDP的数据，当然在windows下你也可以找到它的替代版nmap</p><p><a href="https://imgtu.com/i/7nI82V"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nI82V.png"                      alt="7nI82V.png"                ></a></p><p>我们可以输入nc，后面直接跟上服务器的IP地址，127.0.0.1是一个回送地址(loopback address)</p><p><a href="https://imgtu.com/i/7nIBP1"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nIBP1.png"                      alt="7nIBP1.png"                ></a></p><p>代表本地计算机，再后面的1234是端口号，我们按下回车，可以看到服务器接收到了一个新连接</p><p><a href="https://imgtu.com/i/7nIRVH"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nIRVH.png"                      alt="7nIRVH.png"                ></a></p><p>这里我们随便输入字符串，服务器也会原封不动地返回回来</p><p><a href="https://imgtu.com/i/7nIbqg"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nIbqg.png"                      alt="7nIbqg.png"                ></a></p><p>这一步也验证了服务器代码是没有问题的</p><p>接下来我们继续看看客户端的程序</p><p>客户端的代码非常简单，这里我们用同样的方法创建一个socket s</p><p><a href="https://imgtu.com/i/7nIzR0"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nIzR0.png"                      alt="7nIzR0.png"                ></a></p><p>与服务器不同的是，这里我们直接调用connect()函数，并传入服务器的IP地址和端口号</p><p><a href="https://imgtu.com/i/7no3od"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7no3od.png"                      alt="7no3od.png"                ></a></p><p>随后我们调用sendall()函数发送一条消息给服务器，需要注意的是，这里的参数是一个字节序列，并不是字符串，所以千万不要忘记这个b，然后我们调用recv()接受服务器的消息，并将结果打印出来</p><p><a href="https://imgtu.com/i/7nTZ7Q"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nTZ7Q.png"                      alt="7nTZ7Q.png"                ></a></p><p>这里我们新开一个窗口，测试一下客户端的代码，可以看到客户端也成功输出了发送的字符串，然后程序退出，以上我们就讲完了基本服务器和客户端的代码实现，不过这里的服务器有个很大的问题，它只能同时处理一个客户端的请求</p><p><a href="https://imgtu.com/i/7nH1wF"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nH1wF.png"                      alt="7nH1wF.png"                ></a></p><p>要并发地与多个客户端进行通信，这里有几种方法</p><p>我们先来看看最简单的，多线程的服务器</p><p>通过创建线程来响应不同客户端的请求</p><p>首先前面bind和listen的部分和之前的代码完全一样，随后我们写一个循环，然后在循环中不停调用accept()接受来自客户端的连接，为了避免程序的阻塞(block)， 我们直接创建一个新的线程，也就是这里的handle_client()函数，并将客户端的socket c和地址传递给这个线程</p><p><a href="https://imgtu.com/i/7nbtAg"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nbtAg.png"                      alt="7nbtAg.png"                ></a></p><p>然后线程中的代码和之前的完全一样</p><p><a href="https://imgtu.com/i/7nbsBT"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nbsBT.png"                      alt="7nbsBT.png"                ></a></p><p>会不停地回传客户点端发送的信息</p><p>最后我们运行服务器代码，然后新开两个窗口，使用之前讲到的nc命令同时与服务器建立连接，可以看到修改后的服务器可以同时完成这两个客户端的请求</p><p><a href="https://imgtu.com/i/7nqA8s"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nqA8s.png"                      alt="7nqA8s.png"                ></a></p><p>多线程显然能帮我们解决多连接并发的问题，不过它也有自身的局限性，由于GIL的存在，Python中的线程其实做不到真正的并发，并且线程自身也会占用额外的系统资源，除了线程之外，我们还可以使用基于事件驱动的seletors来实现多个连接的并发，或者通过asyncio来实现异步的socket代码</p><p>总结一下:<br>实现一个简单的HTTP服务器，HTTP是TCP协议的一个典型应用，也是浏览器与服务器交互的主要方式，通常服务器会监听80端口，然后等待客户端的连接，客户端在连上服务器以后，首先需要指定要访问的资源，然后客户端会提供一系列额外的信息，每一条都是以冒号分隔的键值对</p><p><a href="https://imgtu.com/i/7nLPL6"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nLPL6.png"                      alt="7nLPL6.png"                ></a></p><p>比如里面包括我们的浏览器的版本等待，这一部分也被称作消息的头部(header)，随后是一个空行，再之后是消息的主体(body)(如果有的话)</p><p><a href="https://imgtu.com/i/7nLBwT"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nLBwT.png"                      alt="7nLBwT.png"                ></a></p><p>服务器在收到消息后，会以同样的格式来响应客户端的请求，首先第一行是一个状态行(status line)，里面包含一个状态码，比如200代表请求成功，404代表请求的资源不存在等等，接着同样是一系列键值对，里面包含了请求资源的类型，服务器信息等等</p><p><a href="https://imgtu.com/i/7nOVBV"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nOVBV.png"                      alt="7nOVBV.png"                ></a></p><p>再后面是一个空行，最后紧跟消息的主体(body)(如果有的话)</p><p><a href="https://imgtu.com/i/7nOQ39"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nOQ39.png"                      alt="7nOQ39.png"                ></a></p><p>在了解了HTTP的基本原理之后，我们可以修改之前的代码来实现这个服务器，首先在handle_client中，我们读取客户端发来的消息，然后我们将消息拆分成一行一行的字符串，存放在header这个列表中，需要注意的是，HTTP标准中定义的换行符是“回车+换行”(CRLF)，这也是我这里用”\r\n”来进行字符串分割的原因，接着我们提取出请求的文件名，和一般的web服务器一样，如果客户请求的是根路径，我们则直接返回index.html</p><p><a href="https://imgtu.com/i/7nOoD0"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7nOoD0.png"                      alt="7nOoD0.png"                ></a></p><p>随后我们读取文件内容，并返回一个状态号为200的消息</p><p><a href="https://imgtu.com/i/7uMyNT"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uMyNT.png"                      alt="7uMyNT.png"                ></a></p><p>如果请求的文件不存在则直接返回404</p><p><a href="https://imgtu.com/i/7ulYlQ"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7ulYlQ.png"                      alt="7ulYlQ.png"                ></a></p><p>最后我们运行代码，并在浏览器中输入本机的IP，可以看到这里成功显示了我本地创建的html测试文件</p><p><a href="https://imgtu.com/i/7uQzQJ"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/01/12/7uQzQJ.png"                      alt="7uQzQJ.png"                ></a></p><p>如果我们去访问其他不存在的文件，则会收到一个错误信息</p><p>这里说一句题外话，其实Python的标准库里已经实现了一个简易的HTTP服务器，它主要用在开发和测试中，调用起来也很方便，大家可以直接输入这个命令使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server <span class="number">8000</span></span><br></pre></td></tr></table></figure><p>最后这里附上代码</p><p>socket_test_server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">s.bind((<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">1235</span>))</span><br><span class="line">s.listen()</span><br><span class="line">c, addr = s.accept()</span><br><span class="line"><span class="keyword">with</span> c:</span><br><span class="line"><span class="built_in">print</span>(addr, <span class="string">&quot;connected.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">data = c.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">c.sendall(data)</span><br></pre></td></tr></table></figure><p>socket_test_client.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">s.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1235</span>))</span><br><span class="line">s.sendall(<span class="string">b&quot;hello lhj&quot;</span>)</span><br><span class="line">data = s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Received&quot;</span>, <span class="built_in">repr</span>(data))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家好，在这里我会为大家讲解socket的基本工作原理，并用它来实现一个简单的服务器，客户端通信&lt;/p&gt;
&lt;p&gt;socket是一套用于不同主机间通信的API，它工作在我们的TCP/IP协议栈上，它的应用无处不在，比如你的手机应用、用于服务器管理的ssh客户端&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一个10分钟的numpy入门教程</title>
    <link href="http://example.com/2022/01/11/%E4%B8%80%E4%B8%AA10%E5%88%86%E9%92%9F%E7%9A%84numpy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/01/11/%E4%B8%80%E4%B8%AA10%E5%88%86%E9%92%9F%E7%9A%84numpy%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</id>
    <published>2022-01-11T08:54:30.000Z</published>
    <updated>2022-01-11T10:46:18.262Z</updated>
    
    <content type="html"><![CDATA[<p>如果你打算在Python中做数据分析、科学运算、数据处理，那你多少会用到numpy这个库，当然你肯定还听过pandas、scipy、PIL、amtplolib等等</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_16-57-09.5ceyiooc2ds0.webp"                      alt="Snipaste_2022-01-11_16-57-09"                ></p><p>这些都是科学运算中非常常用的库，不过这些不是我们现在讲的重点，下面我们来看看numpy</p><p>numpy为我们提供了一个特殊的数组对象<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-01-14.1cbvi5n541mo.webp"                      alt="Snipaste_2022-01-11_17-01-14"                ></p><p>我们可以用它表示普通的一维数组</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-01-39.1esvx0b78s8w.webp"                      alt="Snipaste_2022-01-11_17-01-39"                ></p><p>或者二维的矩阵，或者任意维的数据</p><p>并且它可以对数组中的数据进行非常高效的运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-04-48.6g39zwpe3ik0.webp"                      alt="Snipaste_2022-01-11_17-04-48"                ></p><p>比如用作数据统计，图像处理，线性代数，傅里叶变换等等，我们都知道，Python是一个很慢很慢的语言，而numpy之所以能运行这么快的原因，是因为它底层是用C语言实现的目标代码，当然对于任何想要运算的数据，我们也需要预先将它们表示成numpy数组的形式，也就是所谓的向量化，当然如果你希望将运算速度再提升一个数量级，你甚至可以使用你的GPU来对这些数据做并行运算，那么接下来我们就用实例来讲解下numpy的基本使用叭</p><p>numpy中所有的计算都是围绕着数组进行的，因此在运算之前，我们需要将计算的数据表示成数组的形式，我们首先需要导入numpy这个库</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-12-58.zi9xiyf9fk0.webp"                      alt="Snipaste_2022-01-11_17-12-58"                ></p><p>并起一个别名np，然后我们可以用np.array()来创建一个数组</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-14-28.2q2jhsabj5u0.webp"                      alt="Snipaste_2022-01-11_17-14-28"                ></p><p>括号中是数组的初始化数据，当然我们也可以使用np.zeros()创建一个全零的数组</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-15-50.453ael8zi9y0.webp"                      alt="Snipaste_2022-01-11_17-15-50"                ></p><p>这里传入的参数是数组的尺寸，(3, 2)代表一个三行二列的数组，在numpy中，数组可以是一维、二维、甚至是更高维度的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-18-11.65yri3hinhk0.webp"                      alt="Snipaste_2022-01-11_17-18-11"                ></p><p>二维数组可以用于存放矩阵或者表格数据，多维数组通常用来表示更加复杂的数据</p><p>在numpy中，我们会用到shage来获取数组的尺寸，比如这里的3，是数组第一维的尺寸，我们可以理解为行数，2是数组的第二维的尺寸，我们可以理解为列的个数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-21-39.4u9jv1j5c5g0.webp"                      alt="Snipaste_2022-01-11_17-21-39"                ></p><p>类似的，我们可以使用np.ones()创建一个全部是1的数组</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-23-56.2173yd1135ts.webp"                      alt="Snipaste_2022-01-11_17-23-56"                ></p><p>另外我们可以使用np.arange()创建一个递增或递减的数列</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-24-56.1hlws78qq4kg.webp"                      alt="Snipaste_2022-01-11_17-24-56"                ></p><p>类似于Python的range</p><p>np.linspace()会返回介于某个区间等间距分布的数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-26-35.1mw55gpr5zcw.webp"                      alt="Snipaste_2022-01-11_17-26-35"                ></p><p>前面两个是区间范围，第三个参数是输出样本的总数</p><p>另外我们还可以通过np.random.rand(2, 4)生成一个随机的数组，</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-28-52.1dgu3n9e2x8g.webp"                      alt="Snipaste_2022-01-11_17-28-52"                ></p><p>在numpy中，数组默认的数据类型是64位的浮点数，不过我们可以在创建数组时，通过dtype指定其他的数据类型</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-30-55.w1pvp6l81ds.webp"                      alt="Snipaste_2022-01-11_17-30-55"                ></p><p>对于现有的数组，我们也可以通过satype()来转换数据类型</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-33-36.633ytxp40ls0.webp"                      alt="Snipaste_2022-01-11_17-33-36"                ></p><p>在numpy中我们可以轻松地对数组进行常见的数学运算</p><p>两个相同尺寸的数组可以直接进行四则运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-35-41.4g3wh1slfna0.webp"                      alt="Snipaste_2022-01-11_17-35-41"                ></p><p>他会将数组同位置的元素进行加减乘除</p><p>在乘法运算中还有一个np.dot()，他会对两个向量进行点乘运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-39-10.50h9fhfwy1o0.webp"                      alt="Snipaste_2022-01-11_17-39-10"                ><br>另一个 与乘法相关的是@符号，它会进行矩阵的乘法运算，等同于np.matmul()函数，而不是将相对应的元素直接相乘</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-42-14.59up4q3nvkg0.webp"                      alt="Snipaste_2022-01-11_17-42-14"                ></p><p>我们还可以使用np.sqrt对所有数依次求平方根</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-43-11.3jw6y4r76oo0.webp"                      alt="Snipaste_2022-01-11_17-43-11"                ></p><p>使用np.sin()，np.cos()进行三角函数运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-44-27.t8lgwbd91r4.webp"                      alt="Snipaste_2022-01-11_17-44-27"                ></p><p>或者np.log()，log.power()进行对数和指数运算等等</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-45-43.1pidfm0trt7k.webp"                      alt="Snipaste_2022-01-11_17-45-43"                ></p><p>当然你也可以将一个numpy数组与单独的一个数做运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-46-36.65qlair1mqc0.webp"                      alt="Snipaste_2022-01-11_17-46-36"                ></p><p>numpy会分别计算各个元素与这个数的乘积，产生一个同尺寸的新数组，这个操作在numpy里面被称作广播</p><p>比较有意思的是，不同尺寸的数组也可以直接做运算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-49-32.25hllfiu7fvk.webp"                      alt="Snipaste_2022-01-11_17-49-32"                ></p><p>在运算之前，numpy会将这两个数组扩展至相同的尺寸，然后再将相同位置的元素相加</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-51-07.3eo83vtonva0.webp"                      alt="Snipaste_2022-01-11_17-51-07"                ></p><p>另外，我们还可以通过min()或者max(),返回数组中最小或者最大的元素</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-54-59.1t9yhooz8lj4.webp"                      alt="Snipaste_2022-01-11_17-54-59"                ></p><p>argmin()和argmax()会返回最小或者最大元素所在的索引</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-56-08.3dnaudluz0o0.webp"                      alt="Snipaste_2022-01-11_17-56-08"                ></p><p>sum会返回所有数据的总和</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-56-57.1nr26ssvus80.webp"                      alt="Snipaste_2022-01-11_17-56-57"                ></p><p>mean()，median()会返回数据的平均值，中位数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-58-17.2uicjrcuwx80.webp"                      alt="Snipaste_2022-01-11_17-58-17"                ></p><p>var()和std()会返回数据的方差和标准方差</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_17-59-34.7e49ntp51mg0.webp"                      alt="Snipaste_2022-01-11_17-59-34"                ></p><p>对于以上提到的函数，如果你的数组是多维数组，你还可以指定一个额外的参数axis，当axis等于0时，它会将每一行中对应的数据相加，axis=0代表第一个维度，也就是行</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-01-57.5vl6w83pzhw0.webp"                      alt="Snipaste_2022-01-11_18-01-57"                ></p><p>以此类推axis=1则代表第二个维度，也就是列</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-03-18.6le3mtsrez40.webp"                      alt="Snipaste_2022-01-11_18-03-18"                ></p><p>如果你想要获取数组中的元素，你可以使用与Python list非常相似的语法，比如你要获取第1行第2列的元素，你可以使用下表0和1，中间以逗号分隔</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-05-29.4843ax66qg40.webp"                      alt="Snipaste_2022-01-11_18-05-29"                ></p><p>另外，我们还可以通过条件筛选出指定的元素，比如在方括号中输入a&lt;3则会返回所有小于3的元素</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-07-11.54wob0rkj940.webp"                      alt="Snipaste_2022-01-11_18-07-11"                ></p><p>我们还可以通过逻辑运算符组合不同的条件，比如下面这个例子将筛选出大于3并且是偶数的数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-08-37.15dvi0o1w4yo.webp"                      alt="Snipaste_2022-01-11_18-08-37"                ></p><p>这里需要注意的是，“与”运算需要用&amp;符号来表示，“或”运算则需要用竖线表示</p><p>如果你要获取的第一行，但是1-2列的数据，你可以使用0:2这种切片的语法，这个和Python的列表是一样的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-12-33.u3ii8ehuxr4.webp"                      alt="Snipaste_2022-01-11_18-12-33"                ></p><p>如果你要获取第一行，但是所有列的元素，你可以单写一个冒号，然后将冒号前后的范围省略掉，当然你也可以直接把整个冒号给省略掉</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-15-12.6zyf6m35l000.webp"                      alt="Snipaste_2022-01-11_18-15-12"                ></p><p>另外我们可以在冒号的后面再加一个冒号，第二个冒号后面可以跟一个跨度，也就是步长</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-16-48.5f5bofbkq2s0.webp"                      alt="Snipaste_2022-01-11_18-16-48"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-17-51.5jb29wxc4pc.webp"                      alt="Snipaste_2022-01-11_18-17-51"                ></p><p>比较有意思的是，这个跨度还可以取负值，我们可以通过复苏的跨度，从右往左逆向返回这个数组，比如在numpy中会经常看到::-1的写法，其实它做的事情就是将数组翻转一下而已</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-20-21.jnz06abr5j4.webp"                      alt="Snipaste_2022-01-11_18-20-21"                ></p><p>当然说了这么多，光看一堆数字确实也不够直观，不如我们来看一下numpy的一个典型应用图片处理，通常我们可以把一张灰度图看作是一个二维的数组， 数组中的每个元素用来表示像素点的亮度值</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-24-06.dd408en2cnk.webp"                      alt="Snipaste_2022-01-11_18-24-06"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-24-51.70zqmk1v12o0.webp"                      alt="Snipaste_2022-01-11_18-24-51"                ></p><p>对于彩色的图片，我们可以用三维数组来表示</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-25-45.vjekczaykkw.webp"                      alt="Snipaste_2022-01-11_18-25-45"                ></p><p>数组中的第三维分别存储了像素点的红绿蓝分量</p><p>我们可以使用pillow这个库来读取图片文件</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-29-12.7kmwowkhqh40.webp"                      alt="Snipaste_2022-01-11_18-29-12"                ></p><p>随后我们可以通过np.array(im)将图片转换成一个numpy数组</p><p>可以看到这个图片一共960行，1280列，并且有红绿蓝3个颜色分量，我们可以通过下表来访问某个像素点的颜色</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-32-59.5wq5hppz2rc0.webp"                      alt="Snipaste_2022-01-11_18-32-59"                ></p><p>也可以通过这种方式单独提取出所有像素点的红色分量</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-33-56.3aemdare9z40.webp"                      alt="Snipaste_2022-01-11_18-33-56"                ></p><p>然后图片就成了这样</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-35-04.whh171cqpow.webp"                      alt="Snipaste_2022-01-11_18-35-04"                ></p><p>我们也可以通过这样的方式将两张图按比例混合在一起，这里需要注意的是，运算的结果是浮点数，为了显示图片，我们需要将图片转换成整型数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-39-14.6j6fyv3ub480.webp"                      alt="Snipaste_2022-01-11_18-39-14"                ><br>另外我们可以利用之前讲到的跨度来对图片进行降采样，如果我们想要翻转图片，我们可以选跨度-1</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-40-45.3sllqow2zw60.webp"                      alt="Snipaste_2022-01-11_18-40-45"                ></p><p>这由于我们指定的是第一个维度，因此图片会上下翻转</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-41-50.6jyb4b5pyu00.webp"                      alt="Snipaste_2022-01-11_18-41-50"                ></p><p>如果我们想要裁剪图片的某一部分，我们可以利用之前讲到的切片</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-43-14.101o8kgqlipc.webp"                      alt="Snipaste_2022-01-11_18-43-14"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-43-54.1iaiyje1gk5c.webp"                      alt="Snipaste_2022-01-11_18-43-54"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220111/Snipaste_2022-01-11_18-44-21.2oxofwlwkjq0.webp"                      alt="Snipaste_2022-01-11_18-44-21"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果你打算在Python中做数据分析、科学运算、数据处理，那你多少会用到numpy这个库，当然你肯定还听过pandas、scipy、PIL、amtplolib等等&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
           </summary>
      
    
    
    
    
  </entry>
  
</feed>
