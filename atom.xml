<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-17T01:31:38.569Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python3网络爬虫开发实战第二版第10章-模拟登陆</title>
    <link href="http://example.com/2022/02/16/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC10%E7%AB%A0-%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/"/>
    <id>http://example.com/2022/02/16/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC10%E7%AB%A0-%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86/</id>
    <published>2022-02-16T08:33:30.000Z</published>
    <updated>2022-02-17T01:31:38.569Z</updated>
    
    <content type="html"><![CDATA[<p>很多情况下，网站的一些数据需要登录后才能查看，如果想要爬取这部分数据的话，就需要实现模拟登录的一些机制</p><p>模拟登录现在主要分为两种模式，一种是基于Session和Cookie的模拟登录，一种是基于JWT(JSON Web Token)的模拟登录</p><p>对于第一种模式，我们已经学习过Session和Cookie，简单来说，打开网页后模拟登录，服务器会返回带有Set-Cookie字段的响应头，客户端会生成相应的Cookie，其中保存着SessionID相关的信息，之后发送给服务器的请求都会携带这个生成的Cookie；服务器接收到请求后，会根据Cookie中保存的SessionID找到对应的Session，同时校验Cookie中的其他信息，如果当前Session是有效的并且校验成功，服务器就判断当前用户已经登录，返回所请求的页面信息；所以这种模式的核心是获取客户端登录后生成的Cookie</p><p>对于第二种模式也是如此，我们可以手动在浏览器中输入用户名和密码，再把Cookie或者JWT复制到代码中来进行请求数据，但这样做明显会增加人工工作量；实现爬虫的目的不就是自动化嘛，所以我们要做的就是用程序来完成这个过程，或者说用程序模拟登录</p><h3 id="模拟登录的基本原理"><a href="#模拟登录的基本原理" class="headerlink" title="模拟登录的基本原理"></a>模拟登录的基本原理</h3><p>很多时候，一些网站的页面或资源需要先登录才能看到，例如GitHub的个人设置页面，如果不登录就无法查看，12306网站的提交订单页面，如果不登录也是无法提交订单，在微博上写了个新内容不登录也是无法发表</p><h4 id="网站登录验证的实现"><a href="#网站登录验证的实现" class="headerlink" title="网站登录验证的实现"></a>网站登录验证的实现</h4><p>要实现模拟登录，首先就得了解网站如何验证登录内容</p><p>登录一般需要两个内容，用户名和密码，也有的网站是填写手机号获取验证码，或者微信扫码从根本上看，这些方式都是把一些可供认证的信息提交给服务器</p><p>就拿用户名和密码来说，用户在一个网页表单里面输入这两个内容，然后点击登录按钮的一瞬间，浏览器客户端会向服务器发送一个登录请求，这个请求里肯定包含刚输入的用户名和密码，这时服务器需要处理这些内容，然后返回给客户端一个类似凭证的东西，有了这个凭证，客户端再去访问某些需要登录才能看的页面时，服务器自然会放行，并返回对应的内容或执行对应的操作</p><p>那么问题来了，这个凭证是怎么生成的，服务器又是怎么校验的呢，答案其实刚刚已经介绍过了，一种是基于Session和Cookie，一种是基于JWT</p><h4 id="基于Session和Cookie"><a href="#基于Session和Cookie" class="headerlink" title="基于Session和Cookie"></a>基于Session和Cookie</h4><p>不同网站对于用户登录状态的实现可能是不同的，但Sesson和Cookie一定是相互配合工作的，下面梳理下:</p><ul><li>Cookie里面可能只保存了SessionID相关的信息，服务器能根据这个信息找到对应的Session；当用户登录后，服务器会在相应的Session里标记一个字段，代表用户已处于登录状态或者其他(如角色或登录时间)，这样一来，用户每次访问网站的时候都带着Cookie，服务器每次都找到对应的Session，然后看一下用户的状态是否为登录状态，在决定返回什么结果或执行什么操作；</li><li>Cookie里直接保存了某些凭证信息；例如用户发起登陆请求，服务器校验通过后，返回给客户端的响应头里面可能带有Set-Cookie字段，里面就包含着类似的凭证的信息，这样客户端会执行设置Cookie的操作，将那些类似凭证的信息保存到Cookie里，以后再访问网站时都携带这Cookie，服务器拿着其中的信息进行检验，自然也能检测登录状态</li></ul><p>以上两种情况几乎能涵盖大部分这种模式的实现，具体的实现逻辑因服务器而异，但Session和Cookie是一定要配合使用的</p><h4 id="基于JWT"><a href="#基于JWT" class="headerlink" title="基于JWT"></a>基于JWT</h4><p>web的开发技术一直在发展，近几年前后端分离的开发模式也越来越火，传统的基于Sesson和Cookie的校验又存在一定的问题，例如服务器需要维护登录用户的Session信息，而且分布式部署也不太方便，不太适合前后端分离的项目，所以JWT技术应运而生</p><p>有了JWT，一些认证就不需要借助Session和Cookie了，服务器也无需维护Session信息，从而减少了开销，只需要有一个校验JWT的功能即可，同时还支持分布式部署和跨语言</p><p>JWT一般是一个经过Base64编码技术加密的字符串，有自己的标准，可以把JWT看成一个三段加密字符串，这三部分分别是Header、Payload、Sinnature</p><ul><li>Header: 申明了JWT的签名算法(如RSA，SHA256等)，还可能包含JWT编号或类型等数据</li><li>Payload: 通常是一些业务需要但是不敏感的信息(如UserID)，另外还有很多默认字段，如JWT签发者、JWT接受者、JWT过期时间等</li><li>Signature: 这就是一个签名，是利用秘钥secret对Hader、Payload的信息进行加密后形成的，这个秘钥保存在服务端，不会轻易泄露；如此以来，如果Payload的信息被串改，服务器就能通过Signature判断出这是非法请求，拒绝提供服务</li></ul><p>登录认证流程也很简单了，用户通过用户名和密码登录，然后服务器生成JWT字段返回给客户端，之后客户每次请求都带着这个JWT，服务器会自动判断其有效情况，如果有效就返回对应的数据；JWT的传递方式有很多种，可以放在请求头中，可以放在URL中，甚至有些网站把它放在Cookie中</p><h4 id="模拟登录"><a href="#模拟登录" class="headerlink" title="模拟登录"></a>模拟登录</h4><h5 id="基于Session和Cookie模拟登录"><a href="#基于Session和Cookie模拟登录" class="headerlink" title="基于Session和Cookie模拟登录"></a>基于Session和Cookie模拟登录</h5><p>如果要用爬虫实现基于Cookie和Session的模拟登录，最主要的是要维护好Cookie的信息</p><ul><li>第一，如果已经在浏览器中登录了自己的账号，那么可以直接把Cookie赋值给爬虫，详细点说就是放在请求头中</li><li>第二，如果想让爬虫完全自动化工作，那么可以直接使用爬虫模拟登录过程，大多数时候，登录过程其实就是Post请求，用爬虫把用户名、密码等信息提交给服务器，服务器返回的响应头里面可能会有Set-Cookie字段，我们只需要把这个字段的内容保存下来即可，所以最主要的是把这个过程中的Cookie维持好，当然，我们可能会遭遇到一些困难，例如登录过程中伴随着各种校验参数，不好直接模拟请求；客户端设置Cookie的过程中是通过JavaScript实现的，所以可能还得仔细分析其中的逻辑，尤其是用requests这样的请求的库进行模拟登录遇到的问题总会是比较多</li><li>可以用一些简单的方式，那就是自动化处理工具了</li></ul><h5 id="基于JWT模拟登录"><a href="#基于JWT模拟登录" class="headerlink" title="基于JWT模拟登录"></a>基于JWT模拟登录</h5><p>基于JWT的模拟登录思路也比较清晰，由于JWT的字符串就是用户访问的凭证，所以模拟登录只需要做到下面几步:</p><ul><li>模拟登录操作，例如拿着用户名和密码信息请求登录接口，获取服务器返回的结果，这个结果中通常包含着JWT信息，将其保存下来即可</li><li>之后发送个给服务器的请求都携带JWT，在JWT不过期的情况下，通常能正常访问和执行操作，携带方式多种多样，因网站而异</li><li>如果JWT过期了，可能需要再次做第一步，重新获取JWT</li></ul><p>当然，模拟登录的过程中肯定会带有一些其他加密参数，需要根据情况而定</p><h4 id="账号池"><a href="#账号池" class="headerlink" title="账号池"></a>账号池</h4><p>如果爬虫要求爬取的数据量比较大或爬取速度比较快，网站又有单账号并发限制或者访问状态检测等反爬虫手段，我们的账号可能就无法访问网站或者面临封号的风险</p><p>这时一般怎么处理呢，可以分流，建立一个账号池，用多个账号随机访问网站或爬取数据，这样能大幅提高爬虫的并发量，降低被封号的风险；例如准备100个账号，然后这100个账号都模拟登录，并保存对应的Cookie或JWT，每次都随机从中选取一个来访问，账号多，所以每个账号被选中的概率就小，也就避免了单账号并发量过大的问题</p><h3 id="基于Session和Cookie的模拟登录爬取实战"><a href="#基于Session和Cookie的模拟登录爬取实战" class="headerlink" title="基于Session和Cookie的模拟登录爬取实战"></a>基于Session和Cookie的模拟登录爬取实战</h3><p>目标网站: <a class="link"   href="https://login2.scrape.center/%EF%BC%8C%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E9%83%BD%E6%98%AFadmin" >https://login2.scrape.center/，用户名和密码都是admin<i class="fas fa-external-link-alt"></i></a></p><p>下面开始分析过程</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>首先我们打开上面提供的目标网站然后F12，我么输入用户名和密码，我们可以看到:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220216/Snipaste_2022-02-16_18-04-31.29ujuruzzsn4.webp"                      alt="Snipaste_2022-02-16_18-04-31"                ></p><p>这里就携带了一个Cookie，这个Cookie一般是有一定有效期的，我们可以直接把它放在Haders中去请求</p><h4 id="reqeust爬取"><a href="#reqeust爬取" class="headerlink" title="reqeust爬取"></a>reqeust爬取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description :</span></span><br><span class="line"><span class="string">@File        : Login-scrape</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/2/16 18:09</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       :</span></span><br><span class="line"><span class="string">@change      :</span></span><br><span class="line"><span class="string">@reason      :</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">login_url = <span class="string">&quot;https://login2.scrape.center/login&quot;</span></span><br><span class="line">index_url = <span class="string">&quot;https://login2.scrape.center/page/2&quot;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于requests模块有自动处理重定向的能力，所以要加上allow_redirects=False</span></span><br><span class="line">res = requests.post(</span><br><span class="line">    login_url,</span><br><span class="line">    headers=headers,</span><br><span class="line">    data=data,</span><br><span class="line">    allow_redirects=<span class="literal">False</span>)</span><br><span class="line">cookies = res.cookies</span><br><span class="line">resp = requests.get(index_url, headers=headers, cookies=cookies)</span><br><span class="line"><span class="built_in">print</span>(resp.url)</span><br></pre></td></tr></table></figure><p>最后打印的url如果和index_url一致这说明成功登录了，但是这样我们发现比较繁琐，每次请求都需要处理并传递一次Cookie，其实我们可以直接借助requests内置的Session对象帮我们自动处理Cookie，使用Session对像之后，requests会自动保存每次请求后设置的Cookie，并在下次请求的时候携带上它，这样就方便了，把上面的代码简化下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description :</span></span><br><span class="line"><span class="string">@File        : Login-scrape</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/2/16 18:09</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       :</span></span><br><span class="line"><span class="string">@change      :</span></span><br><span class="line"><span class="string">@reason      :</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line">login_url = <span class="string">&quot;https://login2.scrape.center/login&quot;</span></span><br><span class="line">index_url = <span class="string">&quot;https://login2.scrape.center/page/2&quot;</span></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于requests模块有自动处理重定向的能力，所以要加上allow_redirects=False</span></span><br><span class="line">res = session.post(</span><br><span class="line">    login_url,</span><br><span class="line">    headers=headers,</span><br><span class="line">    data=data)</span><br><span class="line"><span class="comment"># cookies = res.cookies</span></span><br><span class="line">resp = session.get(index_url, headers=headers)</span><br><span class="line"><span class="built_in">print</span>(resp.url)</span><br></pre></td></tr></table></figure><h4 id="Selenium爬取"><a href="#Selenium爬取" class="headerlink" title="Selenium爬取"></a>Selenium爬取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://login2.scrape.cuiqingcai.com/&#x27;</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">&#x27;/page/1&#x27;</span>)</span><br><span class="line">USERNAME = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(BASE_URL)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&#x27;input[name=&quot;username&quot;]&#x27;</span>).send_keys(USERNAME)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&#x27;input[name=&quot;password&quot;]&#x27;</span>).send_keys(PASSWORD)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">&#x27;input[type=&quot;submit&quot;]&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get cookies from selenium</span></span><br><span class="line">cookies = browser.get_cookies()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Cookies&#x27;</span>, cookies)</span><br><span class="line">browser.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># set cookies to requests</span></span><br><span class="line">session = requests.Session()</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">    session.cookies.<span class="built_in">set</span>(cookie[<span class="string">&#x27;name&#x27;</span>], cookie[<span class="string">&#x27;value&#x27;</span>])</span><br><span class="line"></span><br><span class="line">response_index = session.get(INDEX_URL)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response Status&#x27;</span>, response_index.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response URL&#x27;</span>, response_index.url)</span><br></pre></td></tr></table></figure><h3 id="基于JWT的模拟登录爬取实战"><a href="#基于JWT的模拟登录爬取实战" class="headerlink" title="基于JWT的模拟登录爬取实战"></a>基于JWT的模拟登录爬取实战</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>目标网站: <a class="link"   href="https://login3.scrape.center/" >https://login3.scrape.center/<i class="fas fa-external-link-alt"></i></a></p><p>用户名和密码同样是admin</p><p>我们打开这个网站然后看下后台向它发送了什么数据:</p><p><a href="https://imgtu.com/i/HhOUj1"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2022/02/16/HhOUj1.png"                      alt="HhOUj1.png"                ></a></p><p>我们可以看到服务器向客户端响应了一段字符串</p><p>然后我们再往后点击几页，我们会发现在请求头中正好有个<strong>Authorization</strong>字段包含了前面服务器向客户端响应的字符串，这就说明那就是我们在发送请求的时候需要夹带的数据</p><p>那么整个思路就变得简单了:</p><ul><li>模拟登录请求，带上必要的登录信息，获取返回的JWT</li><li>之后发送请求在请求头里面加上<strong>Authorization</strong>字段，值就是JWT对应的内容</li></ul><p>代码实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://login3.scrape.cuiqingcai.com/&#x27;</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">&#x27;/api/login&#x27;</span>)</span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">&#x27;/api/book&#x27;</span>)</span><br><span class="line">USERNAME = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">PASSWORD = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"></span><br><span class="line">response_login = requests.post(LOGIN_URL, json=&#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: USERNAME,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: PASSWORD</span><br><span class="line">&#125;)</span><br><span class="line">data = response_login.json()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response JSON&#x27;</span>, data)</span><br><span class="line">jwt = data.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;JWT&#x27;</span>, jwt)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">f&#x27;jwt <span class="subst">&#123;jwt&#125;</span>&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response_index = requests.get(INDEX_URL, params=&#123;</span><br><span class="line">    <span class="string">&#x27;limit&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;offset&#x27;</span>: <span class="number">0</span></span><br><span class="line">&#125;, headers=headers)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response Status&#x27;</span>, response_index.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response URL&#x27;</span>, response_index.url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response Data&#x27;</span>, response_index.json())</span><br></pre></td></tr></table></figure><h3 id="大规模账号池的搭建"><a href="#大规模账号池的搭建" class="headerlink" title="大规模账号池的搭建"></a>大规模账号池的搭建</h3><p>见P385</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很多情况下，网站的一些数据需要登录后才能查看，如果想要爬取这部分数据的话，就需要实现模拟登录的一些机制&lt;/p&gt;
&lt;p&gt;模拟登录现在主要分为两种模式，一种是基于Session和Cookie的模拟登录，一种是基于JWT(JSON Web Token)的模拟登录&lt;/p&gt;
&lt;p&gt;对</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python3网络爬虫开发实战第二版第9章-代理的使用</title>
    <link href="http://example.com/2022/02/15/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC9%E7%AB%A0-%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/02/15/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC9%E7%AB%A0-%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-15T08:52:30.000Z</published>
    <updated>2022-02-16T08:10:30.077Z</updated>
    
    <content type="html"><![CDATA[<p>在使用爬虫的过程中经常会遇到这样的情况，爬虫最初还可以正常运行，正常爬取数据，一切看起来都是那么美好，然而一杯茶的功夫，就可能出现了错误，比如返回403或者啥的，出现这些现象的原因是网站采取了一些反爬措施，例如服务器会检测某个IP在单位时间内的请求次数，如果这个次数超过了指定的阈值，就直接拒绝服务，并返回一些错误信息，这种情况就称为封IP，既然服务器检测的是单位时间内某个IP在单位时间的请求次数，那么借助某种方式把IP伪装起来，让服务器识别不出是由我们本机发起的请求不就可以了</p><h3 id="代理的设置"><a href="#代理的设置" class="headerlink" title="代理的设置"></a>代理的设置</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>代理的基本原理可移步第一章，这样有助于更好地理解和学习以下内容；另外，需要先获取一个可用代理，代理就是IP地址和端口的组合，格式是<code>&lt;ip&gt;:&lt;port&gt;</code>；如果代理需要访问认证，则还需要额外的用户名和密码两个信息</p><p>那么如何获取一个可用代理呢，使用搜索引擎搜索代理两字，会返回许多代理服务网站，网站上提供了很多免费或付费代理，例如快代理的免费HTTP代理: https:<a class="link"   href="http://www.kuaidaili.com/free/%E5%B0%B1%E6%8F%90%E4%BE%9B%E4%BA%86%E5%BE%88%E5%A4%9A%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%EF%BC%8C%E4%BD%86%E5%9C%A8%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%E8%BF%99%E4%BA%9B%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%E5%B9%B6%E4%B8%80%E5%AE%9A%E7%A8%B3%E5%AE%9A%EF%BC%8C%E6%89%80%E4%BB%A5%E6%AF%94%E8%BE%83%E9%9D%A0%E8%B0%B1%E7%9A%84%E8%BF%98%E6%98%AF%E8%B4%AD%E4%B9%B0%E4%BB%98%E8%B4%B9%E4%BB%A3%E7%90%86" >www.kuaidaili.com/free/就提供了很多免费代理，但在大多数情况下这些免费代理并一定稳定，所以比较靠谱的还是购买付费代理<i class="fas fa-external-link-alt"></i></a></p><p>除了购买付费代理，也可以在本机配置一些代理软件，具体的配制方法可以参考<a class="link"   href="https://setup.scrape.center/proxy-client" >https://setup.scrape.center/proxy-client<i class="fas fa-external-link-alt"></i></a></p><p>以下示例都是基于本机代理软件</p><h4 id="urllib的代理设置"><a href="#urllib的代理设置" class="headerlink" title="urllib的代理设置"></a>urllib的代理设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler, build_opener</span><br><span class="line"></span><br><span class="line">proxy = <span class="string">&#x27;127.0.0.1:7890&#x27;</span></span><br><span class="line">proxy_handler = ProxyHandler(&#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://&#x27;</span> + proxy,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://&#x27;</span> + proxy</span><br><span class="line">&#125;)</span><br><span class="line">opener = build_opener(proxy_handler)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = opener.<span class="built_in">open</span>(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></table></figure><p>这里需要借助ProxyHandler对象设置代理，参数是字典类型的数据，键名是协议类型，键值是代理地址(注意，此处的代理地址前面需要加上协议，即http://或者https://)，当请求链接使用的是HTTP协议时，使用http键名对应的代理地址， 反之就使用https</p><p>如果遇到需要认证的代理，可以使用如下方式设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> ProxyHandler, build_opener</span><br><span class="line"></span><br><span class="line">proxy = <span class="string">&#x27;username:password@127.0.0.1:7890&#x27;</span></span><br><span class="line">proxy_handler = ProxyHandler(&#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://&#x27;</span> + proxy,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://&#x27;</span> + proxy</span><br><span class="line">&#125;)</span><br><span class="line">opener = build_opener(proxy_handler)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = opener.<span class="built_in">open</span>(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></table></figure><p>如果代理是SOCKS代理，那么可以使用如下方式设置代理，需要注意要在本机7891端口运行一个SOCKS代理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description : </span></span><br><span class="line"><span class="string">@File        : urllib_socks</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/2/15 17:25</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       : </span></span><br><span class="line"><span class="string">@change      : </span></span><br><span class="line"><span class="string">@reason      : </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socks</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib.error <span class="keyword">import</span> URLError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">socks.set_default_proxy(socks.SOCKS5, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">7891</span>)</span><br><span class="line">socket.socket = socks.socksocket</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">response = request.urlopen(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> URLError <span class="keyword">as</span> e:</span><br><span class="line"><span class="built_in">print</span>(e.reason)</span><br></pre></td></tr></table></figure><h4 id="requests的代理设置"><a href="#requests的代理设置" class="headerlink" title="requests的代理设置"></a>requests的代理设置</h4><p>对于requests来说，代理设置非常简单，只需要传入prosies参数即可，这里以我本机的代理为例，看一下requests的HTTP代理配置，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxy = <span class="string">&#x27;127.0.0.1:7890&#x27;</span></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://&#x27;</span> + proxy,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://&#x27;</span> + proxy,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>, proxies=proxies)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>, e.args)</span><br></pre></td></tr></table></figure><p>这里同样使用httpbin这个测试站点，这个返回的是一个json格式的数据，如果运行结果中的origin字段如果是代理服务器的IP，则证明代理已经设置成功</p><p>如果代理类型是SOCKS，可以使用如下方式设置代理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxy = <span class="string">&#x27;127.0.0.1:7891&#x27;</span></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;socks5://&#x27;</span> + proxy,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;socks5://&#x27;</span> + proxy</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>, proxies=proxies)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>, e.args)</span><br></pre></td></tr></table></figure><p>要运行以上代码我们要额外安装一个包requests[socks]，相关命令如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="string">&quot;requests[socks]&quot;</span></span><br></pre></td></tr></table></figure><p>另外还有一种设置SOCKS代理的方法，即使用socks模块，需要安装socks库，这种设置方式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> socks</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">socks.set_default_proxy(socks.SOCKS5, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">7891</span>)</span><br><span class="line">socket.socket = socks.socksocket</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="keyword">except</span> requests.exceptions.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>, e.args)</span><br></pre></td></tr></table></figure><h4 id="httpx代理设置"><a href="#httpx代理设置" class="headerlink" title="httpx代理设置"></a>httpx代理设置</h4><p>httpx的用法本身就和requests的非常相似，所以也是通过proxies参数设置代理，不过也有不同，就是proxies参数的键名不能再是http或https，而需要改为http://或者https://</p><p>设置HTTP代理的方式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line">proxy = <span class="string">&#x27;127.0.0.1:7890&#x27;</span></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http://&#x27;</span>: <span class="string">&#x27;http://&#x27;</span> + proxy,</span><br><span class="line">    <span class="string">&#x27;https://&#x27;</span>: <span class="string">&#x27;http://&#x27;</span> + proxy,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> httpx.Client(proxies=proxies) <span class="keyword">as</span> client:</span><br><span class="line">    response = client.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p>对于需要认证的代理，也是在代理地址前加上用户名和密码，在使用的时候替换username和password字段:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy = <span class="string">&#x27;username:password@127.0.0.1:7890&#x27;</span></span><br></pre></td></tr></table></figure><p>对于SOCKS代理，需要安装httpx-socks[asyncio]库，安装方式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="string">&#x27;httpx-socks[asyncio]&#x27;</span></span><br></pre></td></tr></table></figure><p>与此同时需要设置同步模式或异步模式，同步模式的设置方式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">from</span> httpx_socks <span class="keyword">import</span> SyncProxyTransport</span><br><span class="line"></span><br><span class="line">transport = SyncProxyTransport.from_url(</span><br><span class="line">    <span class="string">&#x27;socks5://127.0.0.1:7891&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> httpx.Client(transport=transport) <span class="keyword">as</span> client:</span><br><span class="line">    response = client.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure><p>异步模式的设置方式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> httpx_socks <span class="keyword">import</span> AsyncProxyTransport</span><br><span class="line"></span><br><span class="line">transport = AsyncProxyTransport.from_url(</span><br><span class="line">    <span class="string">&#x27;socks5://127.0.0.1:7891&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient(transport=transport) <span class="keyword">as</span> client:</span><br><span class="line">        response = <span class="keyword">await</span> client.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><h4 id="Selenium的代理设置"><a href="#Selenium的代理设置" class="headerlink" title="Selenium的代理设置"></a>Selenium的代理设置</h4><p>对于无认证的代理设置如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">proxy = <span class="string">&#x27;127.0.0.1:7890&#x27;</span></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&#x27;--proxy-server=http://&#x27;</span> + proxy)</span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line">browser.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.page_source)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>如果代理需要认证，则设置方式相对繁琐点:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">port = <span class="number">7890</span></span><br><span class="line">username = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;bar&#x27;</span></span><br><span class="line"></span><br><span class="line">manifest_json = <span class="string">&quot;&quot;&quot;&#123;&quot;version&quot;:&quot;1.0.0&quot;,&quot;manifest_version&quot;: 2,&quot;name&quot;:&quot;Chrome Proxy&quot;,&quot;permissions&quot;: [&quot;proxy&quot;,&quot;tabs&quot;,&quot;unlimitedStorage&quot;,&quot;storage&quot;,&quot;&lt;all_urls&gt;&quot;,&quot;webRequest&quot;,&quot;webRequestBlocking&quot;],&quot;background&quot;: &#123;&quot;scripts&quot;: [&quot;background.js&quot;]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">background_js = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">var config = &#123;</span></span><br><span class="line"><span class="string">        mode: &quot;fixed_servers&quot;,</span></span><br><span class="line"><span class="string">        rules: &#123;</span></span><br><span class="line"><span class="string">          singleProxy: &#123;</span></span><br><span class="line"><span class="string">            scheme: &quot;http&quot;,</span></span><br><span class="line"><span class="string">            host: &quot;%(ip) s&quot;,</span></span><br><span class="line"><span class="string">            port: %(port) s</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">chrome.proxy.settings.set(&#123;value: config, scope: &quot;regular&quot;&#125;, function() &#123;&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function callbackFn(details) &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">        authCredentials: &#123;username: &quot;%(username) s&quot;,</span></span><br><span class="line"><span class="string">            password: &quot;%(password) s&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">chrome.webRequest.onAuthRequired.addListener(</span></span><br><span class="line"><span class="string">            callbackFn,</span></span><br><span class="line"><span class="string">            &#123;urls: [&quot;&lt;all_urls&gt;&quot;]&#125;,</span></span><br><span class="line"><span class="string">            [&#x27;blocking&#x27;]</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span> % &#123;<span class="string">&#x27;ip&#x27;</span>: ip, <span class="string">&#x27;port&#x27;</span>: port, <span class="string">&#x27;username&#x27;</span>: username, <span class="string">&#x27;password&#x27;</span>: password&#125;</span><br><span class="line"></span><br><span class="line">plugin_file = <span class="string">&#x27;proxy_auth_plugin.zip&#x27;</span></span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(plugin_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> zp:</span><br><span class="line">    zp.writestr(<span class="string">&quot;manifest.json&quot;</span>, manifest_json)</span><br><span class="line">    zp.writestr(<span class="string">&quot;background.js&quot;</span>, background_js)</span><br><span class="line">options = Options()</span><br><span class="line">options.add_argument(<span class="string">&quot;--start-maximized&quot;</span>)</span><br><span class="line">options.add_extension(plugin_file)</span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line">browser.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.page_source)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>这里在本地创建了一个manifest.json配置文件和background.js脚本来设置认证代理，运行代码后本地会生成一个proxy_auth_plugin.zip文件来保存当前的配置，SOCKS代理的配置方式也比较简单，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">proxy = <span class="string">&#x27;127.0.0.1:7891&#x27;</span></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&#x27;--proxy-server=socks5://&#x27;</span> + proxy)</span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line">browser.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.page_source)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><h4 id="aiohttp代理设置"><a href="#aiohttp代理设置" class="headerlink" title="aiohttp代理设置"></a>aiohttp代理设置</h4><p>对于aiohttp，可以通过proxy参数直接设置代理，HTTP设置方式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">proxy = <span class="string">&#x27;http://127.0.0.1:7890&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>, proxy=proxy) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> response.text())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><p>如果代理需要认证，就把代理地址修改下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy = <span class="string">&#x27;http://username:password@127.0.0.1:7890&#x27;</span></span><br></pre></td></tr></table></figure><p>对于SOCKS代理，需要安装一个aiohttp-socks库，安装方式如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aiohttp-socks</span><br></pre></td></tr></table></figure><p>可以借助这个库的ProxyConnector方法来设置SOCKS代理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> aiohttp_socks <span class="keyword">import</span> ProxyConnector, ProxyType</span><br><span class="line"></span><br><span class="line"><span class="comment"># connector = ProxyConnector.from_url(&#x27;socks5://127.0.0.1:7891&#x27;)</span></span><br><span class="line"></span><br><span class="line">connector = ProxyConnector(</span><br><span class="line">    proxy_type=ProxyType.HTTP,</span><br><span class="line">    host=<span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    port=<span class="number">7890</span>,</span><br><span class="line">    <span class="comment"># username=&#x27;user&#x27;,</span></span><br><span class="line">    <span class="comment"># password=&#x27;password&#x27;,</span></span><br><span class="line">    <span class="comment"># rdns=True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(connector=connector) <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> response.text())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><p>另外，aiohttp-socks库还支持SOCKS4代理、HTTP代理以及需要认证的代理，详情可以参见官方介绍</p><h4 id="Pyppeteer的代理设置"><a href="#Pyppeteer的代理设置" class="headerlink" title="Pyppeteer的代理设置"></a>Pyppeteer的代理设置</h4><p>对于Pyppeteer，由于其默认使用的是类似Chrome的Chromium浏览器，因此代理的设置方式和使用Chrome的Selenium一样，都是通过args参数设置HTTP代理的，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line">proxy = <span class="string">&#x27;127.0.0.1:7890&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(&#123;<span class="string">&#x27;args&#x27;</span>: [<span class="string">&#x27;--proxy-server=http://&#x27;</span> + proxy], <span class="string">&#x27;headless&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> page.content())</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><p>SOCKS代理也一样，只需要将协议修改为socks5即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> pyppeteer <span class="keyword">import</span> launch</span><br><span class="line"></span><br><span class="line">proxy = <span class="string">&#x27;127.0.0.1:7891&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    browser = <span class="keyword">await</span> launch(&#123;<span class="string">&#x27;args&#x27;</span>: [<span class="string">&#x27;--proxy-server=socks5://&#x27;</span> + proxy], <span class="string">&#x27;headless&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">    page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">await</span> page.content())</span><br><span class="line">    <span class="keyword">await</span> browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><h4 id="Playwright的代理设置"><a href="#Playwright的代理设置" class="headerlink" title="Playwright的代理设置"></a>Playwright的代理设置</h4><p>HTTP代理设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(headless=<span class="literal">False</span>, proxy=&#123;</span><br><span class="line">        <span class="string">&#x27;server&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:7890&#x27;</span>  <span class="comment"># 填入代理地址</span></span><br><span class="line">    &#125;)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(page.content())</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><p>SOCKS代理设置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(proxy=&#123;</span><br><span class="line">        <span class="string">&#x27;server&#x27;</span>: <span class="string">&#x27;socks5://127.0.0.1:7891&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(page.content())</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><p>需要认证的代理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> playwright.sync_api <span class="keyword">import</span> sync_playwright</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sync_playwright() <span class="keyword">as</span> p:</span><br><span class="line">    browser = p.chromium.launch(proxy=&#123;</span><br><span class="line">        <span class="string">&#x27;server&#x27;</span>: <span class="string">&#x27;http://127.0.0.1:7890&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    page = browser.new_page()</span><br><span class="line">    page.goto(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(page.content())</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><h3 id="代理池的维护"><a href="#代理池的维护" class="headerlink" title="代理池的维护"></a>代理池的维护</h3><p>前面在代理的设置中了解了给各个请求库设置代理的方法，如何实时高效地获取大量可用代理变成了新的问题</p><p>首先，互联网上有大量公开免费的代理，当然我们也可以购买付费代理，但无论是免费代理还是付费代理，都不能保证是可用的，因为自己选用的IP，可能别人也在使用，爬取的还是同样的目标网站，从而被封禁，或者代理服务器突然发生故障、网络繁忙；一旦选用的是一个不可用的代理，势必就会影响爬虫的工作效率，所以我们要提前做筛选，删除掉不可用的代理，只保留可用的代理，那么怎么实现呢？这就需要借助一个叫代理池的东西了，下面我们就来看看如何搭建一个高效易用的代理池:</p><h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h4><p>存储代理池需要借助Redis数据库，因此需要额外安装Redis数据库；整体来讲，需要的环境如下:</p><ul><li><p>安装并成功运行和连接一个Redis数据库，它运行在本地或者远端服务器都行，只要能正常连接就行，安装的方式可以参考: <a class="link"   href="https://setup.scrape.center/redis" >https://setup.scrape.center/redis<i class="fas fa-external-link-alt"></i></a></p></li><li><p>安装好一些必要的库，包括aiohttp、requests、redis-py、pyquery、Flask、loguru等，安装命令如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aiohttp requests redis pyquery flask loguru</span><br></pre></td></tr></table></figure></li></ul><h4 id="代理池四大基本模块"><a href="#代理池四大基本模块" class="headerlink" title="代理池四大基本模块"></a>代理池四大基本模块</h4><p>代理池分为4个基本模块: 存储模块、获取模块、检测模块和接口模块；各模块的功能如下:</p><ul><li>存储模块: 负责存储爬取下来的代理，首先要保证代理不重复，标识代理的可用情况，其次要动态实时地处理每个代理，一种比较高效和方便的存储方式就是Redis的Sorted Set，即有序集合</li><li>获取模块: 负责定时在各大代理网站爬取代理，代理既可以是免费公开的，也可以是付费的，形式都是IP加端口，此模块尽量从不同来源爬取，并且尽量爬取高匿代理，爬取成功后存储到存储模块中</li><li>检测模块: 用负责定时检测存储模块中的代理是否可用，这里需要设置一个检测链接，最好是设置为要爬取的那个网站，这样更具有针对性；对于一个通用型的代理，可以设置为百度等链接；另外，需要标识每一个代理的状态，例如设置分数表示，100分代表可用，分数越少代表越不可用；经检测，如果代理可用，可以将立即设置为满分100，也可以在原分数基础上加1；如果代理不可用，就将分数标识减1，当分数减到一定阈值后，直接从存储模块中删除此代理，这样就可以标识代理的可用情况，在选用的时候也会更加有针对性</li><li>接口模式: 用API提供对外服务的接口。其实我们可以直接连接数据库来获取对应的数据，但这样需要知道数据库的连接信息，并且要配置连接；比较安全和方便的方式是提供一个Web API接口，访问这个接口即可拿到可用代理；另外，由于可用代理可能有多个，所以可以设置一个随机返回某个可用代理的接口，这样就能保证每个可用代理都有机会被获取，实现负载均衡</li></ul><h4 id="代理池的整体架构"><a href="#代理池的整体架构" class="headerlink" title="代理池的整体架构"></a>代理池的整体架构</h4><p>根据上面的描述，代理池的架构可以是是这样的:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220216/Snipaste_2022-02-16_09-40-07.47c4lwlj5sg0.webp"                      alt="Snipaste_2022-02-16_09-40-07"                ></p><p>以上代理池架构分为四个部分，获取模块、存储模块、检测模块、接口模块</p><ul><li>存储模块使用 Redis 的有序集合，用以代理的去重和状态标识，同时它也是中心模块和基础模块，将其他模块串联起来</li><li>获取模块定时从代理网站获取代理，将获取的代理传递给存储模块，保存到数据库</li><li>检测模块定时通过存储模块获取所有代理，并对其进行检测，根据不同的检测结果对代理设置不同的标识</li><li>接口模块通过 Web API 提供服务接口，其内部还是连接存储模块，获取可用的代理</li></ul><h4 id="代理池的实现"><a href="#代理池的实现" class="headerlink" title="代理池的实现"></a>代理池的实现</h4><p>代码量大，源码地址为: <a class="link"   href="https://github.com/Python3WebSpider/ProxyPool" >https://github.com/Python3WebSpider/ProxyPool<i class="fas fa-external-link-alt"></i></a><br>对代码的解释可详见: <a class="link"   href="https://cuiqingcai.com/7048.html" >https://cuiqingcai.com/7048.html<i class="fas fa-external-link-alt"></i></a></p><h3 id="付费代理的使用"><a href="#付费代理的使用" class="headerlink" title="付费代理的使用"></a>付费代理的使用</h3><h4 id="付费代理的分类以及代理商推荐"><a href="#付费代理的分类以及代理商推荐" class="headerlink" title="付费代理的分类以及代理商推荐"></a>付费代理的分类以及代理商推荐</h4><ul><li>一类是代理商提供代理提取接口的付费代理，我们可以通过接口获取这类代理组成的列表，这类代理地址的IP和端口都是可见的，想用哪个就用哪个，灵活操作即可，这类代理一般会按照时间或者量来收费，比较有代表性的的有快代理(<a class="link"   href="https://www.kuaidaili.com/)%E3%80%81%E8%8A%9D%E9%BA%BB%E4%BB%A3%E7%90%86(https://www.zhimaruanjian.com/)%E5%92%8C%E5%A4%9A%E8%B4%9D%E4%BB%A3%E7%90%86(http://www.dobel.cn)%E7%AD%89" >https://www.kuaidaili.com/)、芝麻代理(https://www.zhimaruanjian.com/)和多贝代理(http://www.dobel.cn)等<i class="fas fa-external-link-alt"></i></a></li><li>另一类是代理商搭建了隧道代理的付费代理，我们可以直接把此类代理设置为固定的IP和端口，无需进一步通过请求接口获取随机代理并设置；在这种情况下，我们只需要知道一个固定的代理服务器地址即可，代理商会在背后进一步将我们发出的请求分发给不同的代理服务器并做负载均衡，同时代理商会负责维护背后的整个代理池，因此开发者使用起来更加方便，但这样就无法自由控制设置哪个IP了；比较有代表性的这类代理有阿布云代理(<a class="link"   href="https://www.abuyun.com/)%E3%80%81%E5%BF%AB%E4%BB%A3%E7%90%86(https://www.kuaidaili.com/)%E5%92%8C%E5%A4%9A%E8%B4%9D%E4%BB%A3%E7%90%86(http://www.dobel.cn)%E7%AD%89" >https://www.abuyun.com/)、快代理(https://www.kuaidaili.com/)和多贝代理(http://www.dobel.cn)等<i class="fas fa-external-link-alt"></i></a></li></ul><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>至于如何使用，在对应服务商购买之后应该会有相应的教程</p><p><a class="link"   href="https://cuiqingcai.com/7051.html" >https://cuiqingcai.com/7051.html<i class="fas fa-external-link-alt"></i></a></p><h3 id="ADSL拨号代理的搭建方法"><a href="#ADSL拨号代理的搭建方法" class="headerlink" title="ADSL拨号代理的搭建方法"></a>ADSL拨号代理的搭建方法</h3><p>这个详情见: <a class="link"   href="https://cuiqingcai.com/3443.html" >https://cuiqingcai.com/3443.html<i class="fas fa-external-link-alt"></i></a></p><h3 id="代理反爬案例爬取实战"><a href="#代理反爬案例爬取实战" class="headerlink" title="代理反爬案例爬取实战"></a>代理反爬案例爬取实战</h3><h4 id="实战目标"><a href="#实战目标" class="headerlink" title="实战目标"></a>实战目标</h4><p>以一个IP反爬网站为例进行一次实战演练，该网站限制单个IP</p><p>每五分钟最多访问10次，访问次数超过10，该网站便会封锁该IP，并返回403状态码，10分钟后才解除封锁</p><h4 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先需要准备并正常运行代理池，还需要安装好一些Python库—requests、redis-py、environs、pyquery和loguru，安装命令如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests redis-py environs pyquery loguru</span><br></pre></td></tr></table></figure><h4 id="爬取分析"><a href="#爬取分析" class="headerlink" title="爬取分析"></a>爬取分析</h4><p>目标网站: <a class="link"   href="https://antispider5.scrape.center/%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%BD%91%E9%A1%B5%E6%89%93%E5%BC%80%E5%90%8E%E7%9C%8B%E4%B8%8A%E5%8E%BB%E5%92%8C%E4%B9%8B%E5%89%8D%E6%B2%A1%E6%9C%89%E5%95%A5%E4%B8%8D%E5%90%8C%EF%BC%8C%E4%BD%86%E8%BF%99%E9%87%8C%E7%BD%91%E7%AB%99%E5%A2%9E%E5%8A%A0%E4%BA%86IP%E5%8F%8D%E7%88%AC%E6%9C%BA%E5%88%B6%EF%BC%8C%E9%99%90%E5%88%B6%E5%8D%95%E4%B8%AAIP%E7%9A%84%E8%AE%BF%E9%97%AE%E6%AC%A1%E6%95%B0%EF%BC%8C%E5%9C%A85%E5%88%86%E9%92%9F%E5%86%85%E8%B6%85%E8%BF%87%E5%8D%81%E6%AC%A1%E8%AE%BF%E9%97%AE%E5%B0%B1%E4%BC%9A%E5%B0%81IP%EF%BC%8C%E4%BD%86%E5%A6%82%E6%9E%9C%E6%AD%A4%E6%97%B6%E5%88%87%E6%8D%A2%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%EF%BC%8C%E4%BE%8B%E5%A6%82%E4%BD%BF%E7%94%A8%E6%89%8B%E6%9C%BA%E7%83%AD%E7%82%B9%EF%BC%8C%E6%80%BB%E4%B9%8B%E8%AE%A9%E8%AE%BF%E9%97%AE%E7%9B%AE%E6%A0%87%E7%BD%91%E7%AB%99%E6%89%80%E7%94%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98%EF%BC%8C%E5%B0%B1%E5%8F%88%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E4%BA%86%EF%BC%8C%E4%B9%9F%E6%98%AF%E5%B0%B1%E8%AF%B4%EF%BC%8C%E8%A6%81%E6%83%B3%E5%9C%A8%E7%9F%AD%E6%97%B6%E9%97%B4%E5%86%85%E7%88%AC%E5%8F%96%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E7%9A%84%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%BE%97%E6%9B%B4%E6%8D%A2%E5%A4%9A%E4%B8%AAIP%E8%BF%9B%E8%A1%8C%E7%88%AC%E5%8F%96%EF%BC%8C%E8%BF%99%E5%B0%B1%E5%BE%97%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E4%BA%86" >https://antispider5.scrape.center/，这个网页打开后看上去和之前没有啥不同，但这里网站增加了IP反爬机制，限制单个IP的访问次数，在5分钟内超过十次访问就会封IP，但如果此时切换一个网络环境，例如使用手机热点，总之让访问目标网站所用的IP地址发生改变，就又可以看到页面正常显示了，也是就说，要想在短时间内爬取这个网站的所有数据，得更换多个IP进行爬取，这就得使用代理了<i class="fas fa-external-link-alt"></i></a></p><p>由于我们无法预知某个代理是否能完成一个正常的爬取，因此可能请求成功也可能请求失败，失败原因可能是网站封锁了该代理，或者代理本身失效了；为了保证正常爬取，我们需要添加重试机制，以确保请求失败的时候可以再次爬取，直到成功</p><p>那怎么实现失败后的重试呢，我们可以使用队列，当请求失败时，把对应的请求加入队列里，等待下次被调用，队列的实现方式有很多，本节我们选用Redis实现，简单高效</p><p>本案例的实现步骤如下:</p><ul><li> 构造Redis爬取队列，用队列存取请求</li><li>实现异常处理，把失败的请求重新加入队列</li><li>解析列表页的数据，将爬取详情页和下一页的请求加入队列</li><li>提取详情页的信息</li></ul><h4 id="构造请求对象"><a href="#构造请求对象" class="headerlink" title="构造请求对象"></a>构造请求对象</h4><p>既然要用队列存储请求，就肯定要实现一个请求的数据结构，这个请求需要包含一些必要信息，例如请求链接、请求头、请求方式和超时时间；另外，对于一个请求，需要实现对应的方法来处理它的响应，那么就需要加一个回调函数callback；如果一个请求的失败次数太多，就不会再重新请求了，所以还需要增加失败次数的记录；用这些内容组成一个完整的请求对象并放入队列等待被调度，从队列获取出这个对象后直接执行就行了</p><p>我们可以采用继承requests库中的Request对象的方式实现这个数据结构；requests库中已经存在Request对象，它将请求作为一个整体对象去执行，得到响应后再返回；其实requests库里的get、post等方法都是通过Request对象实现的，我们先来看看Request对象的部分源代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span>(<span class="params">RequestHooksMixin</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,</span></span></span><br><span class="line"><span class="params"><span class="function">            method=<span class="literal">None</span>, url=<span class="literal">None</span>, headers=<span class="literal">None</span>, files=<span class="literal">None</span>, data=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            params=<span class="literal">None</span>, auth=<span class="literal">None</span>, cookies=<span class="literal">None</span>, hooks=<span class="literal">None</span>, json=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Default empty dicts for dict params.</span></span><br><span class="line">        data = [] <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> data</span><br><span class="line">        files = [] <span class="keyword">if</span> files <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> files</span><br><span class="line">        headers = &#123;&#125; <span class="keyword">if</span> headers <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> headers</span><br><span class="line">        params = &#123;&#125; <span class="keyword">if</span> params <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> params</span><br><span class="line">        hooks = &#123;&#125; <span class="keyword">if</span> hooks <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> hooks</span><br><span class="line"></span><br><span class="line">        self.hooks = default_hooks()</span><br><span class="line">        <span class="keyword">for</span> (k, v) <span class="keyword">in</span> <span class="built_in">list</span>(hooks.items()):</span><br><span class="line">            self.register_hook(event=k, hook=v)</span><br><span class="line"></span><br><span class="line">        self.method = method</span><br><span class="line">        self.url = url</span><br><span class="line">        self.headers = headers</span><br><span class="line">        self.files = files</span><br><span class="line">        self.data = data</span><br><span class="line">        self.json = json</span><br><span class="line">        self.params = params</span><br><span class="line">        self.auth = auth</span><br><span class="line">        self.cookies = cookies</span><br></pre></td></tr></table></figure><p>这是 requests 库中 Request 对象的构造方法。这个 Request 已经包含了请求方式、请求链接、请求头这几个属性，但是相比我们需要的还差了几个。我们需要实现一个特定的数据结构，在原先基础上加入上文所提到的额外几个属性。这里我们需要继承 Request 对象重新实现一个请求，将它定义为 MovieRequest，实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TIMEOUT = <span class="number">10</span></span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Request</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieRequest</span>(<span class="params">Request</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url, callback, method=<span class="string">&#x27;GET&#x27;</span>, headers=<span class="literal">None</span>, need_proxy=<span class="literal">False</span>, fail_time=<span class="number">0</span>, timeout=TIMEOUT</span>):</span></span><br><span class="line">        Request.__init__(self, method, url, headers)</span><br><span class="line">        self.callback = callback</span><br><span class="line">        self.fail_time = fail_time</span><br><span class="line">        self.timeout = timeout</span><br></pre></td></tr></table></figure><p>这里我们实现了MovieRequest类，代码保存为request.py，在构造方法中先调用了Request类的构造方法，然后加入了几个额外的参数，分别定义为callback、fail_time和timeout，代表回调函数、失败次数和超时时间</p><p>之后就可以将MovieRequest作为一个整体来执行，各个MovieRequest对象都是独立的，每个请求都有自己的属性；例如，调用请求的callback属性就可以知道应该用什么方法处理这个请求的响应，调用fail_time就可以知道这个请求失败了多少次，继而判断失败次数是否达到阈值，该不该丢弃这个请求</p><h4 id="实现请求队列"><a href="#实现请求队列" class="headerlink" title="实现请求队列"></a>实现请求队列</h4><p>接下来我们就需要构造请求队列，实现请求的存取。存取无非就是两个操作，一个是放，一个是取，所以这里利用 Redis 的 rpush () 和 lpop () 方法即可。 另外还需要注意，存取不能直接存 Request 对象，Redis 里面存的是字符串。所以在存 Request 对象之前我们先把它序列化，取出来的时候再将其反序列化，这个过程可以利用 pickle 模块实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pickle <span class="keyword">import</span> dumps, loads</span><br><span class="line"><span class="keyword">from</span> request <span class="keyword">import</span> MovieRequest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisQueue</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化 Redis&quot;&quot;&quot;</span></span><br><span class="line">        self.db = StrictRedis(host=REDIS_HOST, port=REDIS_PORT, password=REDIS_PASSWORD)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        向队列添加序列化后的 Request</span></span><br><span class="line"><span class="string">        :param request: 请求对象</span></span><br><span class="line"><span class="string">        :param fail_time: 失败次数</span></span><br><span class="line"><span class="string">        :return: 添加结果</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(request, MovieRequest):</span><br><span class="line">            <span class="keyword">return</span> self.db.rpush(REDIS_KEY, dumps(request))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        取出下一个 Request 并反序列化</span></span><br><span class="line"><span class="string">        :return: Request or None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.db.llen(REDIS_KEY):</span><br><span class="line">            <span class="keyword">return</span> loads(self.db.lpop(REDIS_KEY))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.db.llen(REDIS_KEY) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这里实现了一个 RedisQueue类，代码文件保存为db.py，它的 <strong>init</strong>() 构造方法里面初始化了一个 StrictRedis 对象。随后实现了 add () 方法，首先判断 Request 的类型，如果是 MovieRequest，那么就把程序就会用 pickle 的 dumps () 方法序列化，然后再调用 rpush () 方法加入队列。pop () 方法则相反，调用 lpop () 方法将请求从队列取出，然后再用 pickle 的 loads () 方法将其转为 MovieRequest 对象。另外，empty () 方法返回队列是否为空，只需要判断队列长度是否为 0 即可。 在调度的时候，我们只需要新建一个 RedisQueue 对象，然后调用 add () 方法，传入 MovieRequest 对象，即可将 MovieRequest 加入队列，调用 pop () 方法，即可取出下一个 MovieRequest对象，非常简单易用</p><h4 id="修改代理池"><a href="#修改代理池" class="headerlink" title="修改代理池"></a>修改代理池</h4><p>现在我们要找一些可用代理，这里直接使用崔庆才先生所构建的代理池，我已根据<a class="link"   href="https://github.com/Python3WebSpider/ProxyPool" >此链接<i class="fas fa-external-link-alt"></i></a>在云服务器上构建好5555端口的接口，接口地址为: <a class="link"   href="http://175.24.172.64:5555/random%EF%BC%8C%E6%88%91%E4%BB%AC%E5%86%8D%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%94%A8%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%8F%AF%E7%94%A8%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95" >http://175.24.172.64:5555/random，我们再定义一个用来获取可用代理的方法<i class="fas fa-external-link-alt"></i></a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PROXY_ROOT_RUL = <span class="string">&#x27;http://175.24.172.64:5555/random&#x27;</span></span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_proxy</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        get proxy from proxypool</span></span><br><span class="line"><span class="string">        :return: proxy</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        response = requests.get(PROXY_POOL_URL)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            logger.debug(<span class="string">f&#x27;get proxy <span class="subst">&#123;response.text&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br></pre></td></tr></table></figure><p>这里有个小技巧，我们使用loguru日志库里的catch方法作为get_proxy方法的装饰器，这样可以在请求代理池失败的时候输出具体的报错信息，同时又不会中断程序运行，也避免了编写try/catch语句的麻烦，使得代码看起来更简洁</p><h4 id="第一个请求"><a href="#第一个请求" class="headerlink" title="第一个请求"></a>第一个请求</h4><p>一切工作都做好了，现在我们就可以构造第一个请求请求并放在队列里以供调度了，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Session</span><br><span class="line"><span class="keyword">from</span> core.db <span class="keyword">import</span> RedisQueue</span><br><span class="line"><span class="keyword">from</span> core.request <span class="keyword">import</span> MovieRequest</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">&#x27;https://antispider5.scrape.center/&#x27;</span></span><br><span class="line">HEADERS = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>():</span></span><br><span class="line">    session = Session()  <span class="comment"># Session对象</span></span><br><span class="line">    queue = RedisQueue()  <span class="comment"># RedisQueue对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        start request</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.session.headers.update(HEADERS)  <span class="comment"># 全局更新了HEADERS</span></span><br><span class="line">        start_url = BASE_URL</span><br><span class="line">        request = MovieRequest(</span><br><span class="line">            url=start_url, callback=self.parse_index)</span><br><span class="line">        <span class="comment"># schedule first request</span></span><br><span class="line">        self.queue.add(request)  <span class="comment"># 请求入队</span></span><br></pre></td></tr></table></figure><p>这里先定义了两个全局变量，BASE_URL代表目标网站的URL，HEADERS代表请求头，然后定义了Spider类，代码保存为spider.py</p><h4 id="调度请求"><a href="#调度请求" class="headerlink" title="调度请求"></a>调度请求</h4><p>把第一个请求加入队列之后，就可以开始调度执行了；首先从队列中取出这个请求，将它的结果解析出来，生成新的请求加入队列，然后拿出新的请求，将结果解析，再将新生成的请求加入队列，这样循环执行，直到队列中没有请求，代表爬虫结束</p><p>我们在Spider类中添加scheduler方法，实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        schedule request</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.queue.empty():</span><br><span class="line">            request = self.queue.pop()</span><br><span class="line">            callback = request.callback</span><br><span class="line">            logger.debug(<span class="string">f&#x27;executing request <span class="subst">&#123;request.url&#125;</span>&#x27;</span>)</span><br><span class="line">            response = self.request(request)</span><br><span class="line">            logger.debug(<span class="string">f&#x27;response status <span class="subst">&#123;response&#125;</span> of <span class="subst">&#123;request.url&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> response <span class="keyword">or</span> <span class="keyword">not</span> response.status_code <span class="keyword">in</span> VALID_STATUSES:</span><br><span class="line">                self.error(request)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            results = <span class="built_in">list</span>(callback(response))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> results:</span><br><span class="line">                self.error(request)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, MovieRequest):</span><br><span class="line">                    logger.debug(<span class="string">f&#x27;generated new request <span class="subst">&#123;result.url&#125;</span>&#x27;</span>)</span><br><span class="line">                    self.queue.add(result)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, <span class="built_in">dict</span>):</span><br><span class="line">                    logger.debug(<span class="string">f&#x27;scraped new data <span class="subst">&#123;result&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>scheduler方法的内部是一个wihle循环，该循环内部的判断条件是队列不为空；当队列不为空时，调用pop方法取出下一个请求，然后调用request方法执行这个请求，request方法的实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        execute request</span></span><br><span class="line"><span class="string">        :param request: weixin request</span></span><br><span class="line"><span class="string">        :return: response</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            proxy = self.get_proxy()</span><br><span class="line">            logger.debug(<span class="string">f&#x27;get proxy <span class="subst">&#123;proxy&#125;</span>&#x27;</span>)</span><br><span class="line">            proxies = &#123;</span><br><span class="line">                <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://&#x27;</span> + proxy,</span><br><span class="line">                <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;https://&#x27;</span> + proxy</span><br><span class="line">            &#125; <span class="keyword">if</span> proxy <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> self.session.send(request.prepare(),</span><br><span class="line">                                     timeout=request.timeout,</span><br><span class="line">                                     proxies=proxies)</span><br><span class="line">        <span class="keyword">except</span> RequestException:</span><br><span class="line">            logger.exception(<span class="string">f&#x27;requesting <span class="subst">&#123;request.url&#125;</span> failed&#x27;</span>)</span><br></pre></td></tr></table></figure><p>以上request方法也可以不用try/catch方法采用logger中的catch装饰器，在这个方法中，首先调用get_proxy()获取代理，然后将代理赋值给proxies字典，接着调用session变量的send方法执行这个请求，这里调用prepare方法将请求转化为了Prepared Request对象(具体可看2.2节)，timeout属性是该请求的超时时间，proxies属性就是刚才声明的代理，最后返回send方法的执行结果</p><p>执行request方法之后会得到两种结果，一种是False，即请求失败，连接错误；另一种是Response对象，即请求成功后返回的结果，需要判断其中的状态码，如果状态码合法，就对返回结果进行解析，否则将请求重新放入队列</p><p>之后的就自己看代码了: <a class="link"   href="https://github.com/Python3WebSpider/ScrapeAntispider5" >https://github.com/Python3WebSpider/ScrapeAntispider5<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用爬虫的过程中经常会遇到这样的情况，爬虫最初还可以正常运行，正常爬取数据，一切看起来都是那么美好，然而一杯茶的功夫，就可能出现了错误，比如返回403或者啥的，出现这些现象的原因是网站采取了一些反爬措施，例如服务器会检测某个IP在单位时间内的请求次数，如果这个次数超过了指</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python3网络爬虫开发实战第二版第6章-异步爬虫</title>
    <link href="http://example.com/2022/02/09/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC6%E7%AB%A0-%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/"/>
    <id>http://example.com/2022/02/09/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC6%E7%AB%A0-%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/</id>
    <published>2022-02-09T03:25:30.000Z</published>
    <updated>2022-02-11T02:09:00.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="协程的基本原理"><a href="#协程的基本原理" class="headerlink" title="协程的基本原理"></a>协程的基本原理</h3><p>要实现异步机制的爬虫，那自然和协程脱不了关系，下面我们就来了解下使用协程实现加速的方法，这种方法<strong>对IO密集型任务非常有效</strong></p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>阻塞状态是指<strong>程序未得到所需计算资源时被挂起的状态</strong>；程序在等待某个操作完成期间，自身无法继续干别的事情，则称该程序在该操作上是阻塞的</p><p>常见的阻塞形式有以下几种:</p><ul><li>网络IO阻塞</li><li>磁盘IO阻塞</li><li>用户输入阻塞</li></ul><p>阻塞是无处不在的，包括CPU在执行上下文时，所有进程都无法真正干事情，它们也会阻塞；在多核CPU的情况下，正在执行上下文切换操作的核不可被利用</p><h5 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h5><p>非阻塞状态是指程序在等待某操作的时候，自身不被阻塞，可以继续干别的事情</p><p>非阻塞因阻塞而存在，正因阻塞导致程序运行的耗时增加与效率低下，我们才要把它变成非阻塞</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>举个栗子叭，在购物系统中更新商品库存时，需要用”行锁”，作为通行信号，强制让不同的更新请求<strong>排队并按顺序执行</strong>，这里的更新库存操作就是同步的，简而言之，<strong>同步意味着有序</strong>，不同程序单元在完成某个任务时需要靠某种通行方式保持协调一致才能完成任务</p><h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>举个栗子叭，我们爬虫下载网页，<strong>调度程序调用下载程序后，即可调用其他下载任务</strong>，无需与该下载任务保持通行以协调行为，简而言之，<strong>异步意味着无序</strong>，不同程序单元在完成某个任务时不需要靠某种通行方式保持协调一致也能完成任务</p><h5 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h5><p>多进程就是利用CPU的多核优势，在同一时间并发执行多个任务，可以大大提高执行效率</p><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，而多线程就是指从软件或者硬件上实现多个线程并发执行的技术</p><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>协程(coroutine)，又称微线程，是一种运行在用户态的轻量级线程，它拥有自己的寄存器上下文和栈，协程在调度切换时，将寄存器上下文和栈保存到其他地方， 等切回来的时候，再恢复先前保存的寄存器上下文和栈；因此，协程能保留上一次调用时的状态，每次进入都会进入上一次的所保留的状态</p><p>在我们的爬虫场景下，<strong>我们发出一个请求后，需要等待一定的时间才会响应，在这个等待过程中，程序可以做很多事情，等到得到响应后再切回来继续处理，这样可以充分利用CPU和其他资源</strong>，这就是协程的优势</p><h4 id="协程的用法"><a href="#协程的用法" class="headerlink" title="协程的用法"></a>协程的用法</h4><p>从Python3.4开始，Python中加入了协程的概念，但这个版本的协程还是以生成器对象为基础，Python3.5中增加了async、await，使得协程的实现更为方便，Python中使用协程最常用的库莫过于asyncio，下面我们来看看如何使用:</p><p>首先我们需要了解下面几个概念:</p><ul><li>event_loop: 事件循环，我们可以把一些函数注册到这个事件循环上</li><li>coroutine: 翻译过来是协程，在Python中常代指协程对象类型，我们可以<strong>将协程对象注册到事件循环中，它会被事件循环调用</strong>；我们可以<strong>使用async关键字来定义一个方法，这个方法在调用时不会立即执行，而是会返回一个协程对象</strong></li><li>task: 任务，这是<strong>对协程对象的进一步封装</strong>，包含协程对象的各个状态</li><li>future: 代表<strong>将来执行或没有执行的任务的结果</strong>，实际上和task没有本质区别</li></ul><p>另外，我们还需要知道，async是定义一个协程，await是用来挂起阻塞方法的执行，要使用这两个关键字要使用Python3.5以上</p><h4 id="定义协程"><a href="#定义协程" class="headerlink" title="定义协程"></a>定义协程</h4><p>我们来看一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Number:&#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">coroutine = execute(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Coroutine:&#x27;</span>, coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After calling execute&#x27;</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Coroutine</span>: &lt;coroutine <span class="built_in">object</span> execute at <span class="number">0x0000000002D6E448</span>&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Number: <span class="number">1</span></span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure><p>首先，我们引入了asyncio包，这样才可以使用async和await关键字，然后使用async定义了一个execute方法，该方法接受一个数字参数x，执行之后会打印这个数字，随后我们直接调用了execute方法，然而这个方法并没有执行，而是返回了一个coroutine协程对象；之后我们使用get_event_loop方法创建了一个时间循环loop，并调用loop对象的run_until_complete方法将协程对象coroutine注册到了时间循环中，接着就会启动。最后我们才看到execute方法打印出了接受的数字</p><p>前面我们提到了<strong>task，它是对协程对象的进一步封装，比协程对象多了运行状态，例如running，finished等，我们可以利用这些状态获取协程的执行情况</strong></p><p>在上面的例子中，当把协程对象coroutine传递给run_until_complete方法的时候，实际上它进行了一个操作，就是将coroutine封装成task对象；对此，我们也可显式地进行声明，代码如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Number:&#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">coroutine = execute(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Coroutine:&#x27;</span>, coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After calling execute&#x27;</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Coroutine</span>: &lt;coroutine <span class="built_in">object</span> execute at <span class="number">0x0000000002D6E4C8</span>&gt;</span><br><span class="line">After calling execute</span><br><span class="line">Task: &lt;Task pending coro=&lt;execute() running at D:/Python_LHJ/test/Learn_asyncio/first_aio_demo.py:<span class="number">15</span>&gt;&gt;</span><br><span class="line">Number: <span class="number">1</span></span><br><span class="line">Task: &lt;Task finished coro=&lt;execute() done, defined at D:/Python_LHJ/test/Learn_asyncio/first_aio_demo.py:<span class="number">15</span>&gt; result=<span class="literal">None</span>&gt;</span><br><span class="line">After calling loop</span><br></pre></td></tr></table></figure><p>这里我们定义了loop对象之后，紧接着调用了它的create_task方法，将协程对象转化为task对象，随后打印发现它处于pending状态，随后把它放在run_until_complete方法中去执行，并再次打印task对象，发现它的状态变成了finished</p><p>定义task对象还有另外一种方式，就是直接调用asyncio包的ensure_future方法，返回结果也是task对象，这样的话我们就可以不借助loop对象，即使还没有声明loop，也可以提前定义好task对象，这种方式的写法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Number:&#x27;</span>, x)</span><br><span class="line"></span><br><span class="line">coroutine = execute(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Coroutine:&#x27;</span>, coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After calling execute&#x27;</span>)</span><br><span class="line">task = asyncio.ensure_future(coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;After calling loop&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行效果是一样的</p><h4 id="绑定回调"><a href="#绑定回调" class="headerlink" title="绑定回调"></a>绑定回调</h4><p>我们也可以为某个task对象绑定一个回调方法，实例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>():</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">status = requests.get(url).status_code</span><br><span class="line"><span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span>(<span class="params">task</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Status:&#x27;</span>, task.result())</span><br><span class="line"></span><br><span class="line">coroutine = request()</span><br><span class="line">task = asyncio.ensure_future(coroutine)</span><br><span class="line">task.add_done_callback(callback)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br></pre></td></tr></table></figure><p>我们希望达到的效果是，当协程对象执行完毕之后，就去执行声明的callback方法，以上方法就为我们实现了</p><p>实际上，即使不使用回调方法，在task运行完毕之后，也可以直接调用result方法获取结果，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>():</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">status = requests.get(url).status_code</span><br><span class="line"><span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coroutine = request()</span><br><span class="line">task = asyncio.ensure_future(coroutine)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task:&#x27;</span>, task)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task Ruesult:&#x27;</span>, task.result())</span><br></pre></td></tr></table></figure><p>运行结果是一样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task: &lt;Task pending coro=&lt;request() running at D:/Python_LHJ/test/Learn_asyncio/bind_callback.py:<span class="number">17</span>&gt;&gt;</span><br><span class="line">Task: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/bind_callback.py:<span class="number">17</span>&gt; result=<span class="number">200</span>&gt;</span><br><span class="line">Task Ruesult: <span class="number">200</span></span><br></pre></td></tr></table></figure><h4 id="多任务协程"><a href="#多任务协程" class="headerlink" title="多任务协程"></a>多任务协程</h4><p>在上面的例子中，我们都只进行了一次请求，如果想执行多次请求，我们可以定义一个task列表，然后使用asyncio包中的wait方法执行，如下实例所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>():</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com&#x27;</span></span><br><span class="line">status = requests.get(url).status_code</span><br><span class="line"><span class="keyword">return</span> status</span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(request()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Tasks:&#x27;</span>, tasks)</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Task Result:&#x27;</span>, task.result())</span><br></pre></td></tr></table></figure><p>可以看到，这五个协程都被顺利执行</p><h4 id="协程实现"><a href="#协程实现" class="headerlink" title="协程实现"></a>协程实现</h4><p>上述案例只是为后面的使用做铺垫，现在我们来看看协程在解决IO密集型任务方面到底有怎样的优势</p><p>在前面的代码中，我们用一个网络请求作为例子，这本身就是一个耗时等待的操作，因为在请求网页之后需要等待页面响应并返回结果；耗时等待操作一般都是IO操作，例如文件读取，网络请求等；协程在处理这种操作时是有很大优势的，当遇到需要等待的情况时，程序可以暂时挂起，转而执行其他操作，避免一直等待下去</p><p>我们先来看几个错误的实现:</p><p>我们还是以之前的案例为例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>():</span></span><br><span class="line">url = <span class="string">&#x27;https://www.httpbin.org/delay/5&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Waiting for&#x27;</span>, url)</span><br><span class="line">response = requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;get response from:&#x27;</span>, url, <span class="string">&#x27;response:&#x27;</span>, response)</span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(request()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end-start)</span><br></pre></td></tr></table></figure><p>这里我们还是创建了10个task，然后将task列表传给wait方法并注册到时间循环中执行</p><p>运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line">get response <span class="keyword">from</span>: https://www.httpbin.org/delay/<span class="number">5</span> response: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line">Waiting <span class="keyword">for</span> https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line">get response <span class="keyword">from</span>: https://www.httpbin.org/delay/<span class="number">5</span> response: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line">Waiting <span class="keyword">for</span> https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line">get response <span class="keyword">from</span>: https://www.httpbin.org/delay/<span class="number">5</span> response: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line">Waiting <span class="keyword">for</span> https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line">get response <span class="keyword">from</span>: https://www.httpbin.org/delay/<span class="number">5</span> response: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line">Waiting <span class="keyword">for</span> https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line">get response <span class="keyword">from</span>: https://www.httpbin.org/delay/<span class="number">5</span> response: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line">Waiting <span class="keyword">for</span> https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line">get response <span class="keyword">from</span>: https://www.httpbin.org/delay/<span class="number">5</span> response: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line">Waiting <span class="keyword">for</span> https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line">get response <span class="keyword">from</span>: https://www.httpbin.org/delay/<span class="number">5</span> response: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line">Waiting <span class="keyword">for</span> https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line">get response <span class="keyword">from</span>: https://www.httpbin.org/delay/<span class="number">5</span> response: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line">Waiting <span class="keyword">for</span> https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line">get response <span class="keyword">from</span>: https://www.httpbin.org/delay/<span class="number">5</span> response: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line">Waiting <span class="keyword">for</span> https://www.httpbin.org/delay/<span class="number">5</span></span><br><span class="line">get response <span class="keyword">from</span>: https://www.httpbin.org/delay/<span class="number">5</span> response: &lt;Response [<span class="number">200</span>]&gt;</span><br><span class="line">Cost time: <span class="number">65.49599981307983</span></span><br></pre></td></tr></table></figure><p>我们发现耗时差不读66秒，这好像不是异步啊，其实，要实现异步，先得有挂起操作，当一个任务需要等待IO结果的时候，可以挂起当前任务，转而执行其他任务，而上面的方法都是一本正经地串行执行下来，连个挂起都没有，怎么可能实现异步</p><p>下面我们试试在请求的时候await一下是否有效果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>():</span></span><br><span class="line">url = <span class="string">&#x27;https://www.httpbin.org/delay/5&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Waiting for&#x27;</span>, url)</span><br><span class="line">response = <span class="keyword">await</span> requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;get response from:&#x27;</span>, url, <span class="string">&#x27;response:&#x27;</span>, response)</span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(request()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end-start)</span><br></pre></td></tr></table></figure><p>运行下发现会报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Task exception was never retrieved</span><br><span class="line">future: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py:<span class="number">22</span>&gt; exception=TypeError(<span class="string">&quot;object Response can&#x27;t be used in &#x27;await&#x27; expression&quot;</span>)&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py&quot;</span>, line <span class="number">25</span>, <span class="keyword">in</span> request</span><br><span class="line">    response = <span class="keyword">await</span> requests.get(url)</span><br><span class="line">TypeError: <span class="built_in">object</span> Response can<span class="string">&#x27;t be used in &#x27;</span><span class="keyword">await</span><span class="string">&#x27; expression</span></span><br><span class="line"><span class="string">Task exception was never retrieved</span></span><br><span class="line"><span class="string">future: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py:22&gt; exception=TypeError(&quot;object Response can&#x27;</span>t be used <span class="keyword">in</span> <span class="string">&#x27;await&#x27;</span> expression<span class="string">&quot;)&gt;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;</span>D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py<span class="string">&quot;, line 25, in request</span></span><br><span class="line"><span class="string">    response = await requests.get(url)</span></span><br><span class="line"><span class="string">TypeError: object Response can&#x27;t be used in &#x27;await&#x27; expression</span></span><br><span class="line"><span class="string">Task exception was never retrieved</span></span><br><span class="line"><span class="string">future: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py:22&gt; exception=TypeError(&quot;</span><span class="built_in">object</span> Response can<span class="string">&#x27;t be used in &#x27;</span><span class="keyword">await</span><span class="string">&#x27; expression&quot;)&gt;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py&quot;, line 25, in request</span></span><br><span class="line"><span class="string">    response = await requests.get(url)</span></span><br><span class="line"><span class="string">TypeError: object Response can&#x27;</span>t be used <span class="keyword">in</span> <span class="string">&#x27;await&#x27;</span> expression</span><br><span class="line">Task exception was never retrieved</span><br><span class="line">future: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py:<span class="number">22</span>&gt; exception=TypeError(<span class="string">&quot;object Response can&#x27;t be used in &#x27;await&#x27; expression&quot;</span>)&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py&quot;</span>, line <span class="number">25</span>, <span class="keyword">in</span> request</span><br><span class="line">    response = <span class="keyword">await</span> requests.get(url)</span><br><span class="line">TypeError: <span class="built_in">object</span> Response can<span class="string">&#x27;t be used in &#x27;</span><span class="keyword">await</span><span class="string">&#x27; expression</span></span><br><span class="line"><span class="string">Task exception was never retrieved</span></span><br><span class="line"><span class="string">future: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py:22&gt; exception=TypeError(&quot;object Response can&#x27;</span>t be used <span class="keyword">in</span> <span class="string">&#x27;await&#x27;</span> expression<span class="string">&quot;)&gt;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;</span>D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py<span class="string">&quot;, line 25, in request</span></span><br><span class="line"><span class="string">    response = await requests.get(url)</span></span><br><span class="line"><span class="string">TypeError: object Response can&#x27;t be used in &#x27;await&#x27; expression</span></span><br><span class="line"><span class="string">Task exception was never retrieved</span></span><br><span class="line"><span class="string">future: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py:22&gt; exception=TypeError(&quot;</span><span class="built_in">object</span> Response can<span class="string">&#x27;t be used in &#x27;</span><span class="keyword">await</span><span class="string">&#x27; expression&quot;)&gt;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py&quot;, line 25, in request</span></span><br><span class="line"><span class="string">    response = await requests.get(url)</span></span><br><span class="line"><span class="string">TypeError: object Response can&#x27;</span>t be used <span class="keyword">in</span> <span class="string">&#x27;await&#x27;</span> expression</span><br><span class="line">Task exception was never retrieved</span><br><span class="line">future: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py:<span class="number">22</span>&gt; exception=TypeError(<span class="string">&quot;object Response can&#x27;t be used in &#x27;await&#x27; expression&quot;</span>)&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py&quot;</span>, line <span class="number">25</span>, <span class="keyword">in</span> request</span><br><span class="line">    response = <span class="keyword">await</span> requests.get(url)</span><br><span class="line">TypeError: <span class="built_in">object</span> Response can<span class="string">&#x27;t be used in &#x27;</span><span class="keyword">await</span><span class="string">&#x27; expression</span></span><br><span class="line"><span class="string">Task exception was never retrieved</span></span><br><span class="line"><span class="string">future: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py:22&gt; exception=TypeError(&quot;object Response can&#x27;</span>t be used <span class="keyword">in</span> <span class="string">&#x27;await&#x27;</span> expression<span class="string">&quot;)&gt;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;</span>D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py<span class="string">&quot;, line 25, in request</span></span><br><span class="line"><span class="string">    response = await requests.get(url)</span></span><br><span class="line"><span class="string">TypeError: object Response can&#x27;t be used in &#x27;await&#x27; expression</span></span><br><span class="line"><span class="string">Task exception was never retrieved</span></span><br><span class="line"><span class="string">future: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py:22&gt; exception=TypeError(&quot;</span><span class="built_in">object</span> Response can<span class="string">&#x27;t be used in &#x27;</span><span class="keyword">await</span><span class="string">&#x27; expression&quot;)&gt;</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File &quot;D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py&quot;, line 25, in request</span></span><br><span class="line"><span class="string">    response = await requests.get(url)</span></span><br><span class="line"><span class="string">TypeError: object Response can&#x27;</span>t be used <span class="keyword">in</span> <span class="string">&#x27;await&#x27;</span> expression</span><br><span class="line">Task exception was never retrieved</span><br><span class="line">future: &lt;Task finished coro=&lt;request() done, defined at D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py:<span class="number">22</span>&gt; exception=TypeError(<span class="string">&quot;object Response can&#x27;t be used in &#x27;await&#x27; expression&quot;</span>)&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;D:/Python_LHJ/test/Learn_asyncio/Learn_aiohttp/first_aiohttp_demo.py&quot;</span>, line <span class="number">25</span>, <span class="keyword">in</span> request</span><br><span class="line">    response = <span class="keyword">await</span> requests.get(url)</span><br><span class="line">TypeError: <span class="built_in">object</span> Response can<span class="string">&#x27;t be used in &#x27;</span><span class="keyword">await</span><span class="string">&#x27; expression</span></span><br></pre></td></tr></table></figure><p>为什么会报错呢，这是因为requests返回的Response对象不能和await一起使用，官方文档说明，await后面的对象必须是如下格式之一:</p><ul><li>一个原生协程对象</li><li>一个由types.coroutine修饰过的生成器，这个生成器可以返回协程对象</li><li>由一个包含<code>__await__</code>方法的对象返回的一个迭代器</li></ul><p>既然await后面可以跟一个协程对象，那么async把请求的方法改成协程对象不就行了，于是代码就被改成了如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url</span>):</span></span><br><span class="line">res = requests.get(url)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>():</span></span><br><span class="line">url = <span class="string">&#x27;https://www.httpbin.org/delay/5&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Waiting for&#x27;</span>, url)</span><br><span class="line">response = <span class="keyword">await</span> get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;get response from:&#x27;</span>, url, <span class="string">&#x27;response:&#x27;</span>, response)</span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(request()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end-start)</span><br></pre></td></tr></table></figure><p>以上代码把请求的页面独立出来了，并用async修饰，就得到了一个协程对象，运行发现还是60多秒，这是为啥呢</p><p>这告诉我们仅仅将涉及IO操作的代码封装到async修饰的方法里是不可行的，只有使用支持异步操作的请求方式才可以实现真正的异步，这里就要使用aiohttp了</p><h4 id="使用aiohttp"><a href="#使用aiohttp" class="headerlink" title="使用aiohttp"></a>使用aiohttp</h4><p>aiohttp是一个支持异步请求的库，它和asyncio配合使用，可以非常方便地实现异步请求</p><p>安装aiohttp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aiohttp</span><br></pre></td></tr></table></figure><p>下面我们将aiohttp投入使用，将代码改写成如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url</span>):</span></span><br><span class="line">session = aiohttp.ClientSession()</span><br><span class="line">response = <span class="keyword">await</span> session.get(url)</span><br><span class="line"><span class="keyword">await</span> response.text()</span><br><span class="line"><span class="keyword">await</span> session.close()</span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span>():</span></span><br><span class="line">url = <span class="string">&#x27;https://www.httpbin.org/delay/5&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Waiting for&#x27;</span>, url)</span><br><span class="line">response = <span class="keyword">await</span> get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;get response from:&#x27;</span>, url, <span class="string">&#x27;response:&#x27;</span>, response)</span><br><span class="line"></span><br><span class="line">tasks = [asyncio.ensure_future(request()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">end = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>, end-start)</span><br></pre></td></tr></table></figure><p>这里我们就成功了，可见异步爬虫的速度是十分可观的</p><h3 id="aiohttp的使用"><a href="#aiohttp的使用" class="headerlink" title="aiohttp的使用"></a>aiohttp的使用</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>前面介绍的asyncio模块，其内部实现了对TCP，UDP，SSL协议的异步操作，但是对于HTTP请求来说，就需要用aiohttp来实现了</p><p> aiohttp是一个基于asyncio的异步HTTP网络模块，它既提供了服务端，又提供了客户端，其中，我们可以使用服务端搭建一个支持异步处理的服务器，用来处理请求并提供响应的，类似于Django、flask、Tornado等一些Web服务器；而客户端可以用来发起请求，类似于requests发起一个HTTP请求然后获得响应，但是request发起的是一个同步的网络请求，aiohttp则是异步的</p><h4 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">session, url</span>):</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> response.text(), response.status</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">html, status = <span class="keyword">await</span> fetch(session, <span class="string">&#x27;https://cuiqingcai.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line"><span class="built_in">print</span>(status)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(main())</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure><p>能够发现，aiohttp的请求方法的定义和之前有明显区别，主要包括如下几点:</p><ul><li>首先在导入库的时候，除了必须导入aiohttp这个库，还必须导入asyncio这个库，因为要实现异步爬取，需要启动协程，而协程需要借助于asyncio里面的事件循环才能执行</li><li>异步爬取方法的定义和之前有所不同吗，在每个异步方法的前面都要统一加async来修饰</li><li>with as语句前面同样需要加async来修饰，在Python中，with as语句用于声明一个上下文管理器，<strong>能够帮助我们自动分配和释放资源</strong>， 而在异步方法中，with as前面加上async代表声明一个支持异步的上下文管理器</li><li>对于一些返回协程对象的操作，前面需要加上await，如果是协程对象或者前面提到的三种中的一种那就要加上，如果只是返回数字那就不需要，比如返回状态码</li></ul><h4 id="URL参数设置"><a href="#URL参数设置" class="headerlink" title="URL参数设置"></a>URL参数设置</h4><p>对于URL参数的设置，我们可以借助params参数，传入一个字典即可，实例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">params = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>, params=params) <span class="keyword">as</span> response:</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> response.text())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><h4 id="其他请求类型"><a href="#其他请求类型" class="headerlink" title="其他请求类型"></a>其他请求类型</h4><p>aiohttp还支持其他请求类型，比如POST、PUT、DELETE等，这些和requests的使用方法相似，实例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">session.post(<span class="string">&#x27;http://www.httpbin.org/post&#x27;</span>, data=<span class="string">b&#x27;data&#x27;</span>)</span><br><span class="line">session.put(<span class="string">&#x27;http://www.httpbin.org/post&#x27;</span>, data=<span class="string">b&#x27;data&#x27;</span>)</span><br><span class="line">session.delete(<span class="string">&#x27;http://www.httpbin.org/delete&#x27;</span>)</span><br><span class="line">session.head(<span class="string">&#x27;http://www.httpbin.org/get&#x27;</span>)</span><br><span class="line">session.options(<span class="string">&#x27;http://www.httpbin.org/get&#x27;</span>)</span><br><span class="line">session.patch(<span class="string">&#x27;http://www.httpbin.org/patch&#x27;</span>, data=<span class="string">b&#x27;data&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>对于POST请求，其对应的请求头中的Content-Type为application/x-www-form-urlencoded我们可以用如下方式来提交:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.post(<span class="string">&#x27;https://www.httpbin.org/post&#x27;</span>, data=data) <span class="keyword">as</span> response:</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> response.text())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;data&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;form&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="string">&quot;25&quot;</span>, </span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;germey&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;*/*&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;18&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;www.httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Python/3.7 aiohttp/3.8.1&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-6203958d-60f5aa1f65cba41349a09e45&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;json&quot;</span>: null, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;113.66.217.106&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.httpbin.org/post&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于POST JSON数据提交，其对应的请求头中的Content-Type为application/json，我们只需要将post方法中的data参数改成json即可，实例代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.post(<span class="string">&#x27;https://www.httpbin.org/post&#x27;</span>, json=data) <span class="keyword">as</span> response:</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> response.text())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>对于响应来说，我们可以用如下方法分别获取其中的状态码、响应头、响应体、响应体二进制内容、响应体JSON结果，实例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.post(<span class="string">&#x27;https://www.httpbin.org/post&#x27;</span>, json=data) <span class="keyword">as</span> response:</span><br><span class="line"><span class="built_in">print</span>(response.status)</span><br><span class="line"><span class="built_in">print</span>(response.headers)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> response.text())</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> response.read())</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> response.json())</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><h4 id="设置超时"><a href="#设置超时" class="headerlink" title="设置超时"></a>设置超时</h4><p>我们可以借助ClientTimeout对象设置超时，比如设置1秒的超时时间，可以这么实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">timeout = aiohttp.ClientTimeout(total=<span class="number">1</span>)</span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;25&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(timeout=timeout) <span class="keyword">as</span> session:</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.post(<span class="string">&#x27;https://www.httpbin.org/post&#x27;</span>, json=data) <span class="keyword">as</span> response:</span><br><span class="line"><span class="built_in">print</span>(response.status)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><p>如果超时，则会抛出TimeoutError，其类型为asynico.TimeoutError，我们进行异常捕获即可，另外，ClientTimeout对象还有其他参数，比如connect、socket_connect等，详细可见官网</p><h4 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h4><p>由于aiohttp可以支持很高的并发量，可能高达上百万，面对如此高的并发量，目标网站可能会处理不过来而有挂掉的危险，这就警示我们需要控制一下爬取的并发量</p><p>一般情况下，可以借助asyncio的Semaphore来控制并发量，实例代码如下:</p><p>代码见: <a class="link"   href="https://github.com/Python3WebSpider/AsyncTest" >https://github.com/Python3WebSpider/AsyncTest<i class="fas fa-external-link-alt"></i></a></p><h3 id="aiohttp异步爬取实战"><a href="#aiohttp异步爬取实战" class="headerlink" title="aiohttp异步爬取实战"></a>aiohttp异步爬取实战</h3><h4 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h4><p>点击<a class="link"   href="https://spa5.scrape.center/" >跳转<i class="fas fa-external-link-alt"></i></a>到目标网站，这是个图书网站，我们要使用aiohttp把该网站上的所有数据爬取下来，将数据用异步的方式保存到MongoDB中</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul><li>安装好了Python(最好为3.7或者以上)</li><li>了解了Ajax爬取的一些基本原理和模拟方法</li><li>了解了异步爬虫的基本原理和asyncio基本库的使用</li><li>了解了aiohttp基本库的使用</li><li>安装并成功运行了MongoDB数据库，而且安装了异步爬虫库motor</li></ul><p>要实现MongoDB异步存储，离不开异步实现的MongoDB存储库motor，其安装命令如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install motor</span><br></pre></td></tr></table></figure><p>由于这里有新的库motor，这里我就跟着书上的内容走一遍:</p><h4 id="页面分析"><a href="#页面分析" class="headerlink" title="页面分析"></a>页面分析</h4><ul><li><p>列表页的Ajax请求接口格式为<code>https://spa5.scrape.center/api/book/?limit=18&amp;offset=&#123;offset&#125;</code>，其中<code>limit</code>的值为每一页包含多少本书，offset的值为每一页的偏移量，计算公式为<code>limit * (page - 1)</code></p></li><li><p>我们随便点开一本图书，然后对比刚刚列表页请求接口返回的数据，我们会发现每本书的id字段就是图书本身的id:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220208/Snipaste_2022-02-10_18-09-14.2ygmnawmlpa0.webp"                      alt="Snipaste_2022-02-10_18-09-14"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220208/Snipaste_2022-02-10_18-09-35.3ouphwysn3y0.webp"                      alt="Snipaste_2022-02-10_18-09-35"                ></p><p>这样我们就可以用来进一步请求详情页</p></li></ul><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li>第一阶段是异步爬取所有列表页，将所有列表页的爬取任务集合在一起，并将其声明为由task组成的列表，进行异步爬取</li><li>第二阶段则是拿到上一步列表页的所有内容并解析，将所有图书的id信息组合为所有详情页的爬取任务列表，并将其声明为task组成的列表，进行异步爬取，同时爬取结果也以异步方式存储到MongoDB中</li></ul><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>首先我们先配置一些基本的变量并引入一些必须的库，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s: %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://spa5.scrape.center/api/book/?limit=18&amp;offset=&#123;offset&#125;&#x27;</span></span><br><span class="line">DETAIL_URL = <span class="string">&#x27;https://spa5.scrape.center/api/book/&#123;id&#125;&#x27;</span></span><br><span class="line">PAGE_SIZE = <span class="number">18</span></span><br><span class="line">PAGE_NUMBER = <span class="number">100</span></span><br><span class="line">CONCURRENCY = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这里我们导入了基本的库，然后定义了loggin的基本配置，接着定义了爬取的页数，并发量，每一页的书本数，列表页的URL以及详情页的URL</p><h4 id="直接看代码叭"><a href="#直接看代码叭" class="headerlink" title="直接看代码叭"></a>直接看代码叭</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description : </span></span><br><span class="line"><span class="string">@File        : get_all_books</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/2/11 9:28</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       : </span></span><br><span class="line"><span class="string">@change      : </span></span><br><span class="line"><span class="string">@reason      : </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s: %(message)s&#x27;</span>)  <span class="comment"># loggin的基本配置</span></span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">&#x27;https://spa5.scrape.center/api/book/?limit=18&amp;offset=&#123;offset&#125;&#x27;</span>  <span class="comment"># 列表页的baseURL</span></span><br><span class="line">DETAIL_URL = <span class="string">&#x27;https://spa5.scrape.center/api/book/&#123;id&#125;&#x27;</span>  <span class="comment"># 详情页的baseURL</span></span><br><span class="line">PAGE_SIZE = <span class="number">18</span></span><br><span class="line">PAGE_NUMBER = <span class="number">100</span></span><br><span class="line">CONCURRENCY = <span class="number">5</span>  <span class="comment"># 并发量</span></span><br><span class="line"></span><br><span class="line">session = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">MONGO_CONNECTION_STRING = <span class="string">&#x27;mongodb://localhost:27017&#x27;</span></span><br><span class="line">MONGO_DB_NAME = <span class="string">&#x27;books&#x27;</span></span><br><span class="line">MONGO_COLLECTION_NAME = <span class="string">&#x27;books&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> motor.motor_asyncio <span class="keyword">import</span> AsyncIOMotorClient  <span class="comment"># 异步的插入数据库，需提前安装motor包</span></span><br><span class="line"></span><br><span class="line">client = AsyncIOMotorClient(MONGO_CONNECTION_STRING)</span><br><span class="line">db = client[MONGO_DB_NAME]</span><br><span class="line">collection = db[MONGO_COLLECTION_NAME]</span><br><span class="line"></span><br><span class="line">semaphore = asyncio.Semaphore(CONCURRENCY)  <span class="comment"># 声明信号量，用来控制最大并发数量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">scrape_api</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphore:  <span class="comment"># 引入信号量作为上下文</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            logging.info(<span class="string">&#x27;scraping %s&#x27;</span>, url)</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> response.json()  <span class="comment"># 返回json格式的结果</span></span><br><span class="line">        <span class="keyword">except</span> aiohttp.ClientError:  <span class="comment"># 捕获错误，类型为aiohttp.ClientError</span></span><br><span class="line">            logging.error(<span class="string">&#x27;error occurred while scraping %s&#x27;</span>, url, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">scrape_index</span>(<span class="params">page</span>):</span>  <span class="comment"># 爬取列表页</span></span><br><span class="line">    url = INDEX_URL.<span class="built_in">format</span>(offset=PAGE_SIZE * (page - <span class="number">1</span>))  <span class="comment"># 构造列表页URL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> scrape_api(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">scrape_detail</span>(<span class="params"><span class="built_in">id</span></span>):</span>  <span class="comment"># 爬取详情页并保存数据</span></span><br><span class="line">    url = DETAIL_URL.<span class="built_in">format</span>(<span class="built_in">id</span>=<span class="built_in">id</span>)  <span class="comment"># 构造真实详情页</span></span><br><span class="line">    data = <span class="keyword">await</span> scrape_api(url)</span><br><span class="line">    <span class="keyword">await</span> save_data(data)  <span class="comment"># 保存数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">data</span>):</span></span><br><span class="line">    logging.info(<span class="string">&#x27;saving data %s&#x27;</span>, data)</span><br><span class="line">    <span class="keyword">if</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> collection.update_one(&#123;  <span class="comment"># 这里使用update_one方法，其第二个参数都要使用类似&#x27;$set&#x27;: data的格式</span></span><br><span class="line">            <span class="string">&#x27;id&#x27;</span>: data.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="string">&#x27;$set&#x27;</span>: data</span><br><span class="line">        &#125;, upsert=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># index tasks</span></span><br><span class="line">    <span class="keyword">global</span> session  <span class="comment"># 声明session为全局变量，这样的话就不用在各个方法中都传递session了</span></span><br><span class="line">    session = aiohttp.ClientSession()</span><br><span class="line">    scrape_index_tasks = [asyncio.ensure_future(scrape_index(page)) <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, PAGE_NUMBER + <span class="number">1</span>)]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*scrape_index_tasks)  <span class="comment"># 执行asyncio.gather(*tasks)即可爬取列表页</span></span><br><span class="line">    <span class="comment"># detail tasks</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;results&#x27;</span>, results)</span><br><span class="line">    ids = []</span><br><span class="line">    <span class="keyword">for</span> index_data <span class="keyword">in</span> results:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> index_data: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> index_data.get(<span class="string">&#x27;results&#x27;</span>):</span><br><span class="line">            ids.append(item.get(<span class="string">&#x27;id&#x27;</span>))</span><br><span class="line">    scrape_detail_tasks = [asyncio.ensure_future(scrape_detail(<span class="built_in">id</span>)) <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> ids]  <span class="comment"># 所有爬取详情页的task组成的列表</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(scrape_detail_tasks)  <span class="comment"># 执行asynico.wait(tasks)即可爬取详情页，这里使用asyncio.gather()效果是一样的，只不过返回的结果略有差异</span></span><br><span class="line">    <span class="keyword">await</span> session.close()  <span class="comment"># 调用session.close()关闭session</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()  <span class="comment"># 使用事件循环启动main()对应的协程，main()是最外层的协程，需要放在事件循环中去执行</span></span><br><span class="line">    loop.run_until_complete(main())</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;协程的基本原理&quot;&gt;&lt;a href=&quot;#协程的基本原理&quot; class=&quot;headerlink&quot; title=&quot;协程的基本原理&quot;&gt;&lt;/a&gt;协程的基本原理&lt;/h3&gt;&lt;p&gt;要实现异步机制的爬虫，那自然和协程脱不了关系，下面我们就来了解下使用协程实现加速的方法，这种方法&lt;s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python3网络爬虫开发实战第二版第5章-Ajax数据爬取</title>
    <link href="http://example.com/2022/02/08/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC5%E7%AB%A0-Ajax%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/"/>
    <id>http://example.com/2022/02/08/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC5%E7%AB%A0-Ajax%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/</id>
    <published>2022-02-08T09:10:30.000Z</published>
    <updated>2022-02-11T02:08:46.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h3><p>以下来自百度百科:</p><p>Ajax即<strong>A</strong>synchronous <strong>J</strong>avascript <strong>A</strong>nd <strong>X</strong>ML（异步JavaScript和<a class="link"   href="https://baike.baidu.com/item/XML/86251" >XML<i class="fas fa-external-link-alt"></i></a>）在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: <a class="link"   href="https://baike.baidu.com/item/HTML/97049" >HTML<i class="fas fa-external-link-alt"></i></a> 或 <a class="link"   href="https://baike.baidu.com/item/XHTML/316621" >XHTML<i class="fas fa-external-link-alt"></i></a>, CSS, <a class="link"   href="https://baike.baidu.com/item/JavaScript/321142" >JavaScript<i class="fas fa-external-link-alt"></i></a>, <a class="link"   href="https://baike.baidu.com/item/DOM/50288" >DOM<i class="fas fa-external-link-alt"></i></a>, XML, <a class="link"   href="https://baike.baidu.com/item/XSLT/1330564" >XSLT<i class="fas fa-external-link-alt"></i></a>, 以及最重要的<a class="link"   href="https://baike.baidu.com/item/XMLHttpRequest/6788735" >XMLHttpRequest<i class="fas fa-external-link-alt"></i></a>。 [3] 使用Ajax技术网页应用能够快速地将增量更新呈现在<a class="link"   href="https://baike.baidu.com/item/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/6582461" >用户界面<i class="fas fa-external-link-alt"></i></a>上，而不需要重载（刷新）整个页面，这使得程序能够更快地回应用户的操作</p><p>可以到豆瓣上体验几个实例: <a class="link"   href="https://movie.douban.com/typerank?type_name=%E5%89%A7%E6%83%85&amp;type=11&amp;interval_id=100:90&amp;action=" >https://movie.douban.com/typerank?type_name=%E5%89%A7%E6%83%85&amp;type=11&amp;interval_id=100:90&amp;action=<i class="fas fa-external-link-alt"></i></a></p><h4 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h4><p>我们在浏览网页的时候，一直下滑，在数据没有展现完毕之前会一直在网页不刷新的情况下呈现数据，这个过程就是Ajax加载的过程</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>从发送Ajax请求到网页更新的这个过程可以简单分为以下三步:</p><ul><li><p>发送请求</p><p>我们知道Javascript可以实现页面的各种交互功能，Ajax也不例外，因为它就是由JavaScript实现的，最底层的实现代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    xmlhttp=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// code for IE6、IE5</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/ajax/&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">xmlhttp.send()</span><br></pre></td></tr></table></figure><p>以上代码可以拆分为以下几步:</p><ul><li>新建一个XMLHttpRequest对象xmlhttp</li><li>调用onreadystatechange属性设置监听</li><li>最后调用open和send方法向某个链接(也就是服务器)发送请求</li></ul><p>前面用Python实现请求发送，由于这里是Ajax，所以实际上这里的请求发送会由JavaScript完成，由于设置了监听，当服务器返回响应时，onreadystatechange对应的方法便会被触发，然后就会在浏览器显示内容，后面的数据解析就交给Python了</p></li></ul><h4 id="解析内容"><a href="#解析内容" class="headerlink" title="解析内容"></a>解析内容</h4><p>返回内容可能是HTML或者JSON，接下来只需要在方法中用JavaScript进一步处理即可，如果是JSON的话，可以进行解析和优化</p><h4 id="渲染网页"><a href="#渲染网页" class="headerlink" title="渲染网页"></a>渲染网页</h4><p>JavaScript有改变网页内容的能力，在解析完响应内容之后，就可以调用JavaScript来进行下一步处理了，例如，通过document.getElementById().innerHTML操作可以修改源代码，这种操作也称为dom操作，即对网页文档进行操作</p><p>再回想下豆瓣的下拉刷新，其实就是JavaScript向服务器发送了一个Ajax请求得到的，然后获取新的微博数据，对其做解析，并渲染在网页中</p><p>因此我们知道，真实的网页数据其实就是一次次向服务器发送Ajax请求得到的，要想抓取这些数据，需要知道Ajax请求到底是怎么发送的、发往哪里，发了哪些参数，我们知道这些以后，就可以用Python模拟发送操作</p><h3 id="Ajax分析方法"><a href="#Ajax分析方法" class="headerlink" title="Ajax分析方法"></a>Ajax分析方法</h3><p>这里略过</p><h3 id="Ajax分析与实战"><a href="#Ajax分析与实战" class="headerlink" title="Ajax分析与实战"></a>Ajax分析与实战</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul><li>安装好Python3(最低为3.6版本)</li><li>了解Python HTTP请求库requests的基本用法</li><li>了解Ajax基础知识和分析Ajax的基本方法</li></ul><h4 id="爬取目标"><a href="#爬取目标" class="headerlink" title="爬取目标"></a>爬取目标</h4><p><a class="link"   href="https://spa1.scrape.center/" >点击跳转<i class="fas fa-external-link-alt"></i></a></p><p>我们需要完成的目标如下:</p><ul><li>分析页面数据的加载逻辑</li><li>用request实现Ajax数据的爬取</li><li>将每部电影的数据分别保存到MongoDB数据库</li></ul><p>我们直接上代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_single_page_data</span>(<span class="params">u</span>):</span></span><br><span class="line">    response = requests.get(url).text</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">r</span>):</span></span><br><span class="line">    movies_data_list = json.loads(r)[<span class="string">&#x27;results&#x27;</span>]</span><br><span class="line">    movie_id_page_max = movies_data_list[-<span class="number">1</span>][<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">    drama_list = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(movie_id_page_max - <span class="number">9</span>, movie_id_page_max + <span class="number">1</span>):</span><br><span class="line">        movie_drama_url = <span class="string">f&#x27;https://spa1.scrape.center/detail/<span class="subst">&#123;d&#125;</span>&#x27;</span></span><br><span class="line">        res = get_single_page_data(movie_drama_url)</span><br><span class="line">        drama = json.loads(res)[<span class="string">&#x27;drama&#x27;</span>]</span><br><span class="line">        drama_list.append(drama)</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(movies_data_list):</span><br><span class="line">        value[<span class="string">&#x27;categories&#x27;</span>] = <span class="string">&#x27;,&#x27;</span>.join(i[<span class="string">&#x27;categories&#x27;</span>])</span><br><span class="line">        value[<span class="string">&#x27;regions&#x27;</span>] = <span class="string">&#x27;,&#x27;</span>.join(i[<span class="string">&#x27;regions&#x27;</span>])</span><br><span class="line">        value[<span class="string">&#x27;drama&#x27;</span>] = drama_list[key]</span><br><span class="line"></span><br><span class="line">    myclient = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line">    mydb = myclient[<span class="string">&quot;scrape&quot;</span>]</span><br><span class="line">    mycol = mydb[<span class="string">&#x27;movie_data&#x27;</span>]</span><br><span class="line">    result = mycol.insert_many(movies_data_list)</span><br><span class="line">    <span class="built_in">print</span>(result.inserted_ids)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>):</span><br><span class="line">        url = <span class="string">f&quot;https://spa1.scrape.center/api/movie/?limit=10&amp;offset=<span class="subst">&#123;i&#125;</span>&quot;</span></span><br><span class="line">        res = get_single_page_data(url)</span><br><span class="line">        save(res)</span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220208/Snipaste_2022-02-08_18-48-48.1ohxw6lnjclc.webp"                      alt="Snipaste_2022-02-08_18-48-48"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是Ajax&quot;&gt;&lt;a href=&quot;#什么是Ajax&quot; class=&quot;headerlink&quot; title=&quot;什么是Ajax&quot;&gt;&lt;/a&gt;什么是Ajax&lt;/h3&gt;&lt;p&gt;以下来自百度百科:&lt;/p&gt;
&lt;p&gt;Ajax即&lt;strong&gt;A&lt;/strong&gt;synchronou</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python3网络爬虫开发实战第二版第4章-数据的存储</title>
    <link href="http://example.com/2022/02/08/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <id>http://example.com/2022/02/08/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/</id>
    <published>2022-02-08T01:27:30.000Z</published>
    <updated>2022-02-11T02:08:22.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TXT文本文件存储"><a href="#TXT文本文件存储" class="headerlink" title="TXT文本文件存储"></a>TXT文本文件存储</h3><p>以txt格式存储</p><p>r: 以只读打开</p><p>rb: 以二进制只读方式打开</p><p>r+: 以读写方式打开</p><p>rb+: 以二进制读写方式打开</p><p>w: 以写入方式打开</p><p>wb: 以二进制写入方式打开</p><p>w+: 以读写方式打开</p><p>wb+: 以二进制读写方式打开</p><p>a: 以追加方式打开一个文件</p><p>ab: 以二进制追加方式打开一个文件</p><p>ab+: 以二进制追加方式打开一个文件，如果该文件不存在就新建一个文件用于读写</p><h3 id="JSON文件存储"><a href="#JSON文件存储" class="headerlink" title="JSON文件存储"></a>JSON文件存储</h3><p>在js中，一切皆对象，对象在js中是指用花括号{}包围起来的内容，数据结构是{key1: value1, key2: value2}这种键值对结构，key表示对象的属性，value表示属性的值，前者可以使用整数和字符串，后者可以是任意类型</p><p>关于Python的json文件存储以及提取可以参考<a class="link"   href="https://www.cnblogs.com/guguobao/p/9512696.html" >这里<i class="fas fa-external-link-alt"></i></a></p><h3 id="CSV文件存储"><a href="#CSV文件存储" class="headerlink" title="CSV文件存储"></a>CSV文件存储</h3><p>详情请见: <a class="link"   href="https://www.cnblogs.com/gdjlc/p/11406599.html" >https://www.cnblogs.com/gdjlc/p/11406599.html<i class="fas fa-external-link-alt"></i></a></p><p>还可以参照书本</p><h3 id="MySQL数据存储"><a href="#MySQL数据存储" class="headerlink" title="MySQL数据存储"></a>MySQL数据存储</h3><p>详情请见: <a class="link"   href="https://www.cnblogs.com/hanfanfan/p/10398244.html" >https://www.cnblogs.com/hanfanfan/p/10398244.html<i class="fas fa-external-link-alt"></i></a></p><h3 id="MongoDB数据存储"><a href="#MongoDB数据存储" class="headerlink" title="MongoDB数据存储"></a>MongoDB数据存储</h3><p>NoSQL，全称为Not Only SQL，意为不仅仅是SQL，泛指菲关系型数据库，NoSQL是基于键值对的，而且不需要经过SQL层的解析，数据之间没有耦合性，性能非常高</p><p>非关系型数据库又可细分如下:</p><ul><li>键值存储数据库: 代表有Redis等</li><li>列存储数据库: 代表有Cassandra，HBase和Riak等</li><li>文档型数据库: 代表有CouchDB和MongoDB等</li><li>图形数据库: 代表有Neo4j，InfoGrid等</li></ul><p>我们爬虫使用非关系型数据库是比较方便的，我们来看看MongoDB:</p><h4 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install MongoDB</span><br></pre></td></tr></table></figure><h4 id="连接MongoDB"><a href="#连接MongoDB" class="headerlink" title="连接MongoDB"></a>连接MongoDB</h4><p>连接MongoDB，需要使用PyMongo库里面的MongoClient方法，一般而言，传入MongoDB的IP以及端口即可，MongoClient方法的第一个参数为地址host，第二个参数为端口port(如果不传入此参数默认为27017)</p><p>示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">27017</span>)</span><br></pre></td></tr></table></figure><p>上面的client就是MongoDB的连接对象了</p><p>另外，还可以直接给MongoDB的第一个参数传入MongoDB的连接字符串，它以mongodb开头，实例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;mongodb://localhost:27017&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"> </span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line">mydb = myclient[<span class="string">&quot;runoobdb&quot;</span>]</span><br></pre></td></tr></table></figure><p>执行以上代码便创建了一个名叫runoobdb的数据库，但是要注意在MongoDB中数据库只有在内容插入后才会创建! 就是说，数据库创建后要创建集合(数据表)并插入一个文档(记录)，数据库才会真正创建</p><h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myclient = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line">mydb = myclient[<span class="string">&quot;runoobdb&quot;</span>]</span><br><span class="line"> </span><br><span class="line">mycol = mydb[<span class="string">&quot;sites&quot;</span>]</span><br></pre></td></tr></table></figure><p>执行以上代码便创建了一个名叫sites的集合，但是要注意在 MongoDB 中，集合只有在内容插入后才会创建! 就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建</p><h4 id="指定数据库"><a href="#指定数据库" class="headerlink" title="指定数据库"></a>指定数据库</h4><p>示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = client.test</span><br></pre></td></tr></table></figure><p>这里调用client的test属性即可返回test数据库，当然也可以这样指定:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db = client[&#x27;test&#x27;]</span><br></pre></td></tr></table></figure><p>以上两种方式是等价的</p><h4 id="指定集合"><a href="#指定集合" class="headerlink" title="指定集合"></a>指定集合</h4><p>MongoDB下又包含多个集合，这些结合类似于关系型数据库的表</p><p>示例如下:(这里指定一个集合为students)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection = db.students</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection = [<span class="string">&#x27;students&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>我们在students这个集合中试着插入一个数据，这个数据以字典形式表示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line">mydb = myclient[<span class="string">&quot;runoobdb&quot;</span>]</span><br><span class="line">mycol = mydb[<span class="string">&#x27;students&#x27;</span>]</span><br><span class="line"></span><br><span class="line">studnet = &#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;45&quot;</span>,</span><br><span class="line"><span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">rsult = mycol.insert(studnet)  <span class="comment"># insert is deprecated(insert方法被弃用)</span></span><br><span class="line"><span class="built_in">print</span>(rsult)  <span class="comment"># 会返回一个ObjectId类型的_id属性，执行insert方法后会返回_id值</span></span><br></pre></td></tr></table></figure><p>当然我们也可以插入多条数据，用列表形式传递即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line">mydb = myclient[<span class="string">&quot;runoobdb&quot;</span>]</span><br><span class="line">mycol = mydb[<span class="string">&#x27;students&#x27;</span>]</span><br><span class="line"></span><br><span class="line">studnet1 = &#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;45&quot;</span>,</span><br><span class="line"><span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">studnet2 = &#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;jklg&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;453&quot;</span>,</span><br><span class="line"><span class="string">&quot;gender&quot;</span>: <span class="string">&quot;women&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">rsult = mycol.insert([studnet1,studnet2])  <span class="comment"># insert is deprecated(insert方法被弃用)</span></span><br><span class="line"><span class="built_in">print</span>(rsult)  <span class="comment"># 会返回一个ObjectId类型的_id属性，执行insert方法后会返回_id值</span></span><br><span class="line"><span class="comment"># 插入多个将会返回_id的列表</span></span><br></pre></td></tr></table></figure><p>虽然在Python3.x中insert方法已经不被官方所推荐，但还是可以继续使用，官方推荐用insert_one插入一个，用insert_many插入多个:</p><p>示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line">mydb = myclient[<span class="string">&quot;runoobdb&quot;</span>]</span><br><span class="line">mycol = mydb[<span class="string">&#x27;students&#x27;</span>]</span><br><span class="line"></span><br><span class="line">studnet1 = &#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;jkvl&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;45&quot;</span>,</span><br><span class="line"><span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">result = mycol.insert_one(studnet1)  <span class="comment"># 官方推荐使用insert_one</span></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 返回这次返回的是InsertOneResult对象，我们可以调用其inserted_id属性获取_id</span></span><br><span class="line"><span class="built_in">print</span>(result.inserted_id)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line">mydb = myclient[<span class="string">&quot;runoobdb&quot;</span>]</span><br><span class="line">mycol = mydb[<span class="string">&#x27;students&#x27;</span>]</span><br><span class="line"></span><br><span class="line">studnet1 = &#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;jokvl&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;45&quot;</span>,</span><br><span class="line"><span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">studnet2 = &#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;jlkvl&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;445&quot;</span>,</span><br><span class="line"><span class="string">&quot;gender&quot;</span>: <span class="string">&quot;man&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = mycol.insert_many([studnet1, studnet2])  <span class="comment"># 官方推荐使用insert_many</span></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 返回这次返回的是InsertOneResult对象，我们可以调用其inserted_ids属性获取_id</span></span><br><span class="line"><span class="built_in">print</span>(result.inserted_ids)</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>我们可以使用find_one或find方法进行查询，前者查询得到的是单个结果，后者则会返回一个生成器对象</p><p>示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line">mydb = myclient[<span class="string">&quot;runoobdb&quot;</span>]</span><br><span class="line">mycol = mydb[<span class="string">&#x27;students&#x27;</span>]</span><br><span class="line">result = mycol.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jokvl&#x27;</span>&#125;)  <span class="comment"># 字典类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>我们还可以根据ObjectId来查询数据，需要用到bson库里的objectid:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> bson.objectid <span class="keyword">import</span> ObjectId</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017/&quot;</span>)</span><br><span class="line">mydb = myclient[<span class="string">&quot;runoobdb&quot;</span>]</span><br><span class="line">mycol = mydb[<span class="string">&#x27;students&#x27;</span>]</span><br><span class="line">result = mycol.find_one(&#123;<span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;6201e6be4652abcba2496717&#x27;</span>)&#125;)  <span class="comment"># 字典类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(result))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>如果查询结果不存在，就会返回None</p><p>查询多条数据，可以使用find方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = collection.find(<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">   <span class="built_in">print</span>(r)</span><br></pre></td></tr></table></figure><p>如果要查询age大于20的数据，写法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">20</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>比较符号如下:</p><table><thead><tr><th>符号</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>$lt</td><td>小于</td><td>{‘age’: {‘$lt’: 20}}</td></tr><tr><td>$gt</td><td>大于</td><td>{‘age’: {‘$gt’: 20}}</td></tr><tr><td>$lte</td><td>小于等于</td><td>{‘age’: {‘$lte’: 20}}</td></tr><tr><td>$gte</td><td>大于等于</td><td>{‘age’: {‘$gte’: 20}}</td></tr><tr><td>$ne</td><td>不等于</td><td>{‘age’: {‘$ne’: 20}}</td></tr><tr><td>$in</td><td>在范围内</td><td>{‘age’: {‘$in’: [20, 30]}}</td></tr><tr><td>$nin</td><td>不在范围内</td><td>{‘age’: {‘$nin’: [20, 30]}}</td></tr></tbody></table><p>另外还可以使用正则表达式进行匹配，比如下面查询name以M为开头的学生数量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = collection.find(&#123;<span class="string">&#x27;name&#x27;</span>: &#123;<span class="string">&#x27;$regex&#x27;</span>: <span class="string">&#x27;^M.*&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><p>使用count方法来计数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = collection.find().count()</span><br></pre></td></tr></table></figure><p>统计符合条件的个数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = collection.find(&#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;).count()</span><br></pre></td></tr></table></figure><p>运行结果都是一个数值</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>使用sort方法，并传入排序的字段及升降序标准即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.ASCENDING)</span><br><span class="line"><span class="built_in">print</span>([result[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br></pre></td></tr></table></figure><p>以上代码中的ASCENDING表示升序排序，降序排序可传入pymongo.DESCENDING</p><h4 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h4><p>在某些情况下，我们可能只想取某几个元素，这时候我们可以利用skip方法偏移几个位置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.ASCENDING).skip(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>([result[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br></pre></td></tr></table></figure><p>还可以使用limit方法指定要获取的结果个数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = collection.find().sort(<span class="string">&#x27;name&#x27;</span>, pymongo.ASCENDING).skip(<span class="number">2</span>).limit(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>([result[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br></pre></td></tr></table></figure><p>注意: 在数据库中数量非常庞大的时候，比如千万、亿级别的，最好不要使用大偏移量来查询数据，因为这样很可能导致内存溢出，这个时候可以采用以ObjectId的方法来查询</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>对于数据更新，我们可以使用update方法，在其中指定更新的条件和更新后的数据即可，实例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">condition = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Kevin&#x27;</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">&#x27;age&#x27;</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update(condition, student)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>执行以上语句会返回成功或者失败和影响数据的条数(nMdified)</p><p>对比以上代码，我们还可以使用$set操作符实现数据更新，实例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = collection.update(condition, &#123;<span class="string">&#x27;$set&#x27;</span>: student&#125;)</span><br></pre></td></tr></table></figure><p>这样可以只更新student字典内存在的字段，如果原先还有其他字段，是不会动的，不会被更新，也不会删除；而如果用update，就会把之前的数据全部用student字典替换，要是存在其他字段，会被删除</p><p>官方推荐使用update_one和update_many方法来处理单条和多条数据更新过程，它们的用法更为严格，第二个参数都需要使用$类型操作符作为字典的键名，实例代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">condition = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Kevin&#x27;</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">&#x27;age&#x27;</span>] = <span class="number">26</span></span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">&#x27;$set&#x27;</span>: student&#125;)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># UpdateResult类型</span></span><br><span class="line"><span class="built_in">print</span>(result.matched_count, result.modified_count)  <span class="comment"># 匹配的数据条目和影响的数据条目</span></span><br></pre></td></tr></table></figure><p>我们在来看一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">condition = &#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$gt&#x27;</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">&#x27;$inc&#x27;</span>: &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">1</span>&#125;&#125;)  <span class="comment"># 对age+1对第一条符合的做出改变，如果用update_many就会更新所有被选中的</span></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># UpdateResult类型</span></span><br><span class="line"><span class="built_in">print</span>(result.matched_count, result.modified_count)  <span class="comment"># 匹配的数据条目和影响的数据条目</span></span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除操作比较简单，直接调用remove方法并指定删除条件即可，实例代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = collection.remove(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;kevin&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;ok&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;n&#x27;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>这里依然有两个新方法，delete_one和delete_many，delete_one就是删除第一符合条件的数据，delete_many就是删除所有符合条件的数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = collection.delete_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;kevin&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;result&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result.deleted_count)  <span class="comment"># 1</span></span><br><span class="line">result = collection.delete_many(&#123;<span class="string">&#x27;age&#x27;</span>: &#123;<span class="string">&#x27;$lt&#x27;</span>: <span class="number">25</span>&#125;&#125;)</span><br><span class="line"><span class="built_in">print</span>(result.deleted_count)  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>两个方法返回的结果都是DeletedResult类型，可以调用deleted_coun属性获取删除的数量</p><h4 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h4><p>PyMongo还提供了一些组合方法:</p><p>find_one_and_delete: 查找后删除</p><p>find_one_and_raplace: 查找后替换</p><p>find_one_and_update: 查找后更新</p><h3 id="Redi缓存存储"><a href="#Redi缓存存储" class="headerlink" title="Redi缓存存储"></a>Redi缓存存储</h3><p>Redis是一个基于内存的、高效的键值型非关系型数据库，存取效率极高，而且支持多种数据存储结构，使用起来也非常简单，下面我们来看看:</p><h4 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure><p>以上就是安装了redis-py库，即用来操作Redis的Python包</p><h5 id="Redis和StrictRedis"><a href="#Redis和StrictRedis" class="headerlink" title="Redis和StrictRedis"></a>Redis和StrictRedis</h5><p>StrictRedis类实现了绝大部分官方的Redis命令，参数也一一对应，例如set方法就对应着Redis命令的set方法，而Redis是StrictRedis的子类，其主要功能是向后兼容旧版本库里的几个方法；为了实现兼容，Redis类对方法做了改写，例如将lrem方法中的value和num参数的位置进行了互换，这和Redis命令行参数是不一样的，官方推荐使用StrictRedis！</p><h4 id="连接Redis"><a href="#连接Redis" class="headerlink" title="连接Redis"></a>连接Redis</h4><p>首先我们需要启动redis服务，步骤如下:</p><p>首先申明，我是在一个工作电脑上</p><ul><li><p>打开everything，然后搜索redis，进入到redis的安装目录:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220208/Snipaste_2022-02-08_16-13-31.61m7f9fmij00.webp"                      alt="Snipaste_2022-02-08_16-13-31"                ></p><p>然后在此路径打开cmd，输入以下命令:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe</span><br></pre></td></tr></table></figure><p>以上命令只能启动6379端口，用以下命令可以在7000端口启动redis</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  redis-server.exe redis.windows7000.conf</span><br><span class="line"></span><br><span class="line">​然后就启动了redis</span><br><span class="line"></span><br><span class="line">接下来我们进行连接并测试:</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis</span><br><span class="line"></span><br><span class="line">redis = StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="literal">None</span>)  <span class="comment"># 没有设置password就None吧</span></span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(redis.get(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul><p>运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;Bob&#x27;</span></span><br></pre></td></tr></table></figure><p>以上代码我们传入了Redis的地址，运行端口，使用的数据库和密码信息，在默认不传数据的情况下这4个参数分别为localhost，6379,0和None</p><p>以上代码同时说明我们已经成功连接redis，当然我们也可使用ConnectionPool来连接Redis，实例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = ConnectionPool(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="literal">None</span>)</span><br><span class="line">redis = StrictRedis(connection_pool=pool)</span><br><span class="line">redis.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;tob&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(redis.get(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure><p>另外，ConnectionPool还支持通过URL来构建，URL支持的格式有如下3中:</p><p>redis://[:password]@host:port/db</p><p>rediss://[:password]@host:port/db</p><p>unix://[password]@/path/to/socket.sock?db=db</p><p>这三种url分别表示创建Redis TCP连接、Redis TCP+SSL连接、Redis UNIX socket连接，我们只需要构造其中一种即可，其中password部分如果没有可以省略，下面用URL连接演示下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;redis://foobared@localhost:6379/0&#x27;</span></span><br><span class="line">pool = ConnectionPool.form_url(url)</span><br><span class="line">redis = StrictRedis(connection_pool=pool)</span><br></pre></td></tr></table></figure><h4 id="键操作"><a href="#键操作" class="headerlink" title="键操作"></a>键操作</h4><p>点击<a class="link"   href="https://www.runoob.com/redis/redis-keys.html" >这里跳转<i class="fas fa-external-link-alt"></i></a>，可配合书第152页</p><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>点击<a class="link"   href="https://www.runoob.com/redis/redis-strings.html" >这里跳转<i class="fas fa-external-link-alt"></i></a>，可配合书第153页</p><h4 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h4><p>点击<a class="link"   href="https://www.runoob.com/redis/redis-lists.html" >这里操作<i class="fas fa-external-link-alt"></i></a>，可配合书第154页</p><h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><p>点击<a class="link"   href="https://www.runoob.com/redis/redis-sets.html" >这里跳转<i class="fas fa-external-link-alt"></i></a>，可配合书第155页</p><h4 id="有序集合操作"><a href="#有序集合操作" class="headerlink" title="有序集合操作"></a>有序集合操作</h4><p>点击<a class="link"   href="https://www.runoob.com/redis/redis-sorted-sets.html" >这里跳转<i class="fas fa-external-link-alt"></i></a>，可配合书第157页</p><h4 id="散列操作"><a href="#散列操作" class="headerlink" title="散列操作"></a>散列操作</h4><p>点击<a class="link"   href="https://www.runoob.com/redis/redis-hashes.html" >这里跳转<i class="fas fa-external-link-alt"></i></a>，可配合书第158页</p><h3 id="Elasticsearch搜索引擎存储"><a href="#Elasticsearch搜索引擎存储" class="headerlink" title="Elasticsearch搜索引擎存储"></a>Elasticsearch搜索引擎存储</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;TXT文本文件存储&quot;&gt;&lt;a href=&quot;#TXT文本文件存储&quot; class=&quot;headerlink&quot; title=&quot;TXT文本文件存储&quot;&gt;&lt;/a&gt;TXT文本文件存储&lt;/h3&gt;&lt;p&gt;以txt格式存储&lt;/p&gt;
&lt;p&gt;r: 以只读打开&lt;/p&gt;
&lt;p&gt;rb: 以二进制只读</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python3网络爬虫开发实战第二版第2章-基本库的使用</title>
    <link href="http://example.com/2022/02/07/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC2%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/02/07/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC2%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-07T09:18:30.000Z</published>
    <updated>2022-02-13T14:27:53.261Z</updated>
    
    <content type="html"><![CDATA[<p>Python提供了功能齐全的类库来帮助我们实现需求，最基础的有HTTP库有urllib、requests、httpx等</p><h2 id="urllib的使用"><a href="#urllib的使用" class="headerlink" title="urllib的使用"></a>urllib的使用</h2><p>注意: 在Python2中，有urllib和urllib2两个库来实现HTTP请求的发送，而在Python3中，urllib2库已经不存在了，统一为了urllib</p><p>urllib是Python内置的HTTP请求库，也就是说不需要额外安装，可直接使用；urllib库包括如下4个模块:</p><ul><li>request: 这是最基本的HTTP请求模块，可以模拟请求的发送，就像在浏览器中输入网址然后按下了回车一样，只需要给库方法传入URL以及额外的参数，就可以模拟实现发送请求的过程了</li><li>error: 异常处理模块，如果出现请求异常，那么我们可以捕获这些异常，然后进行重试或其他操作以保证程序运行不会意外终止</li><li>parse: 一个工具模块，提供了许多URL的处理方法，例如拆分、解析、合并等</li><li>robotparser: 主要用来识别网站的robots.txt文件，然后判断哪些网站可以爬，哪些网站不可以爬，它其实用的比较少</li></ul><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><h4 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen"></a>urlopen</h4><p>urllib.request模块提供了最基本的构造HTTP请求的方法，利用这个模块可以模拟浏览器的请求发起过程，同时它还具有处理授权验证，重定向，浏览器Cookie以及其他一些功能</p><p>下面以Python官网为例体验下这个模块:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>运行结果如下图所示:</p><p>我们来看看返回的是个什么类型:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(response))</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">http</span>.<span class="title">client</span>.<span class="title">HTTPResponse</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个HTTPResponse类型的对象，主要包含read、readinto、getheader、getheaders、fileno等方法，以及msg、version、status、reason、debuglevel、closed等属性</p><p>我们来看看实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.status)</span><br><span class="line"><span class="built_in">print</span>(response.getheaders())</span><br><span class="line"><span class="built_in">print</span>(response.getheader(<span class="string">&#x27;Server&#x27;</span>))</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line">[(<span class="string">&#x27;Connection&#x27;</span>, <span class="string">&#x27;close&#x27;</span>), (<span class="string">&#x27;Content-Length&#x27;</span>, <span class="string">&#x27;49476&#x27;</span>), (<span class="string">&#x27;Server&#x27;</span>, <span class="string">&#x27;nginx&#x27;</span>), (<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>), (<span class="string">&#x27;X-Frame-Options&#x27;</span>, <span class="string">&#x27;DENY&#x27;</span>), (<span class="string">&#x27;Via&#x27;</span>, <span class="string">&#x27;1.1 vegur, 1.1 varnish, 1.1 varnish&#x27;</span>), (<span class="string">&#x27;Accept-Ranges&#x27;</span>, <span class="string">&#x27;bytes&#x27;</span>), (<span class="string">&#x27;Date&#x27;</span>, <span class="string">&#x27;Sun, 06 Feb 2022 14:10:46 GMT&#x27;</span>), (<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;283&#x27;</span>), (<span class="string">&#x27;X-Served-By&#x27;</span>, <span class="string">&#x27;cache-iad-kcgs7200085-IAD, cache-nrt18330-NRT&#x27;</span>), (<span class="string">&#x27;X-Cache&#x27;</span>, <span class="string">&#x27;HIT, HIT&#x27;</span>), (<span class="string">&#x27;X-Cache-Hits&#x27;</span>, <span class="string">&#x27;3, 353&#x27;</span>), (<span class="string">&#x27;X-Timer&#x27;</span>, <span class="string">&#x27;S1644156646.362936,VS0,VE0&#x27;</span>), (<span class="string">&#x27;Vary&#x27;</span>, <span class="string">&#x27;Cookie&#x27;</span>), (<span class="string">&#x27;Strict-Transport-Security&#x27;</span>, <span class="string">&#x27;max-age=63072000; includeSubDomains&#x27;</span>)]</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p>下面是urlopen方法的API:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.urlopen(url, data=<span class="literal">None</span>, [timeout,]*, cafile=<span class="literal">None</span>, capath=<span class="literal">None</span>, cadefault=<span class="literal">False</span>, context=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>接下来详细说明下urlopen方法中几个参数的用法:</p><ul><li><p>data参数</p><p>data参数为可选，使用该参数需要使用bytes方法将参数转化为字节流编码格式的内容即bytes类型，如果传递了这个参数，那么它的请求方式就不再是GET了，而是POST了</p><p>以下是实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">data = <span class="built_in">bytes</span>(urllib.parse.urlencode(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;germey&#x27;</span>&#125;), encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.httpbin.org/post&#x27;</span>, data=data)</span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>上面代码中转码时使用了bytes方法，该方法的第一个参数得是str类型，因此用urllib.parse模块里的urlencode方法将字典参数转化为字符串，第二个参数指定编码格式</p><p>此处我们请求的站点是<a class="link"   href="http://www.httpbin.org,它可以提供http请求测试,上面实例的运行结果如下/" >www.httpbin.org，它可以提供HTTP请求测试，上面实例的运行结果如下<i class="fas fa-external-link-alt"></i></a>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;data&quot;</span>: <span class="string">&quot;&quot;</span>, </span><br><span class="line">  <span class="string">&quot;files&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;form&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;germey&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;identity&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;11&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;www.httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Python-urllib/3.7&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-61ffda7a-05a2c9b60ba676290898d9d9&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;json&quot;</span>: null, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;182.101.213.95&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.httpbin.org/post&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>timeout参数</p><p>直接上实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>, timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="built_in">print</span>(response.read())</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  File <span class="string">&quot;C:\Users\Administrator\AppData\Local\Programs\Python\Python37\lib\urllib\request.py&quot;</span>, line <span class="number">1360</span>, <span class="keyword">in</span> https_open</span><br><span class="line">    context=self._context, check_hostname=self._check_hostname)</span><br><span class="line">  File <span class="string">&quot;C:\Users\Administrator\AppData\Local\Programs\Python\Python37\lib\urllib\request.py&quot;</span>, line <span class="number">1319</span>, <span class="keyword">in</span> do_open</span><br><span class="line">    <span class="keyword">raise</span> URLError(err)</span><br><span class="line">urllib.error.URLError: &lt;urlopen error timed out&gt;</span><br></pre></td></tr></table></figure><p>利用try except语句也可实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.error</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(<span class="string">&#x27;https://www.httpbin.org/get&#x27;</span>, timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(e.reason, socket.timeout):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;time out&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time out</span><br></pre></td></tr></table></figure></li><li><p>其他参数</p><p>除了以上两个参数，urlopen还有context参数，该参数必须是ssl.SSLContext类型，用来指定SSL的设置，此外，cafile和capath这连个参数分别用来指定CA证书和其路径，这两个在请求HTTPS链接时会有用，cadefault参数现在已经弃用了，其默认值为Flase，到这里我们就讲完了urlopen方法的用法</p></li></ul><h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>urlopen可以发起最基本的请求，但它那几个简单的参数并不足以构建一个完整的请求，如果需要往请求中加入Headers等信息，就需要使用更强大的Request来构建请求了</p><p>来看看最基本的实例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">request = urllib.request.Request(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"><span class="built_in">print</span>(response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><p>我们来看下可以通过怎样的参数来构造Request类，构造方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urllib.request.Request(url, data=<span class="literal">None</span>, headers=&#123;&#125;, origin_req_host=<span class="literal">None</span>, unverifiable=<span class="literal">False</span>, method=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li>url为请求的URL，这是必传参数，其他都是可选参数</li><li>data如果要传数据，必须传bytes类型的，如果数据是字典，可以先用urllib.parse模块里的urlencode方法进行编码</li><li>第三个参数是一个字典，这是请求头，可以用headers参数直接构造，也可以调用请求实例的add_heade方法添加</li><li>origin_req_host指的是请求方的host名称或者IP地址</li><li>unverifiable表示请求是否是无法验证的，默认取值是False，意思是用户没有足够的权限来接收这个请求的结果</li><li>method是一个字符串，指示请求使用的方法</li></ul><p>由于urllib使用不是太频繁，详情见书本</p><h2 id="requests的使用"><a href="#requests的使用" class="headerlink" title="requests的使用"></a>requests的使用</h2><p>我们感觉使用urllib不太方便，接下来我们来看看requests库的强大之处叭</p><p>首先我们需要安装requests:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install r</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python提供了功能齐全的类库来帮助我们实现需求，最基础的有HTTP库有urllib、requests、httpx等&lt;/p&gt;
&lt;h2 id=&quot;urllib的使用&quot;&gt;&lt;a href=&quot;#urllib的使用&quot; class=&quot;headerlink&quot; title=&quot;urllib的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python3网络爬虫开发实战第二版第1章-爬虫基础</title>
    <link href="http://example.com/2022/01/28/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC1%E7%AB%A0-%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/01/28/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%AC1%E7%AB%A0-%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-28T07:43:07.000Z</published>
    <updated>2022-02-13T14:27:40.445Z</updated>
    
    <content type="html"><![CDATA[<p>本章我们将了解到HTTP原理、网页的基础知识、爬虫的基本原理、Cookie的基本原理、多进程和多线程的基本原理等，了解这些内容有助于我们更好地理解和编写网络爬虫相关的程序</p><h2 id="HTTP基本原理"><a href="#HTTP基本原理" class="headerlink" title="HTTP基本原理"></a>HTTP基本原理</h2><h3 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h3><p>URL: Uniform Resource Location(统一资源定位符)</p><p>URI: Uniform Resource Identifier(统一资源标识符)</p><p>URL是大家所熟知的，它指向网络服务器上的某个资源，而其实URI有两个子类，一个是上面提到的URL，还有一个叫做URN(Uniform Resource Name)，URN只为资源命名而不指定如何定位资源，也就是说<strong>URI包括了URL和URN</strong>；</p><h3 id="URL的基本组成格式"><a href="#URL的基本组成格式" class="headerlink" title="URL的基本组成格式"></a>URL的基本组成格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme://[username:password@]hostname[:port][path][;parameters][?query][#fragment]</span><br></pre></td></tr></table></figure><p>scheme: 协议，常用的协议有http、https、ftp等，另外，scheme也常被称作protocol，二者都代表协议的意思</p><p>username、password: 用户名和密码，在某些情况下URL需要提供用户名和密码才能访问</p><p>hostname: 主机地址，或IP地址</p><p>port: 端口，这是服务器设定的服务端口，但是有些URL中没有端口信息，这是使用了默认的端口，http协议的默认端口是80，https协议的默认端口是443</p><p>path: 路径，指的是网络资源在服务器中的指定位置</p><p>parameters: 参数，用来指定访问某个资源时的附加信息，这个用的比较少</p><p>query: 查询，用来查询某类资源，如果有多个查询，则用&amp;隔开</p><p>fragment: 片段，它是对资源描述的部分补充，可以理解为资源内部的书签</p><h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p>在爬虫中，我们主要接触到的协议通常是基于http或https协议的，因此这里首先了解下这两个协议:</p><p>HTTP的全称是Hypertext Transfer Protocol，中文名为超文本传输协议，其作用是<strong>把超文本数据从网络传输到本地浏览器，能够保证高效而准确地传输超文本文档</strong>，目前被人们广泛使用的是HTTP1.1版本，当然，现在也有不少网站支持HTTP2.0</p><p>HTTPS的全称是<code>Hyper Text Transfer Protocol over SecureSocket Layer</code>，是以安全为目标的HTTP通道，简单讲就是<strong>HTTP的安全版，即在HTTP下加入SSL层</strong>，简称HTTPS</p><p>HTTPS的安全基础是SSL，因此通过该协议传输的内容都是经过SSL加密的，SSL的主要作用有以下两种:</p><ul><li>建立一个信息安全通道，保证数据传输的安全性</li><li>确认网站的真实性，凡是使用了HTTPS协议的网站，都可以通过单击浏览器地址栏的锁头编制来查看网站认证之后的真实信息，此外还可以通过CA机构颁发的安全签章来查询</li></ul><p>HTTP和HTTPS协议都属于计算机网络中的应用层协议，其下层是基于TCP协议实现的，TCP协议属于计算机网络中的传输层协议，包括建立连接时的三次握手和断开时的四次挥手等过程</p><h3 id="HTTP请求过程"><a href="#HTTP请求过程" class="headerlink" title="HTTP请求过程"></a>HTTP请求过程</h3><p>在浏览器地址栏输入一个URL，按下回车之后便可观察到对应的页面内容，实际上，这个过程是浏览器先向网站所在的服务器发送一个请求，网站服务器接收到请求后对其处理和解析，然后返回对应的响应，接着传回浏览器；由于响应里包含页面的源代码等响应内容，所以浏览器再对其进行解析，便将网页呈现出来</p><p>关于浏览器开发者工具的使用<a class="link"   href="http://kest.club/2022/01/19/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/" >点此跳转<i class="fas fa-external-link-alt"></i></a></p><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>请求，英文为Request，由客户端发往服务器，分为四部分内容: 请求方法(Request Method)、请求的网址(Request URL)，请求头(Request head)、请求体(Request body)</p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>请求方法，用于标识客户端请求服务端的方式，常见的请求方法，有两种: GET和POST，在浏览器中直接输入URL并回车，便发起了一个GET请求，请求参数会直接包含到URL里；POST请求大多会在提交表单时发起，例如，对于一个登录表单，输入用户名和密码后，单击登录按钮，这时通常会发起一个POST请求，其数据通常会以表单的形式传输，而不会体现在URL中</p><h5 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h5><ul><li>GET请求中的参数包含在URL里面，数据可以在URL中看到；而POST请求的URL不会包含这些数据，数据都是通过表单形式传输，会包含在请求体中</li><li>GET请求提交的数据最多只有1024字节，POST方式则没有限制</li></ul><h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>响应，即Response，由服务器返回给客户端，可以分为三部分: 响应状态码(HTTP Status Code)，响应头(Response head)，响应体(Response body)</p><h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><p>详情<a class="link"   href="http://kest.club/2022/01/19/%E5%85%B3%E4%BA%8EHTTP%E7%8A%B6%E6%80%81%E7%A0%81/" >点击这里<i class="fas fa-external-link-alt"></i></a></p><h2 id="Web网页基础"><a href="#Web网页基础" class="headerlink" title="Web网页基础"></a>Web网页基础</h2><h3 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h3><p>网页可以分为三大部分: HTML、CSS和JS</p><ul><li>HTML: HTML的全称为<a class="link"   href="https://baike.baidu.com/item/%E8%B6%85%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6972570" >超文本标记语言<i class="fas fa-external-link-alt"></i></a>，是一种<a class="link"   href="https://baike.baidu.com/item/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/5964436" >标记语言<i class="fas fa-external-link-alt"></i></a>。它包括一系列<a class="link"   href="https://baike.baidu.com/item/%E6%A0%87%E7%AD%BE/2440469" >标签<i class="fas fa-external-link-alt"></i></a>．通过这些标签可以将网络上的<a class="link"   href="https://baike.baidu.com/item/%E6%96%87%E6%A1%A3/1009768" >文档<i class="fas fa-external-link-alt"></i></a>格式统一，使分散的<a class="link"   href="https://baike.baidu.com/item/Internet/272794" >Internet<i class="fas fa-external-link-alt"></i></a>资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性<a class="link"   href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC/5443630" >文本<i class="fas fa-external-link-alt"></i></a>，HTML命令可以说明<a class="link"   href="https://baike.baidu.com/item/%E6%96%87%E5%AD%97/612910" >文字<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://baike.baidu.com/item/%E5%9B%BE%E5%BD%A2/773307" >图形<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://baike.baidu.com/item/%E5%8A%A8%E7%94%BB/206564" >动画<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://baike.baidu.com/item/%E5%A3%B0%E9%9F%B3/33686" >声音<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://baike.baidu.com/item/%E8%A1%A8%E6%A0%BC/3371820" >表格<i class="fas fa-external-link-alt"></i></a>、<a class="link"   href="https://baike.baidu.com/item/%E9%93%BE%E6%8E%A5/2665501" >链接<i class="fas fa-external-link-alt"></i></a>等</li><li>CSS: 层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现<a class="link"   href="https://baike.baidu.com/item/HTML" >HTML<i class="fas fa-external-link-alt"></i></a>（<a class="link"   href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073" >标准通用标记语言<i class="fas fa-external-link-alt"></i></a>的一个应用）或<a class="link"   href="https://baike.baidu.com/item/XML" >XML<i class="fas fa-external-link-alt"></i></a>（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化</li><li>JavaScript: （简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的<a class="link"   href="https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/9845131" >编程语言<i class="fas fa-external-link-alt"></i></a>。虽然它是作为开发<a class="link"   href="https://baike.baidu.com/item/Web/150564" >Web<i class="fas fa-external-link-alt"></i></a>页面的<a class="link"   href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/1379708" >脚本语言<i class="fas fa-external-link-alt"></i></a>而出名，但是它也被用到了很多非<a class="link"   href="https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8/213911" >浏览器<i class="fas fa-external-link-alt"></i></a>环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持<a class="link"   href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089" >面向对象<i class="fas fa-external-link-alt"></i></a>、命令式、声明式、<a class="link"   href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0/301912" >函数<i class="fas fa-external-link-alt"></i></a>式编程范式</li></ul><h3 id="网页的结构"><a href="#网页的结构" class="headerlink" title="网页的结构"></a>网页的结构</h3><p>看示例代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span>        <span class="comment">&lt;!-- 声明文档。定义html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>         <span class="comment">&lt;!-- 元素是页面的根元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>                     <span class="comment">&lt;!-- 元素包含文档的元数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>   <span class="comment">&lt;!-- 定义网页编码格式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个项目<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  <span class="comment">&lt;!-- 元素描述了文档的标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="comment">&lt;!--元素包含了页面可以看见的内容。定义文档主体。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这个p是段落。可以把很多文字放到里面去。比如这是一段文字。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是h1标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="comment">&lt;!-- 通过&lt;h1&gt;-&lt;h6&gt;标签来定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是h2标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是h3标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>这是h4标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>这是h5标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>这是h6标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span><span class="comment">&lt;!--定义水平线--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。插入图片<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.baidu.com&quot;</span>&gt;</span>这是跳转到的百度链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  <span class="comment">&lt;!--&lt;a&gt;标签来定义。在 href 属性中指定链接的地址。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="comment">&lt;!--换行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/one.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span>&gt;</span>   <span class="comment">&lt;!--图像是通过标签 &lt;img&gt; 来定义的。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/two.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文本格式化的标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>这是一句话。定义粗体<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>这是一句话。定义着重文字<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>这是一句话。定义斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span>这是一句话。定义小字号<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span>这是一句话。定义加重语气<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>插入<span class="tag">&lt;<span class="name">sub</span>&gt;</span>这是一句话<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>定义下标字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>插入<span class="tag">&lt;<span class="name">sup</span>&gt;</span>这是一句话<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>定义上标字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ins</span>&gt;</span>这是一句话。定义插入字<span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">del</span>&gt;</span>这是一句话。定义删除字<span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 计算机输出标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是计算机输出标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">code</span> &gt;</span>#定义计算机代码print(&quot;hello world!&quot;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>定义键盘码<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">samp</span>&gt;</span>定义计算机代码样本<span class="tag">&lt;/<span class="name">samp</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">var</span>&gt;</span>定义变量<span class="tag">&lt;/<span class="name">var</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pre</span>&gt;</span>定义预格式文本<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注释：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>这些标签常用于显示计算机/编程代码。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- HTML 引文 引用 标签定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span>&gt;</span>定义缩写<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span>定义地址<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">bdo</span> <span class="attr">dir</span>=<span class="string">&quot;rtl&quot;</span>&gt;</span>该段落文字从右到左显示。<span class="tag">&lt;/<span class="name">bdo</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>定义长的引用<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">q</span>&gt;</span>定义短的引用<span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cite</span>&gt;</span>定义引用、引证<span class="tag">&lt;/<span class="name">cite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dfn</span>&gt;</span>定义一个定义项目<span class="tag">&lt;/<span class="name">dfn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="节点树及节点间的关系"><a href="#节点树及节点间的关系" class="headerlink" title="节点树及节点间的关系"></a>节点树及节点间的关系</h3><p>在HTML中，所有标签定义的内容都是节点，这些节点构成一个HTML节点树，也叫HTML DOM树；先来看下什么是DOM，DOM是W3C(万维网联盟)的标准，英文全称是Document Object Model，即文档对象模型，它定义了访问HTML和XML文档的标准，根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点</p><ul><li>整个网站文档是一个文档节点</li><li>每个html标签对应一个根节点，即上例中的html标签，它属于一个根节点</li><li>节点内的文本是文本节点，比如a节点代表一个超链接，它内部的文本也被认为是一个文本节点</li><li>每个节点的属性是属性节点，比如a节点有一个href属性，它就是一个属性节点</li><li>注释是注释节点，在HTML中有特殊的语法会被解析为注释，它也会对应一个节点</li></ul><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><p>详情请见: <a class="link"   href="https://www.w3school.com.cn/cssref/css_selectors.asp" >https://www.w3school.com.cn/cssref/css_selectors.asp<i class="fas fa-external-link-alt"></i></a></p><h4 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h4><p>详情请见: <a class="link"   href="https://www.w3school.com.cn/xpath/index.asp" >https://www.w3school.com.cn/xpath/index.asp<i class="fas fa-external-link-alt"></i></a></p><h2 id="爬虫的基本原理"><a href="#爬虫的基本原理" class="headerlink" title="爬虫的基本原理"></a>爬虫的基本原理</h2><h3 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h3><p>简单点讲，爬虫就是<strong>获取网页并提取和保存信息的自动化程序</strong></p><h4 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h4><p>爬虫的工作首先是获取网页的源代码，源代码里包含网页的部分有用信息，所以只要获取源代码，就可以从中提取想要的信息了，Python提供了许多库，可以帮助我们获取源代码，比如urllib，requests等，我们可以用这些库完成HTTP请求操作，除此之外，请求和响应都可以用类库提供的数据结构来表示，因此得到相应之后只需要解析数据结构中的body部分，即可得到网页的源代码</p><h4 id="提取信息"><a href="#提取信息" class="headerlink" title="提取信息"></a>提取信息</h4><p>提取网页的源代码之后，接下来的就是分析源代码，从中提取我们想要的数据，首先，最通用的提取方式是采用正则表达式，这是一个万能的方法，但是构造正则表达式的过程比较复杂且容易出错；另外，由于网页结构具有一定的规则，所以还有一些库是根据网页节点属性、CSS选择器或Xpath来提取网页信息的，如BeautifulSoup、pyquery，lxml等，使用这些库，可以高效地从源代码中提取网页信息，如节点地属性，文本值等</p><h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h4><p>提取数据之后，我们一般会将提取到的数据保存到某处以便后续使用，保存数据的形式多种多样，可以简单保存为TXT文本或者JSON文本，也可以保存到数据库，如MySQL和MongoDB等，还可保存到远程服务器如借助SFTP进行操作等</p><h4 id="自动化程序"><a href="#自动化程序" class="headerlink" title="自动化程序"></a>自动化程序</h4><p>自动化程序的意思是爬虫可以代替人来完成上述操作，我们当然可以手动提取网页中的信息，但是当量特别大或者想快速大量获取数据的时候，肯定还是借助程序快，爬虫就是代替我们完成爬取工作的自动化程序，它可以在爬取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行</p><h3 id="能爬怎样的数据"><a href="#能爬怎样的数据" class="headerlink" title="能爬怎样的数据"></a>能爬怎样的数据</h3><p>网页中存在各种各样的信息，最常见的便是常规网页，这些网页对应着HTML代码，而最常抓取的便是HTML源代码</p><p>另外，可能有些网页返回的不是HTML代码，而是一个JSON字符串(其中API接口大多采用这种方式)，这种格式的数据方便传输和解析，爬虫同样可以抓取这些数据，而且数据提取会更加方便；</p><p>网页中还包含着各种二进制数据，如图片、视频音频文件，利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成对应的文件名</p><p>除了上述数据，网页中还有各种扩展名文件，如CSS、Javascript和配置文件等</p><h3 id="Javascript渲染的页面"><a href="#Javascript渲染的页面" class="headerlink" title="Javascript渲染的页面"></a>Javascript渲染的页面</h3><p>对于Javascript渲染的网页，我们可以分析源代码后台Ajax接口，也可使用Selenium、Splash、Pyppeteer、Playwright这样的库来模拟Javascript渲染</p><h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h2><h3 id="神秘的凭证"><a href="#神秘的凭证" class="headerlink" title="神秘的凭证"></a>神秘的凭证</h3><p>很多页面是需要登录之后才可以查看的，按照一般的逻辑，输入用户名和密码登陆网站，肯定是拿到了一种类似凭证的东西，有了这个凭证，才能保持登录的状态，访问那些登录之后才能看到的页面</p><p>那么这种神秘的凭证到底是什么呢，其实它就是Session和Cookie共同产生的结果</p><h3 id="无状态HTTP"><a href="#无状态HTTP" class="headerlink" title="无状态HTTP"></a>无状态HTTP</h3><p>我们需要知道HTTP的一个特点: <strong>无状态</strong></p><p>什么叫无状态呢，也就是说<strong>HTTP协议对事物处理是没有记忆能力的，或者说服务并不知道客户端处于什么状态</strong>，这时，两种用于保持HTTP连接状态的技术出现了，分别是Session和Cookie；<strong>Session在服务端</strong>，也就是网站的服务器，用来保存用户的Session信息，<strong>Cookie在客户端</strong>，也可以理解为在浏览器端，有了Cookie，浏览器在下次访问相同网页时就会自动附带上它，并发送给服务器，服务器通过识别Cookie鉴定出是哪个用户在访问，然后判断此用户是否处于登录状态，并返回对应的响应</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session译为会话，其本意是指有始有终的一系列动作、消息，例如打电话时，从拿起电话拨号到挂断电话之间的一系列过程就可以称为一个Session</p><p>而在Web中，Session对象用来存储特定用户Session所需的属性及配置信息，这样，当用户在应用程序的页面之间跳转时，存储在Session对象中的变量将不会丢失，会在整个Session中一直保存下去；当用户请求来自应用程序的页面时，如果该用户还没有Session，那么Web服务器将自动创建一个Session对象，当Session过期或被放弃后，服务器将终止该Session</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>值某些网站为了鉴别用户身份、进行Session跟踪而存储在用户本地终端上的数据</p><h4 id="Session维持"><a href="#Session维持" class="headerlink" title="Session维持"></a>Session维持</h4><p>如何利用Cookie保持状态呢，在客户端第一次请求服务器时，服务器会返回一个响应头中带有Set-Cookie字段的响应给客户端，这个字段用来标记用户；客户端浏览器会把Cookie保存起来，当下一次请求相同的网站时，把保存的Cookie放到请求头中一起交给服务器；Cookie中携带着Session ID相关信息，服务器通过检查Cookie即可找到对应的Session，继而通过判断Session辨认用户状态；如果Session当前是有效的，就证明用户处于登录状态，此时服务器返回登录之后才可以查看的网页内容，浏览器再进行解析即可</p><p>反之，如果传给服务器的Cookie是无效的，或者Session已经过期了，客户端将不能继续访问页面</p><p>Cookie和Session需要配合，一个在客户端，一个在服务端，二者共同协作，就实现了登录控制</p><h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h4><p>接下来，我们看看Cookie都包含哪些内容:</p><p>Name: Cookie的名称，Cookie一旦创建，名称便不可更改</p><p>Value: Cookie的值，如果值为Unicode字符，则需要为字符编码；如果值为二进制数据，则需要使用base64编码</p><p>Domain: 指定可以访问该Cookie的域名，例如设置Domain为.zhihu.com，表示所有以.zhihu.com结尾的域名都可以访问该Cookie</p><p>Path: Cookie的使用路径，如果设置为/path/，则只有该路径为/path/的页面才可以访问该Cookie，如果设置为/，则本域名下的所有页面都可以访问该Cookie</p><p>Max-Age: Cookie失效的时间，单位为秒，常和Expires一起使用，通过此属性可以计算出Cookie的有效时间，Max-Age如果为正数，则表示Cookie在Max-Age秒之后失效，如果为负数，则Cookie在关闭浏览器时失效，而且浏览器不会以任何形式保存该Cookie</p><p>Size: Cookie的大小</p><p>HTTP: Cookie的httponly属性，若此属性为true，则只有在HTTP Headers中才会带有此Cookie的信息，而不能通过document.cookie来访为此Cookie</p><p>Secure: 是否允许使用安全协议传输Cookie，安全协议有HTTPS和SSL等，使用这些协议在网络上传输数据之前会先将数据加密，其默认值为false</p><h4 id="会话Cookie和持久Cookie"><a href="#会话Cookie和持久Cookie" class="headerlink" title="会话Cookie和持久Cookie"></a>会话Cookie和持久Cookie</h4><p>会话Cookie就是把Cookie放在浏览器内存里，关闭浏览器之后，Cookie即失效，持久Cookie则会把Cookie保存在客户端的硬盘中，下次还可以继续使用，用于长久保持用户的登录状态</p><p>其实没有会话Cookie和持久Cookie之说，只是Maxage或者Expires字段决定了Cookie失效的时间</p><p>因此，一些持久化登录的网站实际上就是把Cookie的有效时间和Session有效期设置得比较长</p><h4 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h4><p>关闭浏览器不会删除Session，关闭浏览器可能会删除会话Cookie，所以就找不到Session ID，如果是持久Cooike就能找到Session ID</p><h3 id="代理的基本原理"><a href="#代理的基本原理" class="headerlink" title="代理的基本原理"></a>代理的基本原理</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>代理实际上就是指代理服务器，形象点说代理就是网络信息的中转站</p><h4 id="代理的作用"><a href="#代理的作用" class="headerlink" title="代理的作用"></a>代理的作用</h4><ul><li>突破自身IP的限制，访问一些平时不能访问的站点</li><li>访问一些单位或团体的内部资源</li><li>提高访问速度，通常代理服务器会设置一个较大的硬盘缓冲区，当有外界信息通过时，会同时将其保存到自己的缓冲区中，当其他用户访问相同的信息时，直接从缓冲区中取出信息，所以提高了访问速度</li><li>隐藏真实的IP</li></ul><h4 id="爬虫代理"><a href="#爬虫代理" class="headerlink" title="爬虫代理"></a>爬虫代理</h4><p>爬虫中使用代理，可以隐藏我们真实的IP，让服务器误以为是代理服务器在请求自己，这样在爬取过程中不断更换代理，就可以实现避免IP被封锁，达到很好的爬取效果</p><h4 id="代理分类"><a href="#代理分类" class="headerlink" title="代理分类"></a>代理分类</h4><h5 id="根据协议区分"><a href="#根据协议区分" class="headerlink" title="根据协议区分"></a>根据协议区分</h5><ul><li>FTP代理服务器: 主要用于访问FTP服务器，一般有上传下载以及缓存功能，端口一般我为21、2121等</li><li>HTTP代理服务器: 主要用于访问网页，一般有内容过滤和缓存功能，端口一般为80，8080</li><li>SSL/TLS代理: 主要用于访问加密网站，一般有SSL或TLS加密功能(最高支持128位加密强度)，端口一般为443</li><li>RTSP代理: 主要用于Realplyer访问流媒体服务器，一般有缓存功能，端口一般为554</li><li>Telnet代理: 主要用于Telnet远程控制(黑客入侵计算机时常用于隐藏身份)，端口一般为23</li><li>POP3/SMTP代理: 主要用于以POP3/SMTP方式收发邮件，一般有缓存功能，端口一般为110/25</li><li>SOCKS代理: 只是单纯传递数据包，不关心具体协议和用法，所以速度快很多，一般有缓存功能，端口一般为1080</li></ul><h5 id="根据匿名程度区分"><a href="#根据匿名程度区分" class="headerlink" title="根据匿名程度区分"></a>根据匿名程度区分</h5><ul><li>高度匿名代理: 数据包会原封不动地转发</li><li>普通匿名代理: 数据包会做一些处理</li><li>透明代理: 会告诉服务器客户端真实的IP</li><li>间谍代理: 由组织或个人创建的代理服务器</li></ul><h5 id="常见代理设置"><a href="#常见代理设置" class="headerlink" title="常见代理设置"></a>常见代理设置</h5><ul><li>对于网上的免费代理，最好使用高度代理，可以在使用前把所有代理都抓取下来筛选一遍拿到可用代理，也可以进一步维护一个代理池</li><li>使用付费代理服务，使用付费的代理会好用很多</li><li>ADSL拨号，拨一次号换一次IP，稳定性高，也是一种比较有效的方法</li><li>蜂窝代理，使用4G或5G网卡等制作的代理，由于使用蜂窝网络作为代理的情形比较少，因此整体被封锁的概率会比较低，但搭建蜂窝代理的成本是比较高的</li></ul><h2 id="多线程和多进程的基本原理"><a href="#多线程和多进程的基本原理" class="headerlink" title="多线程和多进程的基本原理"></a>多线程和多进程的基本原理</h2><h3 id="多线程的含义"><a href="#多线程的含义" class="headerlink" title="多线程的含义"></a>多线程的含义</h3><p>先说说什么是进程:</p><p>进程可以理解为一个可以独立运行的程序单位，例如打开一个浏览器，这就是开启了一个浏览器进程；在一个进程中可以同时处理很多事情，比如浏览器可以打开很多个选项卡，这一个个选项卡其实就是一个个线程，<strong>进程就是线程的集合，进程是由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的最小运行单位</strong></p><p>有了上面的铺垫，我们可以了解到，多线程就是一个进程中同时执行多个线程，上面的浏览器进程就是典型的多线程</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>我们知道，在计算机中运行一个程序，底层是通过处理器运行一条条指令来实现的</p><p>并发是指多个线程对应的多条指令被快速轮换地执行</p><p>并行是指同一时刻有多条指令在多个处理器上同时执行</p><p>例如，系统处理器需要同时运行多个线程，<strong>如果系统处理器只有一个核，那它只能通过并发地方式来运行这些线程</strong>，然而如果系统处理器有多个核，那么在一个核执行一个线程地同时，另一个核可以执行另一个线程，这样两个线程就实现了并行执行</p><h3 id="多线程适用场景"><a href="#多线程适用场景" class="headerlink" title="多线程适用场景"></a>多线程适用场景</h3><p>如果任务不全是计算密集型任务，就可以使用多线程来提高程序的整体执行效率，尤其对于网络爬虫这种IO密集型任务，使用多线程能够大大提高程序整体的爬取效率</p><h3 id="多进程的含义"><a href="#多进程的含义" class="headerlink" title="多进程的含义"></a>多进程的含义</h3><p>顾名思义，<strong>多进程就是同时运行多个进程</strong>，由于进程就是线程的集合，而且进程是由一个或多个线程构成的，所以<strong>多进程就意味着有大于等于进程数量的线程在同时运行</strong></p><h3 id="Python中的多线程和多进程"><a href="#Python中的多线程和多进程" class="headerlink" title="Python中的多线程和多进程"></a>Python中的多线程和多进程</h3><p>Python中GIL(全局解释器锁，其设计之初是出于对数据安全的考虑)的限制导致不论是在单核还是多核条件下，同一时刻都只能运行一个线程，这使得Python多线程无法发挥多核并行的优势</p><p>在Python的多线程下，每个线程的执行方式分如下三步:</p><ul><li>获取GIL</li><li>执行对应线程的代码</li><li>释放GIL</li></ul><p>而对于多进程来说，每个进程都有属于自己的GIL，所以在多核处理器下，多进程的运行是不会受GIL影响的，也就是说，多进程能够更好地发挥多核优势</p><p>不过，对于爬虫这种IO密集型任务来说，多线程和多进程产生的影响差别并不大；但对于计算密集型任务来说，由于GIL的存在，Python多线程的整体运行效率在多核情况下可能反而比单核更低，而Python的多进程相比多线程，运行效率在多核的情况下比单核会有成倍提升</p><p>从整体来说，Python的多进程比多线程更有优势，所以，如果条件允许的话，尽量使用多进程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本章我们将了解到HTTP原理、网页的基础知识、爬虫的基本原理、Cookie的基本原理、多进程和多线程的基本原理等，了解这些内容有助于我们更好地理解和编写网络爬虫相关的程序&lt;/p&gt;
&lt;h2 id=&quot;HTTP基本原理&quot;&gt;&lt;a href=&quot;#HTTP基本原理&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js逆向腾讯动漫</title>
    <link href="http://example.com/2022/01/26/js%E9%80%86%E5%90%91%E8%85%BE%E8%AE%AF%E5%8A%A8%E6%BC%AB/"/>
    <id>http://example.com/2022/01/26/js%E9%80%86%E5%90%91%E8%85%BE%E8%AE%AF%E5%8A%A8%E6%BC%AB/</id>
    <published>2022-01-26T09:31:30.000Z</published>
    <updated>2022-01-26T10:44:11.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标网站"><a href="#目标网站" class="headerlink" title="目标网站"></a>目标网站</h3><p><a class="link"   href="https://ac.qq.com/ComicView/index/id/531490/cid/1" >点击跳转<i class="fas fa-external-link-alt"></i></a></p><h3 id="网站分析"><a href="#网站分析" class="headerlink" title="网站分析"></a>网站分析</h3><p>首先我们打开开发者工具，然后下滑动漫画，会发现一张张图片被加载出来:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_17-34-13.3o5kpreknbs.webp"                      alt="Snipaste_2022-01-26_17-34-13"                ></p><p>但是它又不是ajax方式的:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_17-35-56.72x5n5xna380.webp"                      alt="Snipaste_2022-01-26_17-35-56"                ></p><p>然后来看看是不是在js代码中，我们先取一部分搜索下:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_17-37-59.545sloo9lzk0.webp"                      alt="Snipaste_2022-01-26_17-37-59"                ></p><p>发现是没有的:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_17-39-13.78i7xgfimcw0.webp"                      alt="Snipaste_2022-01-26_17-39-13"                ></p><p>然后就只有一种可能，那就是在页面的代码中，这种方式肯定涉及到加密:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_17-41-55.17hhu0k0toqk.webp"                      alt="Snipaste_2022-01-26_17-41-55"                ></p><p>如上图，在页面的代码中发现了一段可疑的代码，怀疑这里有猫腻</p><p>然后我们就搜索这个DATA，搜素的时候注意大小写:</p><p>然后我们发现只有一个js文件中出现了DATA:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_17-49-02.g8080q6enqo.webp"                      alt="Snipaste_2022-01-26_17-49-02"                ></p><p>我们定位到这个js文件然后格式化下，继续搜索:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_17-50-28.50mdr6qmyf40.webp"                      alt="Snipaste_2022-01-26_17-50-28"                ></p><p>我们发现只有第一个DATA参数有点猫腻，然后我们打个断点看看:</p><p>发现这里的变量_V里面就有我们想要的图片数据:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_17-53-18.6ge3wybq9zk0.webp"                      alt="Snipaste_2022-01-26_17-53-18"                ></p><p>去掉双引号放在浏览器的地址栏发现就是我们要的图片数据</p><p>然后我们来看看这个_v是怎么来的，从哪里来的</p><p>看了一圈_v参数，我们发现第二个·<code>_v</code>参数前面的一个<a class="link"   href="https://www.cnblogs.com/gtscool/p/12607917.html" >立即执行函数<i class="fas fa-external-link-alt"></i></a>有点可疑，这是一个经过加密后的函数(经过eval编码加密):</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_18-05-27.3wvwak3txl80.webp"                      alt="Snipaste_2022-01-26_18-05-27"                ></p><p>我们可以用<a class="link"   href="https://wangye.org/tools/scripts/eval/" >这个网站<i class="fas fa-external-link-alt"></i></a>进行解密:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_18-06-13.2e9v6oewl2dc.webp"                      alt="Snipaste_2022-01-26_18-06-13"                ></p><p>以下是解密后的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _keyStr = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.decode = <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        b, d, h, f, g, e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (c = c.replace(<span class="regexp">/[^A-Za-z0-9\+\/\=]/g</span>, <span class="string">&quot;&quot;</span>); e &lt; c.length;) b = _keyStr.indexOf(c.charAt(e++)),</span><br><span class="line">        d = _keyStr.indexOf(c.charAt(e++)),</span><br><span class="line">        f = _keyStr.indexOf(c.charAt(e++)),</span><br><span class="line">        g = _keyStr.indexOf(c.charAt(e++)),</span><br><span class="line">        b = b &lt;&lt; <span class="number">2</span> | d &gt;&gt; <span class="number">4</span>,</span><br><span class="line">        d = (d &amp; <span class="number">15</span>) &lt;&lt; <span class="number">4</span> | f &gt;&gt; <span class="number">2</span>,</span><br><span class="line">        h = (f &amp; <span class="number">3</span>) &lt;&lt; <span class="number">6</span> | g,</span><br><span class="line">        a += <span class="built_in">String</span>.fromCharCode(b),</span><br><span class="line">        <span class="number">64</span> != f &amp;&amp; (a += <span class="built_in">String</span>.fromCharCode(d)),</span><br><span class="line">        <span class="number">64</span> != g &amp;&amp; (a += <span class="built_in">String</span>.fromCharCode(h));</span><br><span class="line">        <span class="keyword">return</span> a = _utf8_decode(a)</span><br><span class="line">    &#125;;</span><br><span class="line">    _utf8_decode = <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> a = <span class="string">&quot;&quot;</span>,</span><br><span class="line">        b = <span class="number">0</span>,</span><br><span class="line">        d = c1 = c2 = <span class="number">0</span>; b &lt; c.length;) d = c.charCodeAt(b),</span><br><span class="line">        <span class="number">128</span> &gt; d ? (a += <span class="built_in">String</span>.fromCharCode(d), b++) : <span class="number">191</span> &lt; d &amp;&amp; <span class="number">224</span> &gt; d ? (c2 = c.charCodeAt(b + <span class="number">1</span>), a += <span class="built_in">String</span>.fromCharCode((d &amp; <span class="number">31</span>) &lt;&lt; <span class="number">6</span> | c2 &amp; <span class="number">63</span>), b += <span class="number">2</span>) : (c2 = c.charCodeAt(b + <span class="number">1</span>), c3 = c.charCodeAt(b + <span class="number">2</span>), a += <span class="built_in">String</span>.fromCharCode((d &amp; <span class="number">15</span>) &lt;&lt; <span class="number">12</span> | (c2 &amp; <span class="number">63</span>) &lt;&lt; <span class="number">6</span> | c3 &amp; <span class="number">63</span>), b += <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> B = <span class="keyword">new</span> Base(),</span><br><span class="line">T = W[<span class="string">&#x27;DA&#x27;</span> + <span class="string">&#x27;TA&#x27;</span>].split(<span class="string">&#x27;&#x27;</span>),</span><br><span class="line">N = W[<span class="string">&#x27;n&#x27;</span> + <span class="string">&#x27;onc&#x27;</span> + <span class="string">&#x27;e&#x27;</span>],</span><br><span class="line">len,</span><br><span class="line">locate,</span><br><span class="line">str;</span><br><span class="line">N = N.match(<span class="regexp">/\d+[a-zA-Z]+/g</span>);</span><br><span class="line">len = N.length;</span><br><span class="line"><span class="keyword">while</span> (len--) &#123;</span><br><span class="line">    locate = <span class="built_in">parseInt</span>(N[len]) &amp; <span class="number">255</span>;</span><br><span class="line">    str = N[len].replace(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    T.splice(locate, str.length)</span><br><span class="line">&#125;</span><br><span class="line">T = T.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">_v = <span class="built_in">JSON</span>.parse(B.decode(T));</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出T应该就是页面代码中的那一长串字符串，我们来验证下:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_18-14-06.57lgr10pb5s0.webp"                      alt="Snipaste_2022-01-26_18-14-06"                ></p><p>然后_v就是刚刚打断点看到的包含图片url的变量</p><p>然后我们就可以通过以上的js代码获得_v，但是我们还有一个变量N未知，同样的我们在console中看一下:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_18-15-44.6a7z29eh0n00.webp"                      alt="Snipaste_2022-01-26_18-15-44"                ></p><p>但是这个N参数在哪里呢，我们在页面代码中看下，取一小部分搜索，这也是一个技巧:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_18-18-06.75bpfs6tq2s0.webp"                      alt="Snipaste_2022-01-26_18-18-06"                ></p><p>发现这是一句js代码生成的</p><h3 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h3><p>刚刚我们知道了_v这个变量的生成函数，然后目前有两个参数需要构建出来</p><p>这里我们用正则提取，主要用到了正则的(?=、?&lt;=)，可以跳转<a class="link"   href="https://www.runoob.com/regexp/regexp-syntax.html" >这里<i class="fas fa-external-link-alt"></i></a>查看如何使用</p><p>下面来看看代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://ac.qq.com/ComicView/index/id/531490/cid/1&#x27;</span></span><br><span class="line">res = requests.get(url).text</span><br><span class="line">data = re.findall(<span class="string">&quot;(?&lt;=var DATA        = &#x27;).*?(?=&#x27;)&quot;</span>, res)[<span class="number">0</span>]   <span class="comment"># 提取DATA</span></span><br><span class="line">nonce = re.findall(<span class="string">&#x27;window\[&quot;.+?(?&lt;=;)&#x27;</span>, res)[<span class="number">0</span>]   <span class="comment"># 提取window[&quot;no&quot;+&quot;nce&quot;]</span></span><br><span class="line">nonce = <span class="string">&#x27;=&#x27;</span>.join(nonce.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>:])[:-<span class="number">1</span>]   <span class="comment"># 掐头去尾</span></span><br><span class="line">nonce = execjs.<span class="built_in">eval</span>(nonce)   <span class="comment"># 通过execjs模块计算js代码</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="built_in">print</span>(nonce)</span><br></pre></td></tr></table></figure><p>以上对data的提取的正则有点问题，可以用beautifsuop来获取</p><p>获取到参数之后就可以很方便地进行获取_v变量了，可以像上面一样使用execjs来运行js代码然后获取到<code>_v</code>参数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;目标网站&quot;&gt;&lt;a href=&quot;#目标网站&quot; class=&quot;headerlink&quot; title=&quot;目标网站&quot;&gt;&lt;/a&gt;目标网站&lt;/h3&gt;&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://ac.qq.com/ComicView/index/id/5</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于asyncio异步编程</title>
    <link href="http://example.com/2022/01/26/%E5%85%B3%E4%BA%8Easyncio%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2022/01/26/%E5%85%B3%E4%BA%8Easyncio%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-26T01:42:30.000Z</published>
    <updated>2022-01-26T07:56:34.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="协程-amp-异步编程-asyncio"><a href="#协程-amp-异步编程-asyncio" class="headerlink" title="协程&amp;异步编程(asyncio)"></a>协程&amp;异步编程(asyncio)</h3><p>协程(Coroutine)，也可以被称为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是通过一个线程实现代码块相互切换执行，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure><p>上述代码是普通的函数定义和执行，按流程分别执行两个函数中的代码，并先后会输出：<code>1、2、3、4</code>。但如果介入协程技术那么就可以实现函数见代码切换执行，最终输入：<code>1、3、2、4</code></p><h3 id="协程的实现"><a href="#协程的实现" class="headerlink" title="协程的实现"></a>协程的实现</h3><p>在Python中有多种方式可以实现协程，例如:</p><ul><li>greenlet，是一个第三方模块，用于实现协程代码(Gevent协程就是基于greenlet实现)</li><li>yield，生成器，借助生成器的特点也可以实现协程代码</li><li>asyncio，在Python3.4中引入的模块用于编写协程代码</li><li>async &amp; awiat，在Python3.5中引入的两个关键字，结合asyncio模块可以更方便的编写协程代码</li></ul><h4 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h4><p>greentlet是一个第三方模块，需要提前安装 <code>pip3 install greenlet</code>才能使用，来看一个例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)        <span class="comment"># 第1步：输出 1</span></span><br><span class="line">    gr2.switch()    <span class="comment"># 第3步：切换到 func2 函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)        <span class="comment"># 第6步：输出 2</span></span><br><span class="line">    gr2.switch()    <span class="comment"># 第7步：切换到 func2 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)        <span class="comment"># 第4步：输出 3</span></span><br><span class="line">    gr1.switch()    <span class="comment"># 第5步：切换到 func1 函数，从上一次执行的位置继续向后执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)        <span class="comment"># 第8步：输出 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet(func1)</span><br><span class="line">gr2 = greenlet(func2)</span><br><span class="line">gr1.switch() <span class="comment"># 第1步：去执行 func1 函数</span></span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>注意: switch中也可以传递参数用于在切换执行时相互传递值</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>基于Python的生成器的yield和yield form关键字实现协程代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> func2()</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = func1()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> f1:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>注意: yield form关键字是在Python3.3中引入的</p><h4 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h4><p>在Python3.4之前官方未提供协程的类库，一般大家都是使用greenlet等其他来实现。在Python3.4发布后官方正式支持协程，即:asyncio模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future( func1() ),</span><br><span class="line">    asyncio.ensure_future( func2() )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()  <span class="comment"># 创建一个事件循环</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))  <span class="comment"># asyncio.wait会把task这个列表列表里的每一个Task对象也转化成一个Task对象，所以这里是重复了，可以看看以下代码，和这个代码的效果是一样的</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>)  <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">2</span>) <span class="comment"># 遇到IO耗时操作，自动化切换到tasks中的其他任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    func1(),</span><br><span class="line">    func2()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()  <span class="comment"># 创建一个事件循环</span></span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><p>注意: 基于asyncio模块实现的协程比之前的要更厉害，因为他的内部还集成了遇到IO耗时操作自动切花的功能</p><h4 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async&amp;await"></a>async&amp;await</h4><p>async &amp; awit 关键字在Python3.5版本中正式引入，基于他编写的协程代码其实就是 上一示例的加强版，让代码可以更加简便，Python3.8之后 <code>@asyncio.coroutine</code> 装饰器就会被移除，推荐使用async &amp; awit 关键字实现协程代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(func1()),  <span class="comment"># asyncio.ensure_future()将会把协程对象封装成一个Task对象</span></span><br><span class="line">    asyncio.ensure_future(func2())</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>关于协程有多种实现方式，目前主流使用是Python官方推荐的asyncio模块和async&amp;await关键字的方式，例如: 在tonado、sanic、fastapi、django3 中均已支持，接下来，我们也会针对 <code>asyncio模块</code> + <code>async &amp; await</code> 关键字进行更加详细的讲解</p><h3 id="协程的意义以及使用"><a href="#协程的意义以及使用" class="headerlink" title="协程的意义以及使用"></a>协程的意义以及使用</h3><p>通过学习，我们已经了解到协程可以通过一个线程在多个上下文中进行来回切换执行，<strong>但是</strong>，协程来回切换执行的意义何在呢?(网上看到很多文章舔协程，协程牛逼之处是哪里呢?)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。</span><br><span class="line">IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调，那么就会大大节省资源并提供性能，从而实现异步编程(不等待任务结束就可以去执行其他代码)</span><br></pre></td></tr></table></figure><h4 id="爬虫案例"><a href="#爬虫案例" class="headerlink" title="爬虫案例"></a>爬虫案例</h4><p>例如：用代码实现下载 <code>url_list</code> 中的图片:</p><ul><li><p>方式一，同步编程实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_image</span>(<span class="params">url</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始下载:&quot;</span>,url)</span><br><span class="line">    <span class="comment"># 发送网络请求，下载图片</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下载完成&quot;</span>)</span><br><span class="line">    <span class="comment"># 图片保存到本地文件</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">        file_object.write(response.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> url_list:</span><br><span class="line">        download_image(item)</span><br></pre></td></tr></table></figure></li><li><p>方式二，基于协程的异步编程实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">session, url</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;发送请求：&quot;</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl=<span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.content.read()</span><br><span class="line">        file_name = url.rsplit(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">            file_object.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]  <span class="comment"># asyncio.create_task()将会把协程对象封装成一个Task对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure><p>上述两种的执行对比之后会发现，<code>基于协程的异步编程</code> 要比 <code>同步编程</code>的效率高了很多。因为:</p><ul><li>同步编程，按照顺序逐一排队执行，如果图片下载时间为2分钟，那么全部执行完则需要6分钟</li><li>异步编程，几乎同时发出了3个下载任务的请求（遇到IO请求自动切换去发送其他任务请求），如果图片下载时间为2分钟，那么全部执行完毕也大概需要2分钟左右就可以了</li></ul></li></ul><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>协程一般应用在有IO操作的程序中，因为协程可以利用IO等待的时间去执行一些其他的代码，从而提升代码执行效率</p><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><p>基于<code>async</code> &amp; <code>await</code>关键字的协程可以实现异步编程，这也是目前python异步相关的主流技术</p><p>想要真正的了解Python中内置的异步编程，根据下文的顺序一点点来看</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>事件循环，可以把他当做是一个while循环，这个while循环在周期性地运行并执行一些<code>任务</code>，在特定条件下终止循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line"></span><br><span class="line">任务列表 = [ 任务<span class="number">1</span>, 任务<span class="number">2</span>, 任务<span class="number">3</span>,... ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有的任务，将<span class="string">&#x27;可执行&#x27;</span>和<span class="string">&#x27;已完成&#x27;</span>的任务返回</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 就绪任务 <span class="keyword">in</span> 已准备就绪的任务列表:</span><br><span class="line">        执行已就绪的任务</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 已完成的任务 <span class="keyword">in</span> 已完成的任务列表:</span><br><span class="line">        在任务列表中移除 已完成的任务</span><br><span class="line"></span><br><span class="line">    如果 任务列表 中的任务都已完成，则终止循环</span><br></pre></td></tr></table></figure><p>在编写程序的时候可以通过如下代码来获取和创建事件循环:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br></pre></td></tr></table></figure><h4 id="协程和异步编程"><a href="#协程和异步编程" class="headerlink" title="协程和异步编程"></a>协程和异步编程</h4><p>协程函数，定义形式为<code>async def</code>的函数；协程对象，调用协程函数所返回的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个协程函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用协程函数，返回一个协程对象</span></span><br><span class="line">result = func()</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 调用协程函数时，函数内部代码不会执行，只是会返回一个协程对象</p><h5 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h5><p>程序中，如果想要执行协程函数的内部代码，需要 <code>事件循环</code> 和 <code>协程对象</code> 配合才能实现，如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;协程内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用协程函数，返回一个协程对象(任务对象)</span></span><br><span class="line">result = func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="comment"># loop = asyncio.get_event_loop() # 创建一个事件循环</span></span><br><span class="line"><span class="comment"># loop.run_until_complete(result) # 将协程对象当做任务提交到事件循环的任务列表中(这里只有一个协程对象，所以就直接把这个协程对象传进去)，任务列表中的所有协程对象执行完之后就终止</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line"><span class="comment"># 本质上方式一是一样的，内部先 创建事件循环 然后执行 run_until_complete，一个简便的写法。</span></span><br><span class="line"><span class="comment"># asyncio.run 函数在 Python 3.7 中加入 asyncio 模块，</span></span><br><span class="line">asyncio.run(result)</span><br></pre></td></tr></table></figure><p>这个过程可以简单理解为：将<code>协程对象</code>当做任务添加到 <code>事件循环</code> 的任务列表，然后事件循环检测列表中的<code>协程对象</code>是否 已准备就绪(默认可理解为就绪状态)，如果准备就绪则执行其内部代码</p><h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><p>await是一个只能在协程函数中使用的关键字，<strong>用于遇到IO操作时挂起当前协程(任务)，当前协程(任务)挂起过程中 事件循环可以去执行其他的协程(任务)，当前协程IO处理完成时，可以再次切换回来执行await之后的代码</strong>；代码如下:</p><p>示例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。</span></span><br><span class="line">    <span class="comment"># 当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line"></span><br><span class="line">result = func()</span><br><span class="line"></span><br><span class="line">asyncio.run(result)</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行协程函数内部代码</span><br><span class="line">IO请求结束，结果为： <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">others</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回值&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> others()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行协程函数内部代码</span><br><span class="line">start</span><br><span class="line">end</span><br><span class="line">IO请求结束，结果为： 返回值</span><br></pre></td></tr></table></figure><p>示例3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">others</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回值&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response1 = <span class="keyword">await</span> others()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response1)</span><br><span class="line"></span><br><span class="line">    response2 = <span class="keyword">await</span> others()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response2)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure><p>上述的所有示例都只是创建了一个任务(协程对象)，即: 事件循环的任务列表中只有一个任务(协程对象)，所以在IO等待时无法演示切换到其他任务效果</p><p>程序想要创建多个任务对象，需要使用Task对象来实现</p><h5 id="Task对象"><a href="#Task对象" class="headerlink" title="Task对象"></a>Task对象</h5><p><strong>Tasks用于并发调度协程</strong>，通过<code>asyncio.create_task(协程对象)</code>的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行。除了使用 <code>asyncio.create_task()</code> 函数以外，还可以用低层级的 <code>loop.create_task()</code> 或 <code>ensure_future()</code> 函数，不建议手动实例化Task对象</p><p>本质上是将协程对象们封装成task对象，一个<strong>协程对象列表</strong>，并将协程立即加入事件循环，同时追踪协程的状态</p><p><strong>注意</strong>: <code>asyncio.create_task()</code> 函数在 Python 3.7 中被加入。在 Python 3.7 之前，可以改用低层级的 <code>asyncio.ensure_future()</code> 函数</p><p>示例1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main开始&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    task1 = asyncio.create_task(func())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到一个Task对象中并立即添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    task2 = asyncio.create_task(func())</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务。</span></span><br><span class="line">    <span class="comment"># 此处的await是等待相对应的协程全都执行完毕并获取结果</span></span><br><span class="line">    ret1 = <span class="keyword">await</span> task1</span><br><span class="line">    ret2 = <span class="keyword">await</span> task2</span><br><span class="line">    <span class="built_in">print</span>(ret1, ret2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;返回值&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main开始&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建协程，将协程封装到Task对象中并添加到事件循环的任务列表中，等待事件循环去执行（默认是就绪状态）。</span></span><br><span class="line">    <span class="comment"># 在调用</span></span><br><span class="line">    task_list = [</span><br><span class="line">        asyncio.create_task(func(), name=<span class="string">&quot;n1&quot;</span>),</span><br><span class="line">        asyncio.create_task(func(), name=<span class="string">&quot;n2&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当执行某协程遇到IO操作时，会自动化切换执行其他任务。</span></span><br><span class="line">    <span class="comment"># 此处的await是等待所有协程执行完毕，并将所有协程的返回值保存到done</span></span><br><span class="line">    <span class="comment"># 如果设置了timeout值，则意味着此处最多等待的秒，完成的协程返回值写入到done中，未完成则写到pending中。</span></span><br><span class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(task_list, timeout=<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(done, pending)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>注意: <code>asyncio.wait</code>源码内部也会对列表中的每个协程<strong>执行ensure_future从而封装为Task对象</strong>，所以在和wait配合使用时task_list的值为<code>[func(),func()]</code> 也是可以的，如下示例所示:</p><p>示例3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;执行协程函数内部代码&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到IO操作挂起当前协程（任务），等IO操作完成之后再继续往下执行。当前协程挂起时，事件循环可以去执行其他协程（任务）。</span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;IO请求结束，结果为：&quot;</span>, response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">coroutine_list = [func(), func()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误：coroutine_list = [ asyncio.create_task(func()), asyncio.create_task(func()) ]  </span></span><br><span class="line"><span class="comment"># 此处不能直接 asyncio.create_task，因为将Task立即加入到事件循环的任务列表，</span></span><br><span class="line"><span class="comment"># 但此时事件循环还未创建，所以会报错。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用asyncio.wait将列表封装为一个协程，并调用asyncio.run实现执行两个协程</span></span><br><span class="line"><span class="comment"># asyncio.wait内部会对列表中的每个协程执行ensure_future，封装为Task对象。</span></span><br><span class="line">done,pending = asyncio.run( asyncio.wait(coroutine_list) )</span><br></pre></td></tr></table></figure><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例:"></a>综合案例:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description : 抓取交易侠中的天然气期货的收盘价</span></span><br><span class="line"><span class="string">@File        : NGAS_close_price</span></span><br><span class="line"><span class="string">@Project     : aiostarload</span></span><br><span class="line"><span class="string">@Time        : 2021/11/11/0011 19:17</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       : http://120.76.207.186/jin10ts/2021issues/-/issues/707#note_114637</span></span><br><span class="line"><span class="string">@change      : </span></span><br><span class="line"><span class="string">@reason      : </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aiostarlord.utils <span class="keyword">import</span> md5</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aiostarlord.spiders <span class="keyword">import</span> BaseSpider</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>(<span class="params">BaseSpider</span>):</span></span><br><span class="line">    proxy = <span class="literal">None</span></span><br><span class="line">    _<span class="built_in">type</span> = <span class="string">&quot;快讯&quot;</span></span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;pragma&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;cache-control&#x27;</span>: <span class="string">&#x27;no-cache&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;upgrade-insecure-requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.63&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.63&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time_tuple = time.localtime(time.time())</span><br><span class="line">    today = time.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>, time_tuple)</span><br><span class="line"></span><br><span class="line">    n_api = <span class="string">&#x27;http://114.55.255.71:9088/index/klineData&#x27;</span></span><br><span class="line">    n_headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    n_data = json.dumps(&#123;</span><br><span class="line">        <span class="string">&quot;symbols&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;NGAS&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="number">1440</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">    up_id = <span class="string">&#x27;5505&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getYesterday</span>(<span class="params">self</span>):</span></span><br><span class="line">        today = datetime.date.today()</span><br><span class="line">        oneday = datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">        yesterday = today - oneday</span><br><span class="line">        yesterday = <span class="built_in">str</span>(today - oneday)</span><br><span class="line">        <span class="keyword">return</span> yesterday</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">self, url, headers, data=<span class="literal">None</span>, retry=<span class="number">0</span></span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> session.post(</span><br><span class="line">                        url=url,</span><br><span class="line">                        headers=headers,</span><br><span class="line">                        data=data,</span><br><span class="line">                        timeout=<span class="number">10</span>,</span><br><span class="line">                ) <span class="keyword">as</span> resp:</span><br><span class="line">                    html = <span class="keyword">await</span> resp.json()</span><br><span class="line">                    <span class="keyword">return</span> html</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            retry += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> retry &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">await</span> self.fetch(url, headers, data, retry)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.logger(<span class="string">f&quot;req_err: <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(self.history_path):</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.history_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                his_data = json.load(f)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            his_data = &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> his_data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_price_info</span>(<span class="params">self</span>):</span></span><br><span class="line">        price_info = <span class="keyword">await</span> self.fetch(self.n_api, self.n_headers, data=self.n_data)</span><br><span class="line">        <span class="comment"># print(price_info)</span></span><br><span class="line">        close_time = price_info[<span class="string">&#x27;data&#x27;</span>][<span class="number">1</span>][<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;close_time&#x27;</span>].split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(close_time)</span></span><br><span class="line">        close_price = price_info[<span class="string">&#x27;data&#x27;</span>][<span class="number">1</span>][<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">        <span class="comment"># print(close_price)</span></span><br><span class="line">        data = &#123;<span class="string">&#x27;pub_date&#x27;</span>: close_time, <span class="string">&#x27;pub_price&#x27;</span>: close_price&#125;</span><br><span class="line">        self.logger(<span class="string">&#x27;got yes-close-price successfully!&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.history_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># f.write()</span></span><br><span class="line">            json.dump(data, f)</span><br><span class="line">        <span class="keyword">return</span> close_price, close_time</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">judge_upload</span>(<span class="params">self</span>):</span></span><br><span class="line">        history_data = self.read_data()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(history_data) == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># self.logger(&#x27;Today data has uploaded yet!&#x27;)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> history_data[<span class="string">&#x27;pub_date&#x27;</span>] != self.getYesterday():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">upload_info</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.judge_upload():</span><br><span class="line">            self.logger(<span class="string">&#x27;Data has uploaded yet!&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pub_price, pub_date = <span class="keyword">await</span> self.get_price_info()</span><br><span class="line">        data_id = self.up_id</span><br><span class="line">        up_url = <span class="string">&#x27;http://09636cb288b4456385f023a597399ec6.z3c.jin10.com/admin/api/data/insert/batch&#x27;</span></span><br><span class="line">        up_headers = &#123;</span><br><span class="line">            <span class="string">&quot;sync-token&quot;</span>: <span class="string">&quot;3CD24FB0D6963F7D&quot;</span>,</span><br><span class="line">            <span class="string">&quot;x-app-id&quot;</span>: <span class="string">&quot;KYEcsGhEkPo9EMg3&quot;</span>,</span><br><span class="line">            <span class="string">&quot;x-version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,  <span class="comment"># 正式服</span></span><br><span class="line">            <span class="comment"># &quot;x-version&quot;: &quot;1000&quot;,  # 测试服</span></span><br><span class="line">            <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># &quot;data&quot;: [&#123;&quot;x_axis&quot;: date_info, &quot;y_axis&quot;: f&quot;&#123;end_price&#125;&quot;, &quot;status&quot;: 1&#125;]&#125;</span></span><br><span class="line">        pub_date = pub_date.replace(<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        data = &#123;<span class="string">&quot;data_set_id&quot;</span>: data_id,</span><br><span class="line">                <span class="string">&quot;data&quot;</span>: [&#123;<span class="string">&quot;x_axis&quot;</span>: pub_date, <span class="string">&quot;y_axis&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;pub_price&#125;</span>&quot;</span>, <span class="string">&quot;status&quot;</span>: <span class="number">1</span>&#125;]&#125;</span><br><span class="line"></span><br><span class="line">        upload_return_value = <span class="keyword">await</span> self.fetch(up_url, up_headers, data=json.dumps(data))</span><br><span class="line">        <span class="keyword">if</span> upload_return_value[<span class="string">&#x27;status&#x27;</span>] == <span class="number">200</span>:</span><br><span class="line">            self.logger(<span class="string">f&#x27;<span class="subst">&#123;data_id&#125;</span> up ok!&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(upload_return_value)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">self, msg</span>):</span></span><br><span class="line">        self.history_path = os.path.join(self.spider_cache_dir, <span class="string">&#x27;ngas_history.json&#x27;</span>)</span><br><span class="line">        self.his_data = self.read_data()</span><br><span class="line">        <span class="keyword">await</span> self.upload_info()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    s = Spider()</span><br><span class="line">    loop.run_until_complete(s.on_message(<span class="string">&#x27;a&#x27;</span>))</span><br></pre></td></tr></table></figure><p><code>loop = asyncio.get_event_loop()</code>创建一个事件循环，然后再把这个协程对象放到<code>loop.run_until_complete()</code>函数中，这个函数会把协程封装成task对象，然后在放进事件循环中去执行</p><h4 id="讲了这么多，主要记住以下三步"><a href="#讲了这么多，主要记住以下三步" class="headerlink" title="讲了这么多，主要记住以下三步:"></a>讲了这么多，主要记住以下三步:</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-26_15-28-54.22e4znwmjtz4.webp"                      alt="Snipaste_2022-01-26_15-28-54"                ></p><p>本文参考自:<a class="link"   href="https://zhuanlan.zhihu.com/p/137057192" >https://zhuanlan.zhihu.com/p/137057192<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;协程-amp-异步编程-asyncio&quot;&gt;&lt;a href=&quot;#协程-amp-异步编程-asyncio&quot; class=&quot;headerlink&quot; title=&quot;协程&amp;amp;异步编程(asyncio)&quot;&gt;&lt;/a&gt;协程&amp;amp;异步编程(asyncio)&lt;/h3&gt;&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>利用aiohttp和asyncio写异步爬虫</title>
    <link href="http://example.com/2022/01/25/%E5%88%A9%E7%94%A8aiohttp%E5%92%8Casyncio%E5%86%99%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/"/>
    <id>http://example.com/2022/01/25/%E5%88%A9%E7%94%A8aiohttp%E5%92%8Casyncio%E5%86%99%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB/</id>
    <published>2022-01-25T08:56:30.000Z</published>
    <updated>2022-01-26T01:22:11.069Z</updated>
    
    <content type="html"><![CDATA[<p>关于<code>asyncio</code>(异步io)，我在前面的别的文章介绍过，点击<a class="link"   href="http://kest.club/2022/01/14/%E7%90%86%E8%A7%A3Python%20asyncio%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E6%B4%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/" >这里<i class="fas fa-external-link-alt"></i></a>查看，这里我们来看看如何利用<code>aiohttp</code>和<code>asyncio</code>完成一个异步爬虫，我实习的第一家公司就是全部使用异步爬虫</p><h4 id="什么是aiohttp"><a href="#什么是aiohttp" class="headerlink" title="什么是aiohttp"></a>什么是aiohttp</h4><p>aiohttp是一个异步的HTTP客户端\服务端框架，基于asyncio的异步模块，可用于实现异步爬虫，更快与requests的同步爬虫</p><h4 id="aiohttp的安装"><a href="#aiohttp的安装" class="headerlink" title="aiohttp的安装"></a>aiohttp的安装</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aiohttp </span><br></pre></td></tr></table></figure><h4 id="aiohttp用作客户端的案例"><a href="#aiohttp用作客户端的案例" class="headerlink" title="aiohttp用作客户端的案例"></a>aiohttp用作客户端的案例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个函数用来发请求</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">session, url</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个函数用来下载网页</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        html = <span class="keyword">await</span> fetch(session, <span class="string">&quot;http://httpbin.org/headers&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(html)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;输出结果：</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;headers&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;Accept&quot;: &quot;*/*&quot;, </span></span><br><span class="line"><span class="string">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, </span></span><br><span class="line"><span class="string">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span></span><br><span class="line"><span class="string">    &quot;User-Agent&quot;: &quot;Python/3.7 aiohttp/3.6.2&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="aiohttp用作服务端的案例"><a href="#aiohttp用作服务端的案例" class="headerlink" title="aiohttp用作服务端的案例"></a>aiohttp用作服务端的案例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是一个处理函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">request</span>):</span></span><br><span class="line">    name = request.match_info.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&quot;Anonymous&quot;</span>)</span><br><span class="line">    text = <span class="string">&quot;Hello, &quot;</span> + name</span><br><span class="line">    <span class="keyword">return</span> web.Response(text=text)</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">app.add_routes([web.get(<span class="string">&#x27;/&#x27;</span>, handle),</span><br><span class="line">                web.get(<span class="string">&#x27;/&#123;name&#125;&#x27;</span>, handle)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    web.run_app(app)</span><br></pre></td></tr></table></figure><p>运行这个代码，然后访问<a href="http://127.0.0.1:8080就可以看到你的网站了，很基础的一个网页，你可以在url后面跟上你的名字，然后会在网页上显示出来">http://127.0.0.1:8080就可以看到你的网站了，很基础的一个网页，你可以在url后面跟上你的名字，然后会在网页上显示出来</a></p><h4 id="aiohttp用作客户端参数详解"><a href="#aiohttp用作客户端参数详解" class="headerlink" title="aiohttp用作客户端参数详解"></a>aiohttp用作客户端参数详解</h4><p>我们来看看客户端，也就是用来发送http请求的方法，首先看一段代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description : </span></span><br><span class="line"><span class="string">@File        : aiohttp-test</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/1/25 17:18</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       : </span></span><br><span class="line"><span class="string">@change      : </span></span><br><span class="line"><span class="string">@reason      : </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>) <span class="keyword">as</span> resp:</span><br><span class="line"><span class="built_in">print</span>(resp.status)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">await</span> resp.text())</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>代码解释:</p><p>在网络请求中，一个请求就是一个会话，<code>aiohttp</code>使用的是<code>ClientSession</code>来管理会话，上面的代码就是实例化一个<code>ClientSession</code>类然后命名为<code>session</code>，然后用<code>session</code>去发送请求，当然上面出现的是get请求，其他的还有post，put啥的都支持的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">session.put(<span class="string">&#x27;http://httpbin.org/put&#x27;</span>, data=<span class="string">b&#x27;data&#x27;</span>)</span><br><span class="line">session.delete(<span class="string">&#x27;http://httpbin.org/delete&#x27;</span>)</span><br><span class="line">session.head(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line">session.options(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>)</span><br><span class="line">session.patch(<span class="string">&#x27;http://httpbin.org/patch&#x27;</span>, data=<span class="string">b&#x27;data&#x27;</span>)</span><br></pre></td></tr></table></figure><h5 id="在url中传递参数"><a href="#在url中传递参数" class="headerlink" title="在url中传递参数"></a>在url中传递参数</h5><p>有时候在发起网络请求的时候需要附加一些参数到url中，这一点也是支持的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>: <span class="string">&#x27;value2&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>,</span><br><span class="line">                       params=params) <span class="keyword">as</span> resp:</span><br><span class="line">    expect = <span class="string">&#x27;http://httpbin.org/get?key2=value2&amp;key1=value1&#x27;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">str</span>(resp.url) == expect</span><br></pre></td></tr></table></figure><p>我们可以通过<code>params</code>参数来指定要传递的参数</p><p>那么post如何传参数呢，我用上面的代码改变了下，做个示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description :</span></span><br><span class="line"><span class="string">@File        : aiohttp-test</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/1/25 17:18</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       :</span></span><br><span class="line"><span class="string">@change      :</span></span><br><span class="line"><span class="string">@reason      :</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;key1&#x27;</span>: <span class="string">&#x27;value1&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.post(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, data=json.dumps(data)) <span class="keyword">as</span> resp:</span><br><span class="line">            <span class="built_in">print</span>(resp.status)</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> resp.text())</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h5 id="读取响应内容"><a href="#读取响应内容" class="headerlink" title="读取响应内容"></a>读取响应内容</h5><p>通过<code>status</code>来获取响应状态码，通过<code>text</code>来获取响应内容，当然也可以直接指明编码格式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="keyword">as</span> resp:</span><br><span class="line">            <span class="built_in">print</span>(resp.status)</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> resp.text(encoding=utf-<span class="number">8</span>))</span><br><span class="line">            </span><br><span class="line"><span class="string">&quot;&quot;&quot;输出结果：</span></span><br><span class="line"><span class="string">200</span></span><br><span class="line"><span class="string">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang=&quot;zh-CN&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>对于非文本内容格式，比如一张图片，这种返回值是二进制也是可以读取到的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> resp.read()</span><br></pre></td></tr></table></figure><p>将<code>text()</code>换为<code>read()</code>即可</p><h5 id="自定义headers"><a href="#自定义headers" class="headerlink" title="自定义headers"></a>自定义headers</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot;</span></span><br><span class="line">                      <span class="string">&quot;AppleWebKit/537.36 (KHTML, like Gecko)&quot;</span></span><br><span class="line">                      <span class="string">&quot; Chrome/78.0.3904.108 Safari/537.36&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">await</span> session.post(url, headers=headers)</span><br></pre></td></tr></table></figure><h5 id="自定义cookie"><a href="#自定义cookie" class="headerlink" title="自定义cookie"></a>自定义cookie</h5><p>发送你自己的cookies给服务器，你可以为ClientSession对象指定cookies参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://httpbin.org/cookies&#x27;</span></span><br><span class="line">cookies = &#123;<span class="string">&#x27;cookies_are&#x27;</span>: <span class="string">&#x27;working&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> ClientSession(cookies=cookies) <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">await</span> resp.json() == &#123;</span><br><span class="line">           <span class="string">&quot;cookies&quot;</span>: &#123;<span class="string">&quot;cookies_are&quot;</span>: <span class="string">&quot;working&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h5><p>我们在写爬虫的时候可能需要使用到代理，<code>aiohttp</code>也是支持使用代理的，我们可以在发起请求的时候使用代理，只需要使用关键字<code>proxy</code>来指明即可，但是有一个不太好的地方就是它只支持<code>http</code>代理，不支持<code>https</code>代理，下面只是一个简单的使用，我们真正在项目中需要去购买一些优质代理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy = “http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10809</span>” </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(headers=headers) <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url=login_url, proxy=proxy) <span class="keyword">as</span> response:</span><br><span class="line">        resu = <span class="keyword">await</span> response.text()</span><br></pre></td></tr></table></figure><h4 id="和asyncio结合起来使用"><a href="#和asyncio结合起来使用" class="headerlink" title="和asyncio结合起来使用"></a>和asyncio结合起来使用</h4><h5 id="速度对比"><a href="#速度对比" class="headerlink" title="速度对比"></a>速度对比</h5><p>使用asyncio和aiohttp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description :</span></span><br><span class="line"><span class="string">@File        : SpeedCompare-Notuseaio</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/1/25 17:52</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       :</span></span><br><span class="line"><span class="string">@change      :</span></span><br><span class="line"><span class="string">@reason      :</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> scrapy.utils <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.project <span class="keyword">import</span> get_project_settings</span><br><span class="line"><span class="keyword">from</span> pybase.util <span class="keyword">import</span> send_file</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(headers=headers) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> resp.get(url) <span class="keyword">as</span> res:</span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">await</span> res.text())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">        url = <span class="string">f&quot;https://www.puercn.com/news/zhengce/p<span class="subst">&#123;i&#125;</span>/&quot;</span></span><br><span class="line">        <span class="keyword">await</span> parse(url)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_time = datetime.now()</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;time:&#x27;</span>, datetime.now() - start_time)</span><br></pre></td></tr></table></figure><p>不使用asyncio和aiohttp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description :</span></span><br><span class="line"><span class="string">@File        : SpeedCompare-Notuseaio</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/1/25 17:52</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       :</span></span><br><span class="line"><span class="string">@change      :</span></span><br><span class="line"><span class="string">@reason      :</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> scrapy.utils <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.project <span class="keyword">import</span> get_project_settings</span><br><span class="line"><span class="keyword">from</span> pybase.util <span class="keyword">import</span> send_file</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="comment"># async with aiohttp.ClientSession(headers=headers) as resp:</span></span><br><span class="line">    <span class="comment">#     async with resp.get(url) as res:</span></span><br><span class="line">    <span class="comment">#         print(await res.text())</span></span><br><span class="line">    res = requests.get(url=url, headers=headers).text</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">        url = <span class="string">f&quot;https://www.puercn.com/news/zhengce/p<span class="subst">&#123;i&#125;</span>/&quot;</span></span><br><span class="line">        parse(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_time = datetime.now()</span><br><span class="line">    main()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;time:&#x27;</span>, datetime.now() - start_time)</span><br></pre></td></tr></table></figure><p>可以看到使用asyncio的速度会快，虽然这里的案例差别不大</p><p>使用案例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description : </span></span><br><span class="line"><span class="string">@File        : grasp_douban</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/1/26 9:18</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       : </span></span><br><span class="line"><span class="string">@change      : </span></span><br><span class="line"><span class="string">@reason      : </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&quot;</span></span><br><span class="line">                         <span class="string">&quot;/537.36 (KHTML, like Gecko) &quot;</span></span><br><span class="line">                         <span class="string">&quot;Chrome/72.0.3626.121 Safari/537.36&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_movie_url</span>():</span></span><br><span class="line">    req_url = <span class="string">&quot;https://movie.douban.com/chart&quot;</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(headers=headers) <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url=req_url, headers=headers) <span class="keyword">as</span> response:</span><br><span class="line">            result = <span class="keyword">await</span> response.text()</span><br><span class="line">            result = etree.HTML(result)</span><br><span class="line">        <span class="keyword">return</span> result.xpath(<span class="string">&quot;//*[@id=&#x27;content&#x27;]/div/div[1]/div/div/table/tr/td/a/@href&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_movie_content</span>(<span class="params">movie_url</span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(headers=headers) <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url=movie_url, headers=headers) <span class="keyword">as</span> response:</span><br><span class="line">            result = <span class="keyword">await</span> response.text()</span><br><span class="line">            result = etree.HTML(result)</span><br><span class="line">        movie = <span class="built_in">dict</span>()</span><br><span class="line">        name = result.xpath(<span class="string">&#x27;//*[@id=&quot;content&quot;]/h1/span[1]//text()&#x27;</span>)</span><br><span class="line">        author = result.xpath(<span class="string">&#x27;//*[@id=&quot;info&quot;]/span[1]/span[2]//text()&#x27;</span>)</span><br><span class="line">        movie[<span class="string">&quot;name&quot;</span>] = name</span><br><span class="line">        movie[<span class="string">&quot;author&quot;</span>] = author</span><br><span class="line">    <span class="keyword">return</span> movie</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = datetime.now()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    movie_url_list = loop.run_until_complete(get_movie_url())</span><br><span class="line">    tasks = [get_movie_content(url) <span class="keyword">for</span> url <span class="keyword">in</span> movie_url_list]</span><br><span class="line">    movies = loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">    <span class="built_in">print</span>(movies)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于&lt;code&gt;asyncio&lt;/code&gt;(异步io)，我在前面的别的文章介绍过，点击&lt;a class=&quot;link&quot;   href=&quot;http://kest.club/2022/01/14/%E7%90%86%E8%A7%A3Python%20asyncio%E5%8E%</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>端口大全介绍</title>
    <link href="http://example.com/2022/01/25/%E7%AB%AF%E5%8F%A3%E5%A4%A7%E5%85%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2022/01/25/%E7%AB%AF%E5%8F%A3%E5%A4%A7%E5%85%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-01-25T01:19:30.000Z</published>
    <updated>2022-01-25T01:20:19.589Z</updated>
    
    <content type="html"><![CDATA[<p>此文转载自头条，点击<a class="link"   href="https://www.toutiao.com/a7056495090310693389/?log_from=ab57387dea42b_1643073348950" >跳转<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此文转载自头条，点击&lt;a class=&quot;link&quot;   href=&quot;https://www.toutiao.com/a7056495090310693389/?log_from=ab57387dea42b_1643073348950&quot; &gt;跳转&lt;i class=&quot;fas fa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ubuntu云服务器如何安装MySQL</title>
    <link href="http://example.com/2022/01/24/Ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85MySQL/"/>
    <id>http://example.com/2022/01/24/Ubuntu%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85MySQL/</id>
    <published>2022-01-24T07:09:30.000Z</published>
    <updated>2022-01-24T09:41:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>首先验证下是否安装，键入mysql:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_15-11-14.png"                      alt="Snipaste_2022-01-24_15-11-14"                ></p><p>像这样就是没有安装</p><p>然后下面我们就开始安装</p><ol><li><p>首先更新软件包(这个命令很常用)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>如果当前系统已经是root用户则不用键入sudo，输入也是没关系的:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_15-30-02.png"                      alt="Snipaste_2022-01-24_15-30-02"                ></p></li><li><p>开始安装MySQL服务端和客户端(中间会有确认，输入y或者Y):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_15-31-35.png"                      alt="Snipaste_2022-01-24_15-31-35"                ></p></li><li><p>然后我们查看下数据库版本，如果出现数据库版本则安装成功:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_15-33-21.2tsy0k8c3wg0.webp"                      alt="Snipaste_2022-01-24_15-33-21"                ></p></li><li><p>修改密码</p><ul><li><p>进入配置文件，在在mysqld.cnf中添加skip-grant-tables便可跳过登录认证(要记得保存):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_15-37-46.4qmshu9lsp00.webp"                      alt="Snipaste_2022-01-24_15-37-46"                ></p></li><li><p>重启数据库服务，并登录数据库，不要输入密码，直接回车；登录数据库之后，进入mysql数据库，修改user表中user=’root’的密码:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_15-45-29.6bp8qx0apjc0.webp"                      alt="Snipaste_2022-01-24_15-45-29"                ></p><p>来看看这上面出现的命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart  # 重启mysql服务</span><br><span class="line">mysql -u root -p  # 以root用户在本地登录，这个时候我们没设置密码但在安装mysql的时候自动生成了一个，我们可以用这个自动生成的去登录，但是我们之前有个操作让我们跳过了登录认证，所以这里可以不输入密码直接登录</span><br><span class="line">use mysql;  # 使用mysql这个数据库</span><br><span class="line">select user,plugin from user;  # 选出user和plguin这两列</span><br><span class="line">update user set authentication_string=password(&quot;yourCode&quot;),plugin=&#x27;mysql_native_password&#x27; where user=&quot;root&quot;;  # 设置root用户登录密码</span><br><span class="line">flush privileges;  # 更新权限</span><br></pre></td></tr></table></figure></li><li><p>进入刚刚那个配置文件，将skip-grant-tables注释掉(在skip-grant-tables前添加#)，保存退出，这一步是关闭刚刚不输入密码就登录mysql的操作，确保登录数据库必须使用密码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_15-54-40.1j1paqeb25ls.webp"                      alt="Snipaste_2022-01-24_15-54-40"                ></p></li></ul></li></ol><h3 id="开放远程连接权限"><a href="#开放远程连接权限" class="headerlink" title="开放远程连接权限"></a>开放远程连接权限</h3><ol><li><p>进入刚刚的那个配置文件，将<code>bind-address          = 127.0.0.1</code>这一行注释掉，保存并退出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_15-58-55.3q30m3qywt60.webp"                      alt="Snipaste_2022-01-24_15-58-55"                ></p></li><li><p>登录数据库，配置root用户远程权限</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_16-02-53.4h4j3qprai00.webp"                      alt="Snipaste_2022-01-24_16-02-53"                ></p><p>重复的命令这里就不赘述了，讲一条关键的命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;yourCode&#x27; WITH GRANT OPTION;  # 让所有的地址都可以使用root用户，远程访问数据库</span><br></pre></td></tr></table></figure></li><li><p>云服务器控制台开放MySQL数据库3306端口，按下图操作点击确定即可:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_16-10-05.3ud7mcfm31m0.webp"                      alt="Snipaste_2022-01-24_16-10-05"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/20200509230650615.1ktpct6aln1c.webp"                      alt="20200509230650615"                ></p></li><li><p>用客户端连接查看是否安装成功:</p><p>因为我们刚配置完，我们最好在云服务器中重启下mysql的服务，使用命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql restart  # 这个命令一定要root权限</span><br></pre></td></tr></table></figure><p>上面这个命令一定要root权限，如果没有就会报如下错误:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_16-33-39.6by085d5bhc0.webp"                      alt="Snipaste_2022-01-24_16-33-39"                ></p><p>然后我们来测试下，这样成功开放远程链接了:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_16-35-30.3v3eifkbtrc0.webp"                      alt="Snipaste_2022-01-24_16-35-30"                ></p></li></ol><h3 id="新增guest用户并设置访问权限"><a href="#新增guest用户并设置访问权限" class="headerlink" title="新增guest用户并设置访问权限"></a>新增guest用户并设置访问权限</h3><ol><li>登录数据库，进入mysql库</li><li>创建guest用户，并设置登录密码</li><li>为gest用户开放select、insert、update权限</li><li>刷新生效</li></ol><p>上面的命令对应如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#创建用户</span><br><span class="line">mysql&gt; grant usage on *.* to &#x27;guest&#x27;@&#x27;%&#x27;identified by &#x27;yourguestcode&#x27; with grant option;</span><br><span class="line">#设置权限</span><br><span class="line">mysql&gt; grant select,insert,update on *.* to &#x27;guest&#x27;@&#x27;%&#x27; with grant option;</span><br><span class="line">#刷新</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>这上面我的密码搞错了，这里就不改了，密码直接是<code>yourguestcode</code>，修改密码可以使用以下语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;guest&#x27;@&#x27;%&#x27; = PASSWORD(&#x27;123456&#x27;);  # 修改密码</span><br><span class="line">FLUSH PRIVILEGES;  # 刷新权限</span><br></pre></td></tr></table></figure><p>这里之所以是<code>@&#39;%&#39;</code>，因为上面设置了远程的访问权限</p><p>为验证guest用户设置是否生效，可以试试guest用户新建一个库，或者新建一个表，数据库会报错，因为我们没有给guest用户create权限:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_17-19-38.30pnxs1a0m20.webp"                      alt="Snipaste_2022-01-24_17-19-38"                ></p><p>然后我们来验证下:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_17-41-15.1d1dkzqfg6ps.webp"                      alt="Snipaste_2022-01-24_17-41-15"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;安装MySQL&quot;&gt;&lt;a href=&quot;#安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;安装MySQL&quot;&gt;&lt;/a&gt;安装MySQL&lt;/h3&gt;&lt;p&gt;首先验证下是否安装，键入mysql:&lt;/p&gt;
&lt;p&gt;&lt;img  
                 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL常用命令</title>
    <link href="http://example.com/2022/01/24/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/01/24/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-24T06:46:30.000Z</published>
    <updated>2022-01-24T10:18:39.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h3><p>格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h主机地址 -u用户名 －p用户密码</span><br></pre></td></tr></table></figure><ol><li><p>连接到本地的MySQL(<strong>-h主机地址可以省略</strong>)</p><p><strong>用户密码和<code>-p</code>之间不要有空格，否则会把空格当做密码的一部分</strong>，会再次要求你输入密码:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_14-51-56.6d41tca5mu40.png"                      alt="Snipaste_2022-01-24_14-51-56"                ></p><p>下面则是正确格式的命令:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_14-55-52.awe8823neeo.png"                      alt="Snipaste_2022-01-24_14-55-52"                ></p></li><li><p>连接到远程主机上的MySQL</p><p>具体见<a class="link"   href="https://www.cnblogs.com/bluealine/p/7832219.html" >这里<i class="fas fa-external-link-alt"></i></a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;连接MySQL&quot;&gt;&lt;a href=&quot;#连接MySQL&quot; class=&quot;headerlink&quot; title=&quot;连接MySQL&quot;&gt;&lt;/a&gt;连接MySQL&lt;/h3&gt;&lt;p&gt;格式:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python操作各数据库的代码示例</title>
    <link href="http://example.com/2022/01/24/Python%E6%93%8D%E4%BD%9C%E5%90%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"/>
    <id>http://example.com/2022/01/24/Python%E6%93%8D%E4%BD%9C%E5%90%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</id>
    <published>2022-01-24T06:29:30.000Z</published>
    <updated>2022-01-24T10:17:20.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="操作MySQL"><a href="#操作MySQL" class="headerlink" title="操作MySQL"></a>操作MySQL</h3><p>首先安装pymysql包:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure><p>然后在mysql里创建数据库名为test，然后在里面创建一个Product表:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `Product`;</span><br><span class="line">/*!40101 SET @saved_cs_client     = @@character_set_client */;</span><br><span class="line">/*!40101 SET character_set_client = utf8 */;</span><br><span class="line">CREATE TABLE `Product` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(40) NOT NULL,    /* 商品名称 */</span><br><span class="line">  `remark` varchar(1000) NULL,</span><br><span class="line">  `isBuy` int(1) DEFAULT 1,      /* 1: 在售 2:卖出 */</span><br><span class="line">  `version` int(11) NOT null default 1000, </span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>直接在Navicat Premium中打开一个连接然后新建一个test数据库用于测试，然后右键运行SQL文件即可完成数据表的创建:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220124/Snipaste_2022-01-24_17-53-11.233jivgv6g4g.webp"                      alt="Snipaste_2022-01-24_17-53-11"                ></p><p>下面先来看看首秀，首先mysql获得connection，然后从connection获得cursor进行操作:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">host = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">port = <span class="number">3306</span></span><br><span class="line">db = <span class="string">&#x27;test&#x27;</span></span><br><span class="line">user = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- 用pymysql 操作数据库</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_connection</span>():</span></span><br><span class="line">    conn = pymysql.connect(host=host, port=port, db=db, user=user, password=password)</span><br><span class="line">    <span class="keyword">return</span> conn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_it</span>():</span></span><br><span class="line"></span><br><span class="line">    conn = get_connection()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 cursor() 方法创建一个 dict 格式的游标对象 cursor</span></span><br><span class="line">    cursor = conn.cursor(pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 execute()  方法执行 SQL 查询</span></span><br><span class="line">    cursor.execute(<span class="string">&quot;select count(id) as total from Product&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 fetchone() 方法获取单条数据.以字典显示</span></span><br><span class="line">    data = cursor.fetchone()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-- 当前数量: %d &quot;</span> % data[<span class="string">&#x27;total&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭数据库连接</span></span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    check_it()</span><br></pre></td></tr></table></figure><p>以上只是个简单小案例，具体请移步<a class="link"   href="https://www.jianshu.com/p/4e72faebd27f" >这里<i class="fas fa-external-link-alt"></i></a></p><h3 id="操作Mongodb"><a href="#操作Mongodb" class="headerlink" title="操作Mongodb"></a>操作Mongodb</h3><p>这里直接上我工作的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.project <span class="keyword">import</span> get_project_settings</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadInfo</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;zscq-uploadinfo&#x27;</span></span><br><span class="line">    start_urls = []</span><br><span class="line">    config = get_project_settings()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        mongo = pymongo.MongoClient(host=<span class="string">&#x27;192.168.3.85&#x27;</span>, port=<span class="number">27017</span>)</span><br><span class="line">        <span class="comment"># mongo = pymongo.MongoClient(host=self.config.get(&#x27;MONGO_HOST&#x27;), port=self.config.get(&#x27;MONGO_PORT&#x27;))</span></span><br><span class="line">        db = mongo[<span class="string">&#x27;popular_industry&#x27;</span>]  <span class="comment"># 选择数据库</span></span><br><span class="line">        collection = db[<span class="string">&#x27;lhj_kcpt_zscq&#x27;</span>]  <span class="comment"># 获取collection</span></span><br><span class="line">        url_info = <span class="string">&#x27;http://192.168.3.85:8066/datainsertApp/policy/insertToMongo&#x27;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 资讯的</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> collection.find(<span class="built_in">filter</span>=&#123;<span class="string">&#x27;cleaning_status&#x27;</span>: <span class="number">0</span>&#125;, no_cursor_timeout=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;issue_time&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>(item).keys() <span class="keyword">or</span> item[<span class="string">&#x27;issue_time&#x27;</span>] == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                item[<span class="string">&#x27;issue_time&#x27;</span>] = <span class="string">&#x27;0-0-0&#x27;</span></span><br><span class="line">            time_split = item[<span class="string">&#x27;issue_time&#x27;</span>].split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            data_day = time_split[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">            data_month = time_split[<span class="number">1</span>]</span><br><span class="line">            data_year = time_split[<span class="number">0</span>]</span><br><span class="line">            form_data = [&#123;</span><br><span class="line">                <span class="string">&quot;_id&quot;</span>: <span class="built_in">str</span>(item[<span class="string">&#x27;_id&#x27;</span>]),</span><br><span class="line">                <span class="string">&#x27;content&#x27;</span>: item[<span class="string">&#x27;content_url&#x27;</span>] <span class="keyword">if</span> <span class="string">&#x27;content&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>(item).keys() <span class="keyword">else</span> item[<span class="string">&#x27;content&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;content_url&#x27;</span>: item[<span class="string">&#x27;content_url&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;day&#x27;</span>: data_day,</span><br><span class="line">                <span class="string">&quot;paper_abstract&quot;</span>: <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> <span class="string">&#x27;paper_abstract&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>(item).keys() <span class="keyword">else</span> item[<span class="string">&#x27;paper_abstract&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;month&#x27;</span>: data_month,</span><br><span class="line">                <span class="string">&#x27;year&#x27;</span>: data_year,</span><br><span class="line">                <span class="string">&quot;author&quot;</span>: <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> <span class="string">&#x27;author&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>(item).keys() <span class="keyword">else</span> item[<span class="string">&#x27;author&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;information_source&#x27;</span>: <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> <span class="string">&#x27;information_source&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>(item).keys() <span class="keyword">else</span> item[<span class="string">&#x27;information_source&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;path&#x27;</span>: [item[<span class="string">&#x27;category&#x27;</span>], item[<span class="string">&#x27;sub_category&#x27;</span>], <span class="string">&#x27;科创平台&#x27;</span>, item[<span class="string">&#x27;information_categories&#x27;</span>]],</span><br><span class="line">                <span class="string">&#x27;tags&#x27;</span>: <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> <span class="string">&#x27;tags&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>(item).keys() <span class="keyword">else</span> item[<span class="string">&#x27;tags&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>: item[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;title_image&#x27;</span>: <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> <span class="string">&#x27;title_image&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">dict</span>(item).keys() <span class="keyword">else</span> item[<span class="string">&#x27;title_image&#x27;</span>],</span><br><span class="line">            &#125;]</span><br><span class="line">            <span class="comment"># 设置重连次数</span></span><br><span class="line">            requests.adapters.DEFAULT_RETRIES = <span class="number">15</span></span><br><span class="line">            <span class="comment"># 设置连接活跃状态为False</span></span><br><span class="line">            s = requests.session()</span><br><span class="line">            s.keep_alive = <span class="literal">False</span></span><br><span class="line">            req = requests.post(url_info, headers=&#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span>&#125;,</span><br><span class="line">                                json=form_data)</span><br><span class="line">            response = json.loads(req.text)</span><br><span class="line">            <span class="keyword">if</span> response[<span class="string">&#x27;code&#x27;</span>] != <span class="number">1</span>:</span><br><span class="line">                logger.error(<span class="string">&#x27;上传出错，返回：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(response))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            collection.update_one(<span class="built_in">filter</span>=&#123;<span class="string">&#x27;_id&#x27;</span>: item[<span class="string">&#x27;_id&#x27;</span>]&#125;, update=&#123;<span class="string">&#x27;$set&#x27;</span>: &#123;<span class="string">&#x27;cleaning_status&#x27;</span>: <span class="number">5</span>&#125;&#125;)</span><br><span class="line">            logger.info(<span class="string">&#x27;&#123;&#125;，上传成功！！！！！！！&#x27;</span>.<span class="built_in">format</span>(item[<span class="string">&#x27;title&#x27;</span>]))</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&#x27;上传完成，共上传：&#123;&#125; 条数据。。。。。&#x27;</span>.<span class="built_in">format</span>(count))</span><br><span class="line">        mongo.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> scrapy <span class="keyword">import</span> cmdline</span><br><span class="line"></span><br><span class="line">    cmdline.execute(<span class="string">&#x27;scrapy crawl zscq-uploadinfo&#x27;</span>.split())</span><br></pre></td></tr></table></figure><h3 id="操作redis"><a href="#操作redis" class="headerlink" title="操作redis"></a>操作redis</h3><p>安装:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install redis</span><br></pre></td></tr></table></figure><p>测试是否安装成功:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">r = redis.StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.get(<span class="string">&#x27;foo&#x27;</span>))</span><br><span class="line"><span class="comment"># &#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure><p>具体参考<a class="link"   href="https://www.runoob.com/w3cnote/python-redis-intro.html" >这里<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;操作MySQL&quot;&gt;&lt;a href=&quot;#操作MySQL&quot; class=&quot;headerlink&quot; title=&quot;操作MySQL&quot;&gt;&lt;/a&gt;操作MySQL&lt;/h3&gt;&lt;p&gt;首先安装pymysql包:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2022-1-24每日英语</title>
    <link href="http://example.com/2022/01/24/2022-1-24%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD/"/>
    <id>http://example.com/2022/01/24/2022-1-24%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD/</id>
    <published>2022-01-24T06:23:30.000Z</published>
    <updated>2022-01-25T08:34:42.603Z</updated>
    
    <content type="html"><![CDATA[<ol><li>dashboard n. (汽车的)仪表板; 总览板 [ˈdæʃbɔːrd]</li><li>credential n. 资格证明; 资格证书; 证件; 国书 [krəˈdenʃl]</li><li>wizard n. 向导程序 n. 巫师，术士；adj. 卓越的, 杰出的, 巫术的[ˈwɪzərd]</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;dashboard n. (汽车的)仪表板; 总览板 [ˈdæʃbɔːrd]&lt;/li&gt;
&lt;li&gt;credential n. 资格证明; 资格证书; 证件; 国书 [krəˈdenʃl]&lt;/li&gt;
&lt;li&gt;wizard n. 向导程序 n. 巫师，术士；adj. </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简单字体反爬之起点小说网</title>
    <link href="http://example.com/2022/01/24/%E7%AE%80%E5%8D%95%E5%AD%97%E4%BD%93%E5%8F%8D%E7%88%AC%E4%B9%8B%E8%B5%B7%E7%82%B9%E5%B0%8F%E8%AF%B4%E7%BD%91/"/>
    <id>http://example.com/2022/01/24/%E7%AE%80%E5%8D%95%E5%AD%97%E4%BD%93%E5%8F%8D%E7%88%AC%E4%B9%8B%E8%B5%B7%E7%82%B9%E5%B0%8F%E8%AF%B4%E7%BD%91/</id>
    <published>2022-01-24T06:13:30.000Z</published>
    <updated>2022-01-24T06:13:44.438Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在搞字体反爬，然后在网上看了看有哪些案例，就挑了这个来记录下，这个算是比较简单的，我们来看看:</p><p>首先打开<a class="link"   href="https://www.qidian.com/all/" >起点小说网<i class="fas fa-external-link-alt"></i></a>，然后我们打开开发者工具，定位到书籍的字数那里，我们发现显示出来的是乱码:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_18-31-12.3b25jy1g29w0.webp"                      alt="Snipaste_2022-01-22_18-31-12"                ></p><p>但是查看源代码却发现显示的是这样的:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_18-33-45.6m8mhqkqpz80.webp"                      alt="Snipaste_2022-01-22_18-33-45"                ></p><p>我抓了下包发现，有好两个.woff后缀的文件，我每个都试，发现关于数字和小数点的字体文件在第二个.woff的文件中:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_18-42-18.61pgeco4zlk0.webp"                      alt="Snipaste_2022-01-22_18-42-18"                ></p><p>复制链接下载然后用在线字体解析网站打开后发现是这样的:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_18-42-55.5voxle4pzhk0.webp"                      alt="Snipaste_2022-01-22_18-42-55"                ></p><p> 之所以说它简单是因为它就是<strong>英文字母对应其数字</strong>，我们先写一个字典(单词与数字的对应关系)，方便待会儿的对照:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;zero&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;one&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;two&#x27;</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;three&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;four&#x27;</span>: <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;five&#x27;</span>: <span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;six&#x27;</span>: <span class="string">&#x27;6&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;seven&#x27;</span>: <span class="string">&#x27;7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;eight&#x27;</span>: <span class="string">&#x27;8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;nine&#x27;</span>: <span class="string">&#x27;9&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们通过Python库的fonttools工具包，找出字体文件中包含的映射关系，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description : </span></span><br><span class="line"><span class="string">@File        : test_cmap</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/1/22 18:54</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       : </span></span><br><span class="line"><span class="string">@change      : </span></span><br><span class="line"><span class="string">@reason      : </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> scrapy.utils <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.project <span class="keyword">import</span> get_project_settings</span><br><span class="line"><span class="keyword">from</span> pybase.util <span class="keyword">import</span> send_file</span><br><span class="line"><span class="keyword">from</span> fontTools.ttLib <span class="keyword">import</span> TTFont</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url_ziti = <span class="string">&quot;https://qidian.gtimg.com/qd_anti_spider/vuPlalqg.woff&quot;</span></span><br><span class="line">ziti = requests.get(url_ziti)</span><br><span class="line"><span class="comment"># 下载ttf字体文件，然后通过BytesIO转化为内存文件，使用TTFont处理</span></span><br><span class="line">font = TTFont(BytesIO(ziti.content))</span><br><span class="line">cmap = font.getBestCmap()</span><br><span class="line"><span class="built_in">print</span>(cmap)</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">100495</span>: <span class="string">&#x27;period&#x27;</span>, <span class="number">100497</span>: <span class="string">&#x27;six&#x27;</span>, <span class="number">100498</span>: <span class="string">&#x27;zero&#x27;</span>, <span class="number">100499</span>: <span class="string">&#x27;five&#x27;</span>, <span class="number">100500</span>: <span class="string">&#x27;eight&#x27;</span>, <span class="number">100501</span>: <span class="string">&#x27;nine&#x27;</span>, <span class="number">100502</span>: <span class="string">&#x27;four&#x27;</span>, <span class="number">100503</span>: <span class="string">&#x27;two&#x27;</span>, <span class="number">100504</span>: <span class="string">&#x27;seven&#x27;</span>, <span class="number">100505</span>: <span class="string">&#x27;one&#x27;</span>, <span class="number">100506</span>: <span class="string">&#x27;three&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以用这两个字典组合一个新的字典:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code_num_dict = &#123;x: Eng_num_dict[cmap[x]] <span class="keyword">for</span> x <span class="keyword">in</span> cmap.keys()&#125;</span><br></pre></td></tr></table></figure><p>然后找出源码中所有的数字code，并进行筛选:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com = re.<span class="built_in">compile</span>(<span class="string">r&quot;&amp;#\d+&quot;</span>)</span><br><span class="line">codes = com.findall(content)</span><br><span class="line">codes_pure = [i <span class="keyword">for</span> i <span class="keyword">in</span> codes <span class="keyword">if</span> <span class="built_in">len</span>(i) == <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>然后进行替换:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> codes_pure:</span><br><span class="line">    content = content.replace(i + <span class="string">&#x27;;&#x27;</span>, code_num_dict[<span class="built_in">int</span>(i[<span class="number">2</span>:])])</span><br></pre></td></tr></table></figure><p>最后再获取我们想要的小说名称和字数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">content_parsed_tree = etree.HTML(content)</span><br><span class="line">info_dict = <span class="built_in">dict</span>()</span><br><span class="line">novel_title = content_parsed_tree.xpath(</span><br><span class="line">    <span class="string">&quot;//div[@class=&#x27;book-mid-info&#x27;]/h2/a/text()&quot;</span>)</span><br><span class="line">novel_words_num = content_parsed_tree.xpath(</span><br><span class="line">    <span class="string">f&quot;//div[@class=&#x27;book-mid-info&#x27;]/p[@class=&#x27;update&#x27;]/span/span[@class=&#x27;<span class="subst">&#123;font_family&#125;</span>&#x27;]/text()&quot;</span>)</span><br><span class="line">novel = &#123;novel_title[i]: novel_words_num[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(novel_title))&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意，这个网站的字体链接是时刻在变化的，链接对应的里面的字体资源也不一样，所以我们<strong>每次请求都需要再构造一个字体链接</strong></p><p>全部代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description :</span></span><br><span class="line"><span class="string">@File        : test_cmap</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/1/24 14:13</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       :</span></span><br><span class="line"><span class="string">@change      :</span></span><br><span class="line"><span class="string">@reason      :</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> fontTools.ttLib <span class="keyword">import</span> TTFont</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="comment"># url_ziti = &quot;https://qidian.gtimg.com/qd_anti_spider/vuPlalqg.woff&quot;</span></span><br><span class="line">url_content = <span class="string">&quot;https://www.qidian.com/all/&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">content = requests.get(url=url_content, headers=headers).text</span><br><span class="line">tree = etree.HTML(content)</span><br><span class="line">font_family = tree.xpath(</span><br><span class="line">    <span class="string">&#x27;//*[@id=&quot;book-img-text&quot;]/ul/li[1]/div[2]/p[3]/span/span/@class&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">url_ziti = <span class="string">&quot;https://qidian.gtimg.com/qd_anti_spider/&quot;</span> + font_family + <span class="string">&quot;.woff&quot;</span></span><br><span class="line">ziti = requests.get(url=url_ziti, headers=headers)</span><br><span class="line"><span class="comment"># 下载ttf字体文件，然后通过BytesIO转化为内存文件，使用TTFont方法处理</span></span><br><span class="line">font = TTFont(BytesIO(ziti.content))</span><br><span class="line">cmap = font.getBestCmap()</span><br><span class="line">Eng_num_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;zero&#x27;</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;one&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;two&#x27;</span>: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;three&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;four&#x27;</span>: <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;five&#x27;</span>: <span class="string">&#x27;5&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;six&#x27;</span>: <span class="string">&#x27;6&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;seven&#x27;</span>: <span class="string">&#x27;7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;eight&#x27;</span>: <span class="string">&#x27;8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;nine&#x27;</span>: <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;period&#x27;</span>: <span class="string">&#x27;.&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">code_num_dict = &#123;x: Eng_num_dict[cmap[x]] <span class="keyword">for</span> x <span class="keyword">in</span> cmap.keys()&#125;</span><br><span class="line">com = re.<span class="built_in">compile</span>(<span class="string">r&quot;&amp;#\d+&quot;</span>)</span><br><span class="line">codes = com.findall(content)</span><br><span class="line">codes_pure = [i <span class="keyword">for</span> i <span class="keyword">in</span> codes <span class="keyword">if</span> <span class="built_in">len</span>(i) == <span class="number">8</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> codes_pure:</span><br><span class="line">    content = content.replace(i + <span class="string">&#x27;;&#x27;</span>, code_num_dict[<span class="built_in">int</span>(i[<span class="number">2</span>:])])</span><br><span class="line">content_parsed_tree = etree.HTML(content)</span><br><span class="line">info_dict = <span class="built_in">dict</span>()</span><br><span class="line">novel_title = content_parsed_tree.xpath(</span><br><span class="line">    <span class="string">&quot;//div[@class=&#x27;book-mid-info&#x27;]/h2/a/text()&quot;</span>)</span><br><span class="line">novel_words_num = content_parsed_tree.xpath(</span><br><span class="line">    <span class="string">f&quot;//div[@class=&#x27;book-mid-info&#x27;]/p[@class=&#x27;update&#x27;]/span/span[@class=&#x27;<span class="subst">&#123;font_family&#125;</span>&#x27;]/text()&quot;</span>)</span><br><span class="line">novel = &#123;novel_title[i]: novel_words_num[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(novel_title))&#125;</span><br><span class="line"><span class="built_in">print</span>(novel)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天在搞字体反爬，然后在网上看了看有哪些案例，就挑了这个来记录下，这个算是比较简单的，我们来看看:&lt;/p&gt;
&lt;p&gt;首先打开&lt;a class=&quot;link&quot;   href=&quot;https://www.qidian.com/all/&quot; &gt;起点小说网&lt;i class=&quot;fas fa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>验证码识别简单基础案例</title>
    <link href="http://example.com/2022/01/23/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2022/01/23/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%A1%88%E4%BE%8B/</id>
    <published>2022-01-23T13:51:30.000Z</published>
    <updated>2022-01-24T01:07:00.256Z</updated>
    
    <content type="html"><![CDATA[<p>案例网站，<a class="link"   href="https://captcha7.scrape.center/" >点击跳转<i class="fas fa-external-link-alt"></i></a></p><p>所用到的库: tesserocr</p><p>步骤:</p><ol><li>在网页上保存验证码图片到本地</li><li>然后调用tesserocr.image_to_text()方法进行解析</li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220123/Snipaste_2022-01-23_21-57-52.2a8mqvug9c2s.webp"                      alt="Snipaste_2022-01-23_21-57-52"                ></p><p>代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tesserocr</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\Administrator\Pictures\verificationcode-example.png&#x27;</span>)</span><br><span class="line">result = tesserocr.image_to_text(image)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>运行效果如下:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220123/Snipaste_2022-01-24_01-38-44.i8h4hxzb16o.webp"                      alt="Snipaste_2022-01-24_01-38-44"                ></p><p>在安装<code>tesserocr</code>之前要先安装<code>Tesseract</code>，可以参考<a class="link"   href="https://cuiqingcai.com/31102.html" >这里<i class="fas fa-external-link-alt"></i></a>，然后我在测试上面代码的时候出现了以下错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to init API, possibly an invalid tessdata path: C:\Users\Administrator\AppData\Local\Programs\Python\Python37\/tessdata/</span><br></pre></td></tr></table></figure><p>通过<a class="link"   href="https://blog.csdn.net/qq_38410428/article/details/82700006" >这个博客<i class="fas fa-external-link-alt"></i></a>我解决了这个问题，也就是需要把<code>tessdata</code>放在Python的目录下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;案例网站，&lt;a class=&quot;link&quot;   href=&quot;https://captcha7.scrape.center/&quot; &gt;点击跳转&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所用到的库: tesserocr&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GitHub如何获取Token</title>
    <link href="http://example.com/2022/01/23/GitHub%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Token/"/>
    <id>http://example.com/2022/01/23/GitHub%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Token/</id>
    <published>2022-01-23T13:33:30.000Z</published>
    <updated>2022-01-24T01:06:02.541Z</updated>
    
    <content type="html"><![CDATA[<p>今天使用PicX图床的时候，发现突然要填Token，这里我就记录下如何生成GitHubToken:</p><ol><li><p>打开GitHub，然后点击setting</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220123/Snipaste_2022-01-23_21-36-01.36ws8kajv8m0.webp"                      alt="Snipaste_2022-01-23_21-36-01"                ></p></li><li><p>然后找到Developer settings</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220123/Snipaste_2022-01-23_21-36-43.62483r79syw0.webp"                      alt="Snipaste_2022-01-23_21-36-43"                ></p></li><li><p>点击Developer settings，再点击Personal access tokens</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220123/Snipaste_2022-01-23_21-38-21.2hi5hbegoew0.webp"                      alt="Snipaste_2022-01-23_21-38-21"                ></p></li><li><p>如果没有就点击Generate new token，然后选择对应的仓库，如果已经有对应仓库的token，可以点进去更新token</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220123/Snipaste_2022-01-23_21-40-18.3hn5nnfl8t60.webp"                      alt="Snipaste_2022-01-23_21-40-18"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220123/Snipaste_2022-01-23_21-40-55.u1xshwdnu6o.webp"                      alt="Snipaste_2022-01-23_21-40-55"                ></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天使用PicX图床的时候，发现突然要填Token，这里我就记录下如何生成GitHubToken:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开GitHub，然后点击setting&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
      </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于Pycharm如何添加代码模板(脚本)</title>
    <link href="http://example.com/2022/01/22/%E5%85%B3%E4%BA%8EPycharm%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF(%E8%84%9A%E6%9C%AC)/"/>
    <id>http://example.com/2022/01/22/%E5%85%B3%E4%BA%8EPycharm%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF(%E8%84%9A%E6%9C%AC)/</id>
    <published>2022-01-22T07:35:30.000Z</published>
    <updated>2022-01-22T08:23:43.614Z</updated>
    
    <content type="html"><![CDATA[<p>我们看到有些人的Pycharm编辑器每个代码的顶端都有一个提示或者每次都是复用同一个代码，这个操作是怎么完成的呢，我们来看看:</p><ol><li><p>打开设置</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_15-38-25.5pgxe4emzpo0.webp"                      alt="Snipaste_2022-01-22_15-38-25"                ></p></li><li><p>直接找不好找，机智的我们就开搜</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_15-40-14.635g036gxe00.webp"                      alt="Snipaste_2022-01-22_15-40-14"                ></p><p>可以看到HTMLFile是已经默认配置了的，HTMLFile下方的我们都可以配置，配置完点击Apply再点击OK，或者直接点击OK都行</p></li><li><p>下面这是我配置的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@Description : </span></span><br><span class="line"><span class="string">@File        : 11</span></span><br><span class="line"><span class="string">@Project     : test</span></span><br><span class="line"><span class="string">@Time        : 2022/1/22 15:52</span></span><br><span class="line"><span class="string">@Author      : LiHouJian</span></span><br><span class="line"><span class="string">@Software    : PyCharm</span></span><br><span class="line"><span class="string">@issue       : </span></span><br><span class="line"><span class="string">@change      : </span></span><br><span class="line"><span class="string">@reason      : </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> scrapy.utils <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">from</span> scrapy.utils.project <span class="keyword">import</span> get_project_settings</span><br><span class="line"><span class="keyword">from</span> pybase.util <span class="keyword">import</span> send_file</span><br></pre></td></tr></table></figure><p>效果:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_16-22-01.69naoak3lws0.webp"                      alt="Snipaste_2022-01-22_16-22-01"                ></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们看到有些人的Pycharm编辑器每个代码的顶端都有一个提示或者每次都是复用同一个代码，这个操作是怎么完成的呢，我们来看看:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开设置&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
        </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python如何安装.whl文件(当pip安装不了时)</title>
    <link href="http://example.com/2022/01/22/Python%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85.whl%E6%96%87%E4%BB%B6(%E5%BD%93pip%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86%E6%97%B6)/"/>
    <id>http://example.com/2022/01/22/Python%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85.whl%E6%96%87%E4%BB%B6(%E5%BD%93pip%E5%AE%89%E8%A3%85%E4%B8%8D%E4%BA%86%E6%97%B6)/</id>
    <published>2022-01-22T02:12:30.000Z</published>
    <updated>2022-01-22T02:25:57.223Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们通过<code>pip install xxx</code>的方式并不能成功安装想要的包，会出现如下所示报错:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_10-14-24.2b9njzxvdaf4.webp"                      alt="Snipaste_2022-01-22_10-14-24"                ></p><p>然后我们就需要去<a class="link"   href="https://pypi.org/" >pypi<i class="fas fa-external-link-alt"></i></a>这个网站上寻找我们想要的包，几乎都是可以找到的，比如我刚刚通过pip没安安装上fonttools，所以我在这边搜索并下载:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_10-17-37.4yuyyresvyo0.webp"                      alt="Snipaste_2022-01-22_10-17-37"                ></p><p>然后我们点进去点击Download files找到以.whl后缀的包再点击下载即可:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_10-19-33.767475sbhvc0.webp"                      alt="Snipaste_2022-01-22_10-19-33"                ></p><p>下载好之后我们点击在文件夹中显示:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_10-21-08.4yc2drl5xyc0.webp"                      alt="Snipaste_2022-01-22_10-21-08"                ></p><p>进入.whl包所在文件夹后，我们在路径一栏输入cmd，然后进入命令行(这个时候命令行就定位到了当前文件夹):</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_10-23-03.6pxy0sowr1s0.webp"                      alt="Snipaste_2022-01-22_10-23-03"                ></p><p>然后以下键入命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install xxx.whl</span><br></pre></td></tr></table></figure><p><code>xxx.whl</code>就是我们刚刚下载的<code>.whl</code>包的全名，然后回车即可安装:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220122/Snipaste_2022-01-22_10-25-37.d1hqcbai83c.webp"                      alt="Snipaste_2022-01-22_10-25-37"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候我们通过&lt;code&gt;pip install xxx&lt;/code&gt;的方式并不能成功安装想要的包，会出现如下所示报错:&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/image</summary>
      
    
    
    
    
  </entry>
  
</feed>
