<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-07T01:36:06.166Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux系统启动过程</title>
    <link href="http://example.com/2022/01/07/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2022/01/07/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2022-01-07T01:19:30.000Z</published>
    <updated>2022-01-07T01:36:06.166Z</updated>
    
    <content type="html"><![CDATA[<p>按下系统的电源开关，过一会儿就可以看到Linux的登录界面，你是否想过，从按下电源开关到登录界面的出现，这后面到底发生了什么?</p><p>我们先来看看一个整体的流程图:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-21-28.5sqouvy7v7g0.webp"                      alt="Snipaste_2022-01-07_09-21-28"                ></p><p>Linux系统在启动过程中，首先是固件(PC上大多是CMOS/BIOS)的物理检测，诸如检测系统的显卡，CPU和硬盘等，可从系统按下电源键后看到此检测信息；检测没有问题后，将读取硬盘的MBR(主引导记录)中的自举程序，Linux中常用的自举程序如LILO和GRUB。自举程序GRUB在系统启动期间只有一个作用，就是启动内核，内核在引导期间有两个主要的作用，一个是驱动系统硬件，另一个是启动系统init，init进程将读取其配置文件/etc/initab完成后继续所有的引导。</p><p>整个过程基本可以分为六个步骤:BIOS–&gt;MBR(GRUB)–&gt;Kernel–&gt;Init–&gt;Runlevel:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-30-19.10of2bn2nfrk.webp"                      alt="Snipaste_2022-01-07_09-30-19"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-31-22.tv1ntom0xc0.webp"                      alt="Snipaste_2022-01-07_09-31-22"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-32-05.1kg0n3aym7s0.webp"                      alt="Snipaste_2022-01-07_09-32-05"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-32-47.7h1x4nh4sps0.webp"                      alt="Snipaste_2022-01-07_09-32-47"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-33-50.7ab7flt0yr40.webp"                      alt="Snipaste_2022-01-07_09-33-50"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-34-15.157a06qsnr4w.webp"                      alt="Snipaste_2022-01-07_09-34-15"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_09-35-46.7ub8ya0rze4.webp"                      alt="Snipaste_2022-01-07_09-35-46"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;按下系统的电源开关，过一会儿就可以看到Linux的登录界面，你是否想过，从按下电源开关到登录界面的出现，这后面到底发生了什么?&lt;/p&gt;
&lt;p&gt;我们先来看看一个整体的流程图:&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
      </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mac终端美化教程</title>
    <link href="http://example.com/2022/01/07/mac%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/01/07/mac%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/</id>
    <published>2022-01-07T01:08:30.000Z</published>
    <updated>2022-01-07T01:11:02.352Z</updated>
    
    <content type="html"><![CDATA[<p>mac终端美化请参考:<a class="link"   href="https://www.wolai.com/fishc/exwe9Srj8St6THjGE6YVyz" >https://www.wolai.com/fishc/exwe9Srj8St6THjGE6YVyz<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;mac终端美化请参考:&lt;a class=&quot;link&quot;   href=&quot;https://www.wolai.com/fishc/exwe9Srj8St6THjGE6YVyz&quot; &gt;https://www.wolai.com/fishc/exwe9Srj8St6THjGE6YVy</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10分钟彻底搞懂“动态规划”算法</title>
    <link href="http://example.com/2022/01/06/10%E5%88%86%E9%92%9F%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E2%80%9C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%9D%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/01/06/10%E5%88%86%E9%92%9F%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E2%80%9C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%9D%E7%AE%97%E6%B3%95/</id>
    <published>2022-01-06T14:48:35.000Z</published>
    <updated>2022-01-07T06:38:24.257Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划是计算机中解决最优化问题的一种方法，它通常给我们的印象是效率高，速度快，但对于初学者来说，可能并不是那么容易理解，今天，我们抛开所有的数学公式，用实例给大家彻底讲懂动态规划算法。</p><p>首先我们来看一个经典的动态规划问题:</p><p>给你一个无序的数组，要求我们找出其中最长的递增的子序列:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_22-54-02.aqz9oufebo0.webp"                      alt="Snipaste_2022-01-06_22-54-02"                ></p><p>比如这里的1，2，4就是其中一个:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_22-55-38.6vj3uoidmbo0.webp"                      alt="Snipaste_2022-01-06_22-55-38"                ></p><p>1，2，3是另外一个答案:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_22-56-38.3s8er174pko0.webp"                      alt="Snipaste_2022-01-06_22-56-38"                ></p><p>这里我们再对这个问题做一些简化，我们要求这个算法只返回最长序列的”长度”就好了:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_22-58-07.5xu4n3s593o0.webp"                      alt="Snipaste_2022-01-06_22-58-07"                ></p><p>也就是3:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_22-59-30.3h6t8hadilc0.webp"                      alt="Snipaste_2022-01-06_22-59-30"                ></p><p>如果是你，你会怎么去求解这个问题呢？</p><p>其实最容易想到的办法是暴力枚举，或者叫暴力搜索；比如从1出发，下一个数字可以取5，2，4或者3，因为他们都是递增的:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-08-04.2yknz8xay5c0.webp"                      alt="Snipaste_2022-01-06_23-08-04"                ></p><p>假如我们第二个数字选5的话，再下一个数字就取不了了，因为剩下的2，4，3都比5小，不能构成一个递增序列:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-11-05.1nizitt9nbc0.webp"                      alt="Snipaste_2022-01-06_23-11-05"                ></p><p>那如果第二个数字选2的话，下一个数字可以是4，也可以是3，此时构成的递增序列长度为3:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-17-13.53bgtzf85u80.webp"                      alt="Snipaste_2022-01-06_23-17-13"                ></p><p>以此类推，如果第三个数字取4，下一个数字依然不能选，因为3比4小：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-18-44.334b9zirnag0.webp"                      alt="Snipaste_2022-01-06_23-18-44"                ></p><p>算法就这样一直循环往复地执行下去，直到我们把每个子序列都找了个遍：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-21-18.1aoayhtnv0o0.webp"                      alt="Snipaste_2022-01-06_23-21-18"                ></p><p>并且在遍历过程中，我们实时记录最长的子序列长度，最后可以知道，最长的子序列长度为3:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-24-06.1qamrhmrgcio.webp"                      alt="Snipaste_2022-01-06_23-24-06"                ></p><p>最后，我们按照同样的方法计算”从5出发”，”从2出发”，”从4出发”，”从3出发”的序列长度，选出最长的那个，算法结束：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-26-44.59pocn5asgs0.webp"                      alt="Snipaste_2022-01-06_23-26-44"                ></p><p>那么我们应该如何去实现这个算法呢？</p><p>我们可以定义一个函数L，这个函数会返回从数组第i个数字开始的最长子序列长度：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_23-28-43.2gu1109n9do0.webp"                      alt="Snipaste_2022-01-06_23-28-43"                ></p><p>然后我们检查i后面的所有数字，我们将索引记为j，只要这个数比当前数大(也就是说可以构成递增序列),我们就递归地调用函数自身，去计算从j开始的最长子序列长度:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-03-26.2ztd9w5f1d60.webp"                      alt="Snipaste_2022-01-07_10-03-26"                ></p><p>然后加1得到目前这个序列的总长度:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-04-43.5hi04glvyrs0.webp"                      alt="Snipaste_2022-01-07_10-04-43"                ></p><p>接着我们只需要遍历所有的j，然后选出最长的子序列长度返回即可:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-08-10.44dhoxp0v2g0.webp"                      alt="Snipaste_2022-01-07_10-08-10"                ></p><p>当然这个递归函数不能永无止境地调用下去，当i取到最后一个数字的时候，由于它后面已经没有其他数字与它构成子序列了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-11-04.6vuby5artm40.webp"                      alt="Snipaste_2022-01-07_10-11-04"                ></p><p>所以我们直接返回长度1:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-13-14.33isck7sr0y0.webp"                      alt="Snipaste_2022-01-07_10-13-14"                ></p><p>接下来我们只需要对数组中的每一个数i依次调用L函数，然后选出长度最长的那个返回即可：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-17-37.28hbi1yxvgkk.webp"                      alt="Snipaste_2022-01-07_10-17-37"                ></p><p>我们可以带入之前的数据进行测试:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-23-39.1po30y692ce8.webp"                      alt="Snipaste_2022-01-07_10-23-39"                ></p><p>可以看到这个算法成功返回了3:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-24-40.1aja6f2rd61s.webp"                      alt="Snipaste_2022-01-07_10-24-40"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-26-47.567n4occkr00.webp"                      alt="Snipaste_2022-01-07_10-26-47"                ></p><p>这个算法虽然能够帮我们算出答案，不过它最大的问题在于时间复杂度，假设数组的长度为n，那就一共存在2^n个子序列，而每一个子序列我们都需要去遍历一次(判断是否是递增序列)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-29-50.6oyhxexemsg0.webp"                      alt="Snipaste_2022-01-07_10-29-50"                ></p><p>很显然这是一个指数级别的算法，最慢的算法之一，如果我们用长度为100的数组做测试，可以看到程序运行了整整5秒才算出答案：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-43-11.3bx9ohe2xbq0.webp"                      alt="Snipaste_2022-01-07_10-43-11"                ></p><p>我这自己重写了一遍半分钟还没出结果：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-41-45.twmdko5ggz4.webp"                      alt="Snipaste_2022-01-07_10-41-45"                ></p><p>那有没有可能对算法进行一些优化呢，如果我们观察这个遍历树，会发现里面存在大量的重复计算：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_10-45-12.79jqgli36jo0.webp"                      alt="Snipaste_2022-01-07_10-45-12"                ></p><p>比如我们在遍历子序列1，2， 4的时候就已经计算过“从4开始的最大子序列的长度”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-07-56.4t0mkodkqlc.webp"                      alt="Snipaste_2022-01-07_11-07-56"                ></p><p>后面遍历1,4的时候又重复计算了一次</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-08-53.2su6qfxq1ww0.webp"                      alt="Snipaste_2022-01-07_11-08-53"                ></p><p>为了避免重复的计算，我们可以在第一次计算的时候将结果保存下来，之后遍历到相同的节点我们就不用再重复计算了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-13-56.1kfbttr1lccg.webp"                      alt="Snipaste_2022-01-07_11-13-56"                ></p><p>直接将之前的结果返回</p><p>这里我们可以用一个字典(哈希表)memo记录下“从i开始最长的子序列长度”也就是代码中的max_len，然后我们在函数的开头检查之前是否保存过这个答案，如果是，直接返回结果，否则再去计算答案：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-17-59.7cavz7n0nms0.webp"                      alt="Snipaste_2022-01-07_11-17-59"                ></p><p>可以看到经过修改的代码，只用了1毫秒就计算出了结果</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-19-10.8r03984lxkw.webp"                      alt="Snipaste_2022-01-07_11-19-10"                ></p><p>相比较之前的5秒是巨大的速度提升，动态规划正是通过避免重复节点的计算，来加速整个计算的过程，由于用到了字典(哈希表)来保存了计算的中间结果，因此我们也称之为“记忆化”搜索，这也是大家经常会说动态规划是“空间”换“时间”,当然也有人叫它“带备忘录”的递归或者叫递归树的“剪枝”，它们都是同一个意思，因为我们不需要对这些树子节点进行重复计算了：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-24-27.293klrn0sev4.webp"                      alt="Snipaste_2022-01-07_11-24-27"                ></p><p>有了递归的算法，我们还可以尝试将它改写成非递归，或者也叫迭代的形式，这样我们可以更加直观地去分析算法的时间复杂度，并且避免了递归时候的函数调用开销：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-27-25.dqw9jcvhfuo.webp"                      alt="Snipaste_2022-01-07_11-27-25"                ></p><p>从之前的算法我们知道，要计算出从“1”开始的最长子序列长度，我们需要依次检查它后面的所有数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-29-57.6haeksrc4l80.webp"                      alt="Snipaste_2022-01-07_11-29-57"                ></p><p>由于1可以和5，2，4，3构成递增序列，所以我们需要递归地计算从5,2,4,3开始的最长子序列长度，然后选出最长的那个，然后加1得到与第一个数构成的最长子序列长度：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-40-40.bvjoqqjium8.webp"                      alt="Snipaste_2022-01-07_11-40-40"                ></p><p>同样的，要计算从“5”出发的最长子序列，我们也需要先检查它后面的数：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-41-53.37n9rgkxuvi0.webp"                      alt="Snipaste_2022-01-07_11-41-53"                ></p><p>然后进行同样的计算</p><p>这里很显然，因为后面没有数可以与它构成递增序列，所以结果直接是1：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-43-22.6ei62hbkezs0.webp"                      alt="Snipaste_2022-01-07_11-43-22"                ></p><p>我们这样以此类推下去，直到最后一个数，由于从3出发的子序列之能是它自己，所以长度直接是1:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-45-50.380d7i5aex40.webp"                      alt="Snipaste_2022-01-07_11-45-50"                ></p><p>从这里的公式中可以发现，我们只要从后往前依次计算，就能把所有的答案给推算出来，大家是不是觉得很像数学归纳法：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-48-54.2qian9yzd440.webp"                      alt="Snipaste_2022-01-07_11-48-54"                ></p><p>最后我们根据列出的式子来实现这个迭代算法：<br>这里我们可以通过两个循环，外面的循环代表从下往上的依次计算：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-50-25.68ykybvgk5c0.webp"                      alt="Snipaste_2022-01-07_11-50-25"                ></p><p>里面的循环用于遍历括号中的这些数值:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-53-23.563eph2lxvc0.webp"                      alt="Snipaste_2022-01-07_11-53-23"                ></p><p>运算的结果我们可以存放在一个数组中，我们直接叫它L：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-52-30.19y42eppuzpc.webp"                      alt="Snipaste_2022-01-07_11-52-30"                ></p><p>接下来只要后面的数比当前数大(能构成递增序列)，我们就按同样的方法来计算这个L(i):<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-56-13.3uifhme2bxk0.webp"                      alt="Snipaste_2022-01-07_11-56-13"                ></p><p>最后我们返回L数组中最大的那个即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_11-57-24.49g1ko485ha0.webp"                      alt="Snipaste_2022-01-07_11-57-24"                ></p><p>这个该写的迭代算法同样可以帮我们计算出最终答案，并且由于这里只用了两个循环，每个循环最多执行n次，因此算法的时间复杂度是o(n^2)和之前的指数级别的算法是天壤之别</p><p>最后我们来总结下动态规划的一般思路：</p><ol><li>穷举法/暴力搜索</li><li>记忆化搜索/剪枝</li><li>改写成迭代形式</li></ol><p>首先，我们可以先简单粗暴地将所有答案穷举出来</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-22-51.4l3i0hy9xyg0.webp"                      alt="Snipaste_2022-01-07_14-22-51"                ></p><p>并画出递归树</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-23-40.4fj03dcx40w.webp"                      alt="Snipaste_2022-01-07_14-23-40"                ></p><p>尝试写一个递归函数来求解，如果发现遍历中存在大量的重复计算</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-24-55.1pjr24yy59ls.webp"                      alt="Snipaste_2022-01-07_14-24-55"                ></p><p>我们可以尝试用哈希表将数据缓存下来</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-26-19.13sgxrh6buqo.webp"                      alt="Snipaste_2022-01-07_14-26-19"                ></p><p>之后遍历到相同的节点就直接查表，避免重复的计算</p><p>最后，我们可以将计算的过程表示出来，然后观察公式求解的顺序</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-30-14.2kvr6ufise60.webp"                      alt="Snipaste_2022-01-07_14-30-14"                ></p><p>并尝试将递归形式改写成更简洁高效的迭代形式:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-32-06.78cb8vh642k0.webp"                      alt="Snipaste_2022-01-07_14-32-06"                ></p><p>如果大家搞懂了之前的内容，不如我们来试试另一个经典的动态规划问题，给你一个数组，要求我们要找出其中连续子序列的最大和:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-36-02.3w8d3wi51z00.webp"                      alt="Snipaste_2022-01-07_14-36-02"                ></p><p>比如这里的[2, -1, 2, 6]和最大:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220107/Snipaste_2022-01-07_14-36-49.6lb1qxlm9lc0.webp"                      alt="Snipaste_2022-01-07_14-36-49"                ></p><p>这个问题又如何求解呢</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;动态规划是计算机中解决最优化问题的一种方法，它通常给我们的印象是效率高，速度快，但对于初学者来说，可能并不是那么容易理解，今天，我们抛开所有的数学公式，用实例给大家彻底讲懂动态规划算法。&lt;/p&gt;
&lt;p&gt;首先我们来看一个经典的动态规划问题:&lt;/p&gt;
&lt;p&gt;给你一个无序的数组，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Puppeteer10分钟快速上手</title>
    <link href="http://example.com/2022/01/06/Puppeteer10%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>http://example.com/2022/01/06/Puppeteer10%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2022-01-06T08:28:30.000Z</published>
    <updated>2022-01-06T10:55:21.045Z</updated>
    
    <content type="html"><![CDATA[<p>爬虫，它就像是一只在互联网删爬行的蜘蛛，会根据我们实现定义好的规制为我们抓取需要的信息，以Python为例，你可以使用urllib或者requests发起一个http请求，并使用beautifulsoup或者lxml来分析返回的html文档，从中提取你需要的信息:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-32-53.ll3dxkbon5c.webp"                      alt="Snipaste_2022-01-06_16-32-53"                ></p><p>当然你也可以使用Scrapy这种专门为爬虫设计的框架，帮你完成从数据抓取，解析，存储以及调试的所有流程，Scrapy这类框架的优点自然是功能全，速度快，灵活性高，扩展性强，但是由于现在大多数网站都是动态加载的，前端呈现的内容可能由极其复杂的JavaScript程序控制，遇到加密混淆的程序，可能自己还得去逆向分析很久，今天我为大家介绍另一种，基于puppeteer的爬虫思路， 虽然他的效率不是最高的，但一定能让你在最短的时间内快速实现一个爬虫，并帮你抓取到需要的信息</p><ol><li><p>首先来介绍下puppeteer</p><p>puppeteer是一款强大web自动化工具，相比较selenium，phantomjs这些老牌的框架，puppeteer绝对是后起之秀，如果你写了一个web应用，你需要对页面的功能进行测试，譬如检测某个按钮是否会唤醒对话框界面，puppeter就完全可以胜任这个任务，由于它可以对浏览器进行操控，获取页面数据，自然也可以用它来做爬虫，爬虫不过是它众多应用中的其中一种，其实对于任何自动化的操作，我们都可以用它来完成，谷歌官方的puppeteer是通过JavaScript调用的，但是它在Python，Ruby，Go上都有对应的移植版本，如果你使用Python，你可以下载一个叫做pyppeteer的包，其中所有的API都是一致的，除了少数语法的不同，这里以JavaScript作为演示：</p></li><li><p>JavaScript演示puppeteer</p><p>首先确保你计算机中安装了Node.js：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-59-36.15i3x7qnyjcw.webp"                      alt="Snipaste_2022-01-06_16-59-36"                ></p><p>然后创建一个目录来保存我们这个项目(也就是这里的web-scraping-node)：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-04-26.3ba14obuhzc0.webp"                      alt="Snipaste_2022-01-06_17-04-26"                ></p><p>然后使用npm init 初始化工程:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-09-51.19lpfmo9zrkw.webp"                      alt="Snipaste_2022-01-06_17-09-51"                ></p><p>最后使用命令npm i puppeteer:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-11-44.1caw222u7jr4.webp"                      alt="Snipaste_2022-01-06_17-11-44"                ></p><p>这过程会持续一段时间，取决于你的网速</p><p>接着我们在文档的入门指南中找到这样一段样例程序，我们直接将代码复制到编辑器中，在它的基础上做修改:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-19-06.15ycsr9yxgqo.webp"                      alt="Snipaste_2022-01-06_17-19-06"                ></p><p>这是修改前的代码:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-32-34.365szkzldym0.webp"                      alt="Snipaste_2022-01-06_17-32-34"                ></p><p>这10行代码非常简单:</p><p>这是创建一个浏览器对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br></pre></td></tr></table></figure><p>打开一个新页面:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br></pre></td></tr></table></figure><p>然后转到example.com</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.goto(<span class="string">&#x27;https://example.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>保存一张截图后退出:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">&#x27;example.png&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><p>如果你运行代码，在短暂的等待之后，程序会当前目录下保存一张截图文件:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-46-02.3pgyll8rvx40.webp"                      alt="Snipaste_2022-01-06_17-46-02"                ></p><p>这里我们稍做修改，首先在创建浏览器对象的时候传入一个新参数headless: false,因为puppeteer默认运行在无头(headless)模式下，也就是说浏览器窗口并不会显示出来，这里我们通过这个参数关闭无头模式，接着我们将网址改为百度，并且删除后面的screenshot()和borwser.close(),保存程序，运行程序，可以看到puppeteer成功打开了百度并显示在新创建的浏览器窗口中，需要注意的是，这里窗口边缘的空白是一个feature，并不是一个bug:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_17-58-33.6xoeg0pu0h80.webp"                      alt="Snipaste_2022-01-06_17-58-33"                ></p></li><li><p>用puppeteer写爬虫</p><p>将bilibili上的音乐的热门信息给提取出来</p><p>以下是实施的步骤:<br>我们打开浏览器的控制台，然后我们可以在这里输入任何JavaScript表达式来做测试，比如:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-10-05.508av10kcpc0.webp"                      alt="Snipaste_2022-01-06_18-10-05"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-10-44.2hli00kc8jk0.webp"                      alt="Snipaste_2022-01-06_18-10-44"                ></p><p>如果我们想要在页面中提取相似的元素，我们可以用到selector(选择器)或者xpath，选择器的语法更为简单些，这里我们以选择器为例，比如你想要的匹配页面中的所有链接，可以在控制台中输入$$(‘a’),如果你想要匹配所有li元素下的a标签则可以输入$$(‘li &gt; a’),这里我们想找出能匹配这个视频标题的选择器，其实chrome给我们提供了一个便利，我们可以在标题上点右键，选择下方的检查，选中的元素就会以高亮的形式显示在右边:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-19-28.3x23lxbfiau0.webp"                      alt="Snipaste_2022-01-06_18-19-28"                ></p><p>我们点击右键，选择这里的复制选择器：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-21-25.1g3gk847wwtc.webp"                      alt="Snipaste_2022-01-06_18-21-25"                ></p><p>接下来我们只需要稍作修改，比如删掉这里多余的部分，做一些简化:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-22-55.7ed889q968g0.webp"                      alt="Snipaste_2022-01-06_18-22-55"                ></p><p>就可以提取出所有的标题元素了：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-24-09.1rx7v1w0alog.webp"                      alt="Snipaste_2022-01-06_18-24-09"                ></p><p>然后我们可以遍历返回的每个元素，将标题文字给提取出来:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-28-30.4z12qiuvgac0.webp"                      alt="Snipaste_2022-01-06_18-28-30"                ></p><p>我们可以先记下这段选择器，待会儿我们就会用到，我们先将浏览器中的网址直接拷贝过来,接下来使用page对象的$$eval函数来获取所有的视频标题：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-32-56.owj42n0njnk.webp"                      alt="Snipaste_2022-01-06_18-32-56"                ></p><p>这里的第一个参数是选择器，就是我之前测试时用于提取标题的选择器，第二个参数要求你传入一个函数，这个函数会直接在网页的上下文中运行，筛选出你需要的数据并返回给puppeteer，这里我做的是遍历所有的a标签,并将其中的文本给提取出来，我们可以调用log函数将结果打印出来：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-37-55.5pupnewbfcg0.webp"                      alt="Snipaste_2022-01-06_18-37-55"                ></p><p>运行程序，我们可以看到这样的结果：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-38-57.7867h3djf1c0.webp"                      alt="Snipaste_2022-01-06_18-38-57"                ></p><p>这里为了让程序更健壮，我们可以在获取标题之前，先等待标题元素的出现，这样可以避免页面加载期，无法找到元素而报错的现象:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-41-27.18gudqzv34o0.webp"                      alt="Snipaste_2022-01-06_18-41-27"                ></p><p>后面的代码直接上，我们限定了数据的时间，然后以json的数据格式保存下来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&quot;puppeteer&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> data = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    <span class="attr">headless</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">userDataDir</span>: <span class="string">&quot;./data&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> mo = <span class="number">1</span>; mo &lt; <span class="number">12</span>; mo++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> pg = <span class="number">1</span>; pg &lt;= <span class="number">10</span>; pg++) &#123;</span><br><span class="line">      mo = mo.toString().padStart(<span class="number">2</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">      <span class="keyword">await</span> page.goto(</span><br><span class="line">        <span class="string">&quot;https://www.bilibili.com/v/music/cover/?spm_id_from=333.5.b_7375626e6176.3#&quot;</span> +</span><br><span class="line">          <span class="string">`/all/click/0/<span class="subst">$&#123;pg&#125;</span>/2020-<span class="subst">$&#123;mo&#125;</span>-01,2020-<span class="subst">$&#123;mo&#125;</span>-29`</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> page.waitForSelector(<span class="string">&quot;.vd-list-cnt &gt; ul &gt; li &gt; div &gt; div.r &gt; a&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> titles = <span class="keyword">await</span> page.$$eval(</span><br><span class="line">        <span class="string">&quot;.vd-list-cnt &gt; ul &gt; li &gt; div &gt; div.r &gt; a&quot;</span>,</span><br><span class="line">        <span class="function">(<span class="params">links</span>) =&gt;</span> links.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x.innerText)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(titles);</span><br><span class="line">      data = data.concat(titles);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs.writeFile(<span class="string">&quot;data.json&quot;</span>, <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="string">&quot;\t&quot;</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>最后我想提一个大家可能经常会遇到的问题</p><p>我们每次运行脚本的时候，puppteteer磨人都会为我们创建一个崭新的实例，也就是像网页的缓存、cookie都会在脚本退出之后自动销毁：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-48-16.2hvjk63hyf60.webp"                      alt="Snipaste_2022-01-06_18-48-16"                ></p><p>像网站的登录信息也不会被保存下来，而通常我们并不希望每次运行脚本都去登录一次，这里我们可以给launch指定另外一个参数，他会将浏览器的数据保存在这个指定的路径下，因此所有的浏览器实例都会共享这些数据：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_18-50-57.2uf3kn93xve0.webp"                      alt="Snipaste_2022-01-06_18-50-57"                ></p><p>登录信息也会被保存下来</p><p>其实用puppteteer来做爬虫确实是一种不错的选择，要知道现在大多数网站都是使用了前端的JavaScript程序来做渲染的，相比于http层的爬虫工具，puppteteer更像是一个模拟网页操作的机器人，他用起来直观很多，也帮我们省去了不少分析前端代码的时间，不过想scrapy还是很强大的，尤其是他的速度和性能</p><p>源码：<a class="link"   href="https://github.com/rossning92/web-scraping" >https://github.com/rossning92/web-scraping<i class="fas fa-external-link-alt"></i></a></p><p>Puppeteer 中文文档：<a class="link"   href="https://zhaoqize.github.io/puppeteer-api-zh_CN/" >https://zhaoqize.github.io/puppeteer-api-zh_CN/<i class="fas fa-external-link-alt"></i></a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;爬虫，它就像是一只在互联网删爬行的蜘蛛，会根据我们实现定义好的规制为我们抓取需要的信息，以Python为例，你可以使用urllib或者requests发起一个http请求，并使用beautifulsoup或者lxml来分析返回的html文档，从中提取你需要的信息:&lt;br&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Kubernetes(k8s)10分钟快速入门</title>
    <link href="http://example.com/2022/01/06/Kubernetes(k8s)10%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/06/Kubernetes(k8s)10%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-06T03:27:30.000Z</published>
    <updated>2022-01-06T08:23:25.126Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>首先来看看Kubernetes用来解决一个什么样的问题</p><p>我们知道Docker就像是一个轻量型的虚拟机，它将应用程序的代码，工具库和运行环境全部都封装到了一个容器中:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_11-30-24.1xg7pjpery0w.webp"                      alt="Snipaste_2022-01-06_11-30-24"                ></p><p>因此大大降低了测试和部署的难度，我们要做的不过是在服务器上运行一条指令而已:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_11-31-59.55wt7na4mi80.webp"                      alt="Snipaste_2022-01-06_11-31-59"                ></p><p>但如果你要部署的是像购物系统这类架构复杂，规模庞大的应用，他们需要根据访问量自动分配服务器，网络资源，并且在某个容器宕机之后自动进行灾难恢复，故障转移：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_11-34-45.69pk7agfuvo0.webp"                      alt="Snipaste_2022-01-06_11-34-45"                ></p><p>这个时候Kubernetes就可以大显身手了</p></li><li><p>我们先从整体上来认识下Kubernetes的工作原理</p><p>我们知道，Kubernetes是一个用于大规模部署分布式应用的平台，他管理着一系列的主机或者服务器：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_11-38-08.13gnkn1jyotc.webp"                      alt="Snipaste_2022-01-06_11-38-08"                ><br>他们被称作Node(节点)，每个节点运行了相对独立的pod：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_11-39-32.1s8cewpm3ti8.webp"                      alt="Snipaste_2022-01-06_11-39-32"                ></p><p>pod是Kubernetes中可以部署的最小执行单元，说白了他就是一个或者多个容器的集合，其中运行了我们应用的某一部分核心组件，比如数据库，web服务器等等，当然这么多的pod，他们需要相互协调才能做到负载均衡或者故障转移，这就需要一台中心计算机来集中管理，这个中心计算机被称作Control Plane(控制面板):<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_14-18-15.6r5yi5pq4ls0.webp"                      alt="Snipaste_2022-01-06_14-18-15"                ></p><p>控制平面通过专有的API与各个节点进行通信，他会实时监测节点的网络状态来平衡服务器的负载，或者临时下发指令来应对突发的状况，比如Kubernetes发现某个容器或者pod挂掉了，他会立即启用在后台预先准别好的，随时待命的备用容器来替换它，这些容器被称作Replica Set(副本集合),正是由于他们的存在，才让我们的应用能够长时间，不间断地可靠运行，而以上讲到的所有节点连同控制面板，一起被称作一个cluster(集群)集群代表了Kubernetes所管理的全部主机节点，要配置一个Kubernetes集群，我们当然可以亲自租用服务器去搭建环境，不过步骤会稍微繁琐一点，另一种做法是使用现成的、预先配置好的云服务提供商:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_14-34-30.2e26p4k77yv4.webp"                      alt="Snipaste_2022-01-06_14-34-30"                ></p><p>一种完全免费的方法是使用minikube在本地模拟一个Kubernetes集群，这也是我接下来要用到的方法：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_14-39-18.4vsvzhoq8gi0.webp"                      alt="Snipaste_2022-01-06_14-39-18"                ></p></li><li><p>使用Kubernetes</p><p>上面我们提到，使用minikube在本地模拟一个Kubernetes集群，在这里面，我们照样可以使用Kubernetes的全部功能，只不过他不是一个真实的生产环境而已</p><p>我们按照这里的步骤下载并安装对应的版本:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_14-45-40.sr621c5plm8.webp"                      alt="Snipaste_2022-01-06_14-45-40"                ></p><p>随后只需要一行指令minikube start启动本地模拟的集群即可:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_14-47-00.6w0twd2xjjk0.webp"                      alt="Snipaste_2022-01-06_14-47-00"                ></p><p>我们来讲下如何在上面部署一个应用</p><p>首先我们需要创建一个yaml文件，里面定义了我们应用的基本信息，比如它由哪些pod组成，里面运行了哪些容器，以及网络配置等等，它和docker中的dockerfile很类似，你可以把它当做一个自动化脚本，里面描述了应用部署的整个过程，另外在vscode中，强烈建议去安装一个Kubernetes插件，他除了提供基本的语法检测、代码提示，在左侧面板中该显示了我们急缺的各种信息、运行状态：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_14-55-58.fl5umn41mrk.webp"                      alt="Snipaste_2022-01-06_14-55-58"                ></p><p>整个部署的过程也都可以通过图形界面完成</p><p>这里我们先创建一个deployment.yaml文件，然后输入deployment:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-02-30.4o9wyk7wep00.webp"                      alt="Snipaste_2022-01-06_15-02-30"                ></p><p>让vscode帮我们生成一个最最基本的配置：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-03-41.5b1fj6dhj600.webp"                      alt="Snipaste_2022-01-06_15-03-41"                ></p><p>可以看到这里列出了相当多的属性，我们可以将鼠标悬停在上面找到每个属性的详细用法:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-05-07.13s9ujkcnqlc.webp"                      alt="Snipaste_2022-01-06_15-05-07"                ></p><p>接下来我们去修改其中我们关系的部分即可，首先第一步我们先将所有的myapp改成我们应用的名字，这里的replicas指定了连同备用pod在内的所有pod数量:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-11-08.6di15uk8zn00.webp"                      alt="Snipaste_2022-01-06_15-11-08"                ></p><p>然后最重要的是这里的这个templates，它里面定义了与pod相关的所有信息：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-13-53.5808geph7nw0.webp"                      alt="Snipaste_2022-01-06_15-13-53"                ></p><p>比如下面的container指定了pod中运行的所有容器</p><p>这里我还是用上个视频同样的项目，一个简单的记账工具(一个非常简单的web应用)作为演示，不过我事先将他的镜像(image)上传到了Docker Hub上：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220106152000150.png"                      alt="image-20220106152000150"                ></p><p>这样Kubernetes可以自动拉取到它，于是我们这里直接填写镜像的名称即可：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-22-05.2u5xwz58da00.webp"                      alt="Snipaste_2022-01-06_15-22-05"                ></p><p>另外我们可以通过这里的limits为每一个pod设置合理的cpu和内存配额：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-23-41.2adum5srhrvo.webp"                      alt="Snipaste_2022-01-06_15-23-41"                ></p><p>最下面的containerPort指定了容器需要对外暴露的端口：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-24-43.6u1fzl28ce00.webp"                      alt="Snipaste_2022-01-06_15-24-43"                ></p><p>比如我们web容器使用的是5000端口</p><p>在默认情况下，我们的pod只能与同一个集群内的其他pod进行通信，虽然每一个pod都拥有一个独立的ip</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-28-53.6dwb57d7qhw0.webp"                      alt="Snipaste_2022-01-06_15-28-53"                ></p><p>但这个ip地址对于外网是不可见的，如果要从外网访问我们的应用，我们还需要用到Kubernetes中另一个重要的组件–服务(Services)</p><p>现在我们讲一种最最基础的服务，NodePort，它是一种最原始的将应用端口暴露给外网的方式：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-32-07.3qv9xytyt9c0.webp"                      alt="Snipaste_2022-01-06_15-32-07"                ></p><p>建立在它之上，Kubernetes还提供LoadBalancer或者更加复杂的ingress来实现负载的均衡，不过这里就不展开讨论了，我们先在下方用三个横线隔开(yaml中列表的语法)，然后输入Service来添加一个服务：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-36-59.1pbvhe08o0u8.webp"                      alt="Snipaste_2022-01-06_15-36-59"                ><br>接下来我们在selectors中指定应当将数据转发到哪一个pod上,这里直接填写之前的应用名称即可：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-39-12.3eim258jpq00.webp"                      alt="Snipaste_2022-01-06_15-39-12"                ></p><p>随后的type指定了服务的类型，也就是NodePort:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-40-48.77cyp47g6i40.webp"                      alt="Snipaste_2022-01-06_15-40-48"                ></p><p>后面的port和targetport我们设置成5000和容器端口保持一致，最后的nodeport指定了暴露给外网的端口，这里我设置成了30080，当然我们也可以省略这一行让Kubernetes自动进行分配：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-44-28.56i2v9l83g80.webp"                      alt="Snipaste_2022-01-06_15-44-28"                ></p><p>到这里我们的配置文件就完成了，接下来到了真正应用部署的环节：</p></li><li><p>应用部署</p><p>这里我们会用到一个命令行工具kubectl来与kubernetes集群进行交互：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-49-20.3cxi4q0rmzc0.webp"                      alt="Snipaste_2022-01-06_15-49-20"                ></p><p>这是一个所有平台通用的工具，就好比我们之前用到的docker命令一样，他可以操纵任何的集群，包括我们本地模拟的ninikube，通常Docker的桌面版本都自带了cubectl命令，但如果你计算机中没有安装Docker，则需要去这里额外下载:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-52-21.2ysxqfl38660.webp"                      alt="Snipaste_2022-01-06_15-52-21"                ></p><p>安装完毕后，我么可以使用kubectl apply来部署我们的应用，并且传入之前创建的这个yaml文件：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-53-35.71trrei7r8w0.webp"                      alt="Snipaste_2022-01-06_15-53-35"                ></p><p>可以看到这个命令被成功执行，此时kubernetes会在后台开始应用的部署：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_15-57-01.5wsor0ur4lg.webp"                      alt="Snipaste_2022-01-06_15-57-01"                ></p><p>我们可以通过kubectl get pods查看所有pod的运行状态，这里显示了我们之前指定的其中包括pod在内的三个pod,他们目前都是正常运行的状态:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-00-05.3lfq5ss9te80.webp"                      alt="Snipaste_2022-01-06_16-00-05"                ></p><p>另外使用kubectl get services可以查看所有创建的服务</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-03-31.2nmij0s7r620.webp"                      alt="Snipaste_2022-01-06_16-03-31"                ></p><p>看到这里，既然应用已经被成功部署，我们自然可以去浏览器中访问它。由于这里我们用到的是minikube模拟的集群，所以需要用到一个专门的指令minikube service 后面跟上我们服务的名字：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-07-06.4z5b5q4k4nk0.webp"                      alt="Snipaste_2022-01-06_16-07-06"                ></p><p>这样minikube会自动在浏览器中打开我们的应用，另外顺便提一下，之前所有的操作也都可以通过vscode中的插件完成，里面可以查看各个节点，pod，服务的运行状态，停止或者删除它们：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-09-46.2xaoloj3u1o0.webp"                      alt="Snipaste_2022-01-06_16-09-46"                ></p></li><li><p>更新应用</p><p>这个时候如果我们想要更新应用，比如切换容器镜像的版本，或者重新分配cpu和内存资源，我们只需要去修改之前的deployment.yaml文件：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-12-08.2c07pz6vufs.webp"                      alt="Snipaste_2022-01-06_16-12-08"                ></p><p>然后再次调用kubectl apply即可</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-13-00.5xjzjcawlfs0.webp"                      alt="Snipaste_2022-01-06_16-13-00"                ></p><p>kubernetes会在后台无缝地更新我们的应用，确保新版本运行起来以后再去销毁旧的版本，因此用户不会遇到服务停机的问题，类似的，如果我们不再需要这个应用，那么可以通过kubectl delete命令从集群上完全移除它：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_16-16-10.4dyacckkq08.webp"                      alt="Snipaste_2022-01-06_16-16-10"                ></p><p>后面我们传入相同的配置文件即可</p><p>讲到这里，我们也不是是介绍了kubernetes中一个非常简单的应用部署，通常生产环境下的应用比这个要复杂得多，如果大家想继续深入的话，还是建议去阅读下官方的文档，里面可以找到各种实用的案例，包括安全配置，网络管理，故障排除甚至是GPU调度等等</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先来看看Kubernetes用来解决一个什么样的问题&lt;/p&gt;
&lt;p&gt;我们知道Docker就像是一个轻量型的虚拟机，它将应用程序的代码，工具库和运行环境全部都封装到了一个容器中:&lt;br&gt;&lt;img  
                     lazyloa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker10分钟快速入门</title>
    <link href="http://example.com/2022/01/05/Docker10%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/05/Docker10%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-05T09:43:30.000Z</published>
    <updated>2022-01-06T03:22:18.716Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>docker是用来解决什么样的问题而出现的呢？</p><p>比如你写了个web应用，并且本地调试没有任何问题，这时候你想发给你的朋友试试看，或者部署到远程的云服务器上，那么首先，你需要配置相同的软件，比如数据库，web服务器，必要的插件，库等等:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://raw.githubusercontent.com/stormwasd/image-hosting/master/20220105/Snipaste_2022-01-05_17-50-31.2m1zv95ek8q0.webp"                      alt="Snipaste_2022-01-05_17-50-31"                ></p><p>而且你还不能保证软件一定能正常地运行起来，因为别人用的可能是完全不同的操作系统，即便同样是使用Linux，每一种发行版也会有微小的区别，为了模拟完全相同的本地环境，我们自然会想到使用虚拟机:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_17-54-07.76nk5wj75k80.webp"                      alt="Snipaste_2022-01-05_17-54-07"                ></p><p>但是虚拟机需要模拟硬件，运行整个操作系统，不但体积臃肿，内存占用高，程序的性能也会收到影响，这时候我们的docker就派上了用场，Docker在概念上与虚拟机非常类似，但却轻量很多，它不会去模拟底层的硬件，只会为每一个应用提供完全隔离的运行环境:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_17-59-22.73sdbazwwcw0.webp"                      alt="Snipaste_2022-01-05_17-59-22"                ></p><p>你可以在环境中配置不同的工具软件，并且不同环境之间相互不影响，这个“环境”在Docker中也被称作container/容器，降到这里，我么就不得不提到Docker中的三个重要概念，Dockerfile，Image和Container:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_18-02-38.7553xxlrsww0.webp"                      alt="Snipaste_2022-01-05_18-02-38"                ></p></li><li><p>Docker中三个重要的概念</p><ul><li><p>Image:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_18-04-17.49lnmefleyq0.webp"                      alt="Snipaste_2022-01-05_18-04-17"                ></p><p>你可以把它理解为一个虚拟机的快照(Snapshot)，里面包含了你要部署的应用程序以及它所关联的所有库，通过镜像，我们可以创建许多个不同的Container容器:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_18-10-19.4cu1gngya880.webp"                      alt="Snipaste_2022-01-05_18-10-19"                ></p><p>这里的容器就像是一台台运行起来的虚拟机，里面运行了你的应用程序，每个容器是独立运行的，他们相互之间不影响，最后Dockerfile就像是一个自动化脚本，它主要被用来创建我们之前讲到的镜像(Image)，这个过程就好比是我们在虚拟机中安装操作系统和软件一样，只不过是通过Dockerfile这个自动化脚本完成了</p></li><li><p>Image</p><p>Docker把应用程序及其依赖，打包在Image文件里面，只有通过这个文件,才能生成Docker容器，Image文件可以看成是容器的模板，Docker根据Image文件生成容器的实例，同一个Image文件，可以生成多个同时运行的容器实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 列出本机的所有 image 文件。</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"># 删除 image 文件</span><br><span class="line">$ docker image rm imageName</span><br></pre></td></tr></table></figure></li><li><p>Container</p><p>Container就类似于我们所创建的虚拟机，内存没有虚拟机那么大，也更容易创建</p></li></ul></li><li><p>快速上手Docker的最好方法就是亲自安装并去使用它:</p><p>如果你是用的是windows和mac，你可以在官网下载一个Docker Desktop的应用，而且在win10上你可以使用WSL2(也就是windows下的Linux子系统)来运行Docker，如果你不是使用的windows最新的预览版本，WSL2的安装可能稍微复杂一点，不过也是按照官网的给定步骤进行安装，在linux中，我们可以直接使用包管理工具，按照官网给定的指示一步步执行即可，如果使用的是vscode，也特别推荐安装docker的扩展:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_18-29-02.60a5lv1c8p80.webp"                      alt="Snipaste_2022-01-05_18-29-02"                ></p><p>他会提供Dockerfile的语法检测，代码高亮，自动补全等等，你也可以通过菜单运行各种Docker命令并且在左侧面板中看到你创建的所有镜像:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_18-31-36.22dn9le7rpog.webp"                      alt="Snipaste_2022-01-05_18-31-36"                ></p><p>接下来我们就尝试使用Docker来部署一个应用，以之前写的一个python程序举例，这是一个非常简单的用Flask搭建的记账工具:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_18-34-01.qkldrwvx6w0.webp"                      alt="Snipaste_2022-01-05_18-34-01"                ></p><p>首先我们在应用的根目录下创建一个Dockerfile文件:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_18-35-48.281d9c6fy9wk.webp"                      alt="Snipaste_2022-01-05_18-35-48"                ></p><p>第一行我们需要用FROM命令指定一个基础镜像(base image)这样可以帮我们节省许多软件安装和配置的时间:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_18-38-06.1at86ylsopfk.webp"                      alt="Snipaste_2022-01-05_18-38-06"                ></p><p>可以看到在DockerHub上提供了许多高质量的操作系统镜像，比如ubuntu:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_18-39-51.5hf8vebgvdo0.webp"                      alt="Snipaste_2022-01-05_18-39-51"                ></p><p>不同的操作系统提供不同的包管理工具，比如ubuntu上的apt，Fedora上的dnf，当然在Docker Hub上还有许多方便某一种语言，某种框架开发的镜像，比如你nginx,Python,node等：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220105/Snipaste_2022-01-05_18-43-19.7igxaak5xtk0.webp"                      alt="Snipaste_2022-01-05_18-43-19"                ></p><p>由于我这里做的是python的开发，自然我会使用Python的镜像，这样免去了它的安装步骤，这里的Python是官方镜像的名字:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-07-02.5g2pbzlwofo0.webp"                      alt="Snipaste_2022-01-06_09-07-02"                ></p><p>冒号后面这一串是版本号，同时也是一个标签，我们可以在docker hub中搜索Python然后点击Python转到docker hub的镜像页面，里面可以找到所有支持的标签:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-09-39.1exez16kc0g0.webp"                      alt="Snipaste_2022-01-06_09-09-39"                ></p><p>比如我们这里用的是Python 3.8版本：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-11-22.3tk2dyha4s20.webp"                      alt="Snipaste_2022-01-06_09-11-22"                ></p><p>运行在debian buster的发行版本上，后面的workdir指定了之后所有Docker命令的工作路径(working directory),注意是这个命令之后的所有Docker命令，比如我们马上要讲到的run，copy等：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-15-35.5ayvdc0i3is0.webp"                      alt="Snipaste_2022-01-06_09-15-35"                ></p><p>当然如果这个路径不存在，Docker会自动帮你创建，这样可以避免使用绝对路径或者手动cd切换路径，增加程序的可读性，之后，我们可以调用copy命令将所有的程序拷贝到Docker镜像中(copy./app表示将当前目录下所有文件(除了.dockerignore排除的路径),都拷贝进入image文件的/app目录)：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-24-30.417yncrzn3q0.webp"                      alt="Snipaste_2022-01-06_09-24-30"                ></p><p>第一个参数代表本地文件，“.”代表程序根目录下的所有文件，第二个参数代表Docker镜像中的路径，这里的.代表当前的工作路径，也就是之前指定的app目录，随后的run允许我们在创建镜像时运行任意的shell命令，因为我们用的是Linux镜像，所以像echo，pwd，cp，rm这些都是合法的，比如我这里用到pip install 来安装Python程序的所有关联:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-32-30.h34cjvn2xc0.webp"                      alt="Snipaste_2022-01-06_09-32-30"                ><br>通过以上的所有命令，我们就可以完成一个Docker镜像的创建，在Dockerfile的最后，我们会用到CMD来指定当Docker容器运行起来以后要执行的命令：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-35-38.6as26jnmec00.webp"                      alt="Snipaste_2022-01-06_09-35-38"                ></p><p>大家需要注意这里容器和镜像的区别(容器不等于镜像),并且它和之前讲到的run不一样，run是创建镜像时使用的，而cmd是运行容器时使用的，到这里我们的自动化脚本dockerfile就完成了，接下来我们可以使用docker build来创建一个镜像，这里的-t指定了镜像的名字，最后面的.告诉docker应该在当前目录下寻找这个dockerfile，这个不能省略:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-45-12.2vcobfm0uuu0.webp"                      alt="Snipaste_2022-01-06_09-45-12"                ></p><p>第一次调用docker build会比较慢，因为docker会下载必要的镜像文件:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-47-59.5c9u6zrhi7k0.webp"                      alt="Snipaste_2022-01-06_09-47-59"                ></p><p>然后一行行运行我们的指令，不过再次调用就会快很多，</p><p>因为docker会缓存之前的每一个操作，这个在Docker中也被称为分层:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-50-09.3bl985352200.webp"                      alt="Snipaste_2022-01-06_09-50-09"                ></p><p>这里我们就不展开谈论了</p><p>有了镜像之后，我们就可以通过docker run来启动一个容器</p><p>这里需要注意的是这个-p参数：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_09-55-53.2onjc4xeasi0.webp"                      alt="Snipaste_2022-01-06_09-55-53"                ></p><p>他会将容器上的某一个端口，映射到你的本地主机上，这样你才能从主机上访问容器中的web应用，前面的80是我们本地主机上的端口，后面是容器上的端口，这个不要搞反了，第二个参数-d(–detached)让容器在后台运行，这样容器的输出就不会直接显示在控制台，如果不出意外的话，你已经可以在浏览器中访问这个web应用了，我们通过Docker Desktop这个图形界面可以查看应用在后台的所有输出:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-08-02.36m8ycdvdxg0.webp"                      alt="Snipaste_2022-01-06_10-08-02"                ></p><p>这个对于调试非常方便，同时我们可以看到当前容器的各种信息：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-10-09.r1fiz3egtjk.webp"                      alt="Snipaste_2022-01-06_10-10-09"                ></p><p>这里的congainer显示了我们创建的所有容器,我们可以选择停止，重启或者删除他们，还可以通过shell远程调试这个容器：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-14-30.4pqhtycfelk0.webp"                      alt="Snipaste_2022-01-06_10-14-30"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-15-12.bhying3kndc.webp"                      alt="Snipaste_2022-01-06_10-15-12"                ></p><p>这里是它们所对应的的命令行指令：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-16-05.65omebt46kw0.webp"                      alt="Snipaste_2022-01-06_10-16-05"                ></p><p>需要注意的是，当我们删除一个容器的时候，之前所做的修改，新添加的数据会全部丢失，这就好比是我们删除一个虚拟机，里面的数据会一通销毁一样，如果我们希望保留容器中的数据，我们可以使用Docker提供的volume数据卷:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-19-22.4vricykfn660.webp"                      alt="Snipaste_2022-01-06_10-19-22"                ></p><p>你可以把它当做是一个在本地主机和不同容器中共享的文件夹:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-21-00.1hxtoxcx3v9c.webp"                      alt="Snipaste_2022-01-06_10-21-00"                ></p><p>比如你在某个容器中修改了某一个volume的数据，他会同时反映在其他的容器上:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-22-50.7eeib6w3iug0.webp"                      alt="Snipaste_2022-01-06_10-22-50"                ></p><p>我们可以通过docker volume create来创建一个数据卷：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-25-28.23owq2z9imqo.webp"                      alt="Snipaste_2022-01-06_10-25-28"                ></p><p>随后在启动容器的时候我们可以通过-v参数指定将这个数据卷挂载(mount)到容器中的哪一个路径上:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-28-47.32vufkycoms0.webp"                      alt="Snipaste_2022-01-06_10-28-47"                ></p><p>这里可以看到我们将my-finance-data挂载到了/etc/finance这个路径下，向这个路径写入的任何数据都会被永久保存在这个数据卷中</p></li><li><p>多容器共同协作</p><p>之前我们讲到的例子都只涉及单个容器，但在实际使用中，我们的应用程序可能会用到多个容器共同协作，比如我们可以使用一个容器来运行web应用，另一个容器来运行数据库系统:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-34-59.1v1da3n2g5ts.webp"                      alt="Snipaste_2022-01-06_10-34-59"                ></p><p>这样可以做到数据和应用逻辑的有效分离，比如当web程序宕机了，数据库依然在有效运转，这个时候我们只需要修复web容器即可，而Docker compose刚好可以帮我们做到这一点：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-37-04.uq5sdls57fk.webp"                      alt="Snipaste_2022-01-06_10-37-04"                ></p><p>我们可以创建一个docker-compose.yml文件，在这个文件下，我们通过services来定义多个container，比如这里我们定义一个web容器，它里面运行了我们的web应用，然后再定义一个db容器，里面运行了mysql数据库系统,这里我们可以通过这两个环境变量指定数据库的名称和连接密码：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-45-37.3cx3ya9lk3m0.webp"                      alt="Snipaste_2022-01-06_10-45-37"                ></p><p>同时在db容器中，我们还可以通过volumes指定一个数据卷用来永久存放数据：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-48-16.2x0xocste3m0.webp"                      alt="Snipaste_2022-01-06_10-48-16"                ></p><p>定义完毕之后，我们保存文件，使用docker compose up来运行所有容器，这里的-d(detach)同样代表在后台运行所有的容器，不直接输出在控制台:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-53-40.77bvpewa1dc0.webp"                      alt="Snipaste_2022-01-06_10-53-40"                ></p><p>与这个命令对应的，我们可以使用docker compose down来停止并删除所有的容器:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-56-44.7epfrtupdsc0.webp"                      alt="Snipaste_2022-01-06_10-56-44"                ></p><p>不过新创建的数据卷需要我们手动删除(除非在上面的命令中加上–volumes参数)：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_10-57-53.1mnh7u350bc0.webp"                      alt="Snipaste_2022-01-06_10-57-53"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_11-01-02.5iu5hfk2h9o0.webp"                      alt="Snipaste_2022-01-06_11-01-02"                ></p><p>另外刚刚讲到的所有操作都可以做图形界面上完成</p></li><li><p>简单聊下Docker和kubernetes的区别和联系</p><p>虽然大家都说kubernetes在逐渐取代Dokcer，但其实指的是kubernetes中的容器引擎(container engines)而已：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_11-05-39.6hybxvb32s00.webp"                      alt="Snipaste_2022-01-06_11-05-39"                ></p><p>实际上kubernetes和Docker并不是同一个层面上的东西，在之前的例子中，我们的应用，数据库容器都运行在同一个计算机中，随着应用规模的增大，一台计算机没有办法满足我们的需求:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20220106/Snipaste_2022-01-06_11-15-40.c5l8w87kit4.webp"                      alt="Snipaste_2022-01-06_11-15-40"                ></p><p>当我们想使用一个集群的电脑来提供服务，并做到负载均衡，故障转移等等，这个时候kubernetes就可以大显身手了，一句话将，kubernetes所做的就是将你的各个容器分发到一个集群(cluster)上运行，并进行全自动化的管理，包括应用的部署和升级</p></li><li><p>最后附上docker中文教程</p><p><a class="link"   href="https://www.coonote.com/docker/docker-tutorial.html" >https://www.coonote.com/docker/docker-tutorial.html<i class="fas fa-external-link-alt"></i></a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;docker是用来解决什么样的问题而出现的呢？&lt;/p&gt;
&lt;p&gt;比如你写了个web应用，并且本地调试没有任何问题，这时候你想发给你的朋友试试看，或者部署到远程的云服务器上，那么首先，你需要配置相同的软件，比如数据库，web服务器，必要的插件，库等等:&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bash脚本教程</title>
    <link href="http://example.com/2022/01/05/Bash%E8%84%9A%E6%9C%AC%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/01/05/Bash%E8%84%9A%E6%9C%AC%E6%95%99%E7%A8%8B/</id>
    <published>2022-01-05T09:20:30.000Z</published>
    <updated>2022-01-05T09:21:36.725Z</updated>
    
    <content type="html"><![CDATA[<p>请参考: <a class="link"   href="https://www.ruanyifeng.com/blog/2020/04/bash-tutorial.html" >https://www.ruanyifeng.com/blog/2020/04/bash-tutorial.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;请参考: &lt;a class=&quot;link&quot;   href=&quot;https://www.ruanyifeng.com/blog/2020/04/bash-tutorial.html&quot; &gt;https://www.ruanyifeng.com/blog/2020/04/bash-tu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SSH最详细入门教程</title>
    <link href="http://example.com/2022/01/05/SSH%E6%9C%80%E8%AF%A6%E7%BB%86%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/01/05/SSH%E6%9C%80%E8%AF%A6%E7%BB%86%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</id>
    <published>2022-01-05T09:03:30.000Z</published>
    <updated>2022-01-05T09:03:47.413Z</updated>
    
    <content type="html"><![CDATA[<p>请参考: <a class="link"   href="https://www.ruanyifeng.com/blog/2020/12/ssh-tutorial.html" >https://www.ruanyifeng.com/blog/2020/12/ssh-tutorial.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;请参考: &lt;a class=&quot;link&quot;   href=&quot;https://www.ruanyifeng.com/blog/2020/12/ssh-tutorial.html&quot; &gt;https://www.ruanyifeng.com/blog/2020/12/ssh-tuto</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker最详细入门教程</title>
    <link href="http://example.com/2022/01/05/Docker%E6%9C%80%E8%AF%A6%E7%BB%86%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2022/01/05/Docker%E6%9C%80%E8%AF%A6%E7%BB%86%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</id>
    <published>2022-01-05T08:39:30.000Z</published>
    <updated>2022-01-05T08:39:32.981Z</updated>
    
    <content type="html"><![CDATA[<p>请参考: <a class="link"   href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" >http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;请参考: &lt;a class=&quot;link&quot;   href=&quot;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot; &gt;http://www.ruanyifeng.com/blog/2018/02/docker-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>推荐一款基于GitHub好用的在线图床工具</title>
    <link href="http://example.com/2021/12/31/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8Egitgub%E5%A5%BD%E7%94%A8%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%9B%BE%E5%BA%8A%E5%B7%A5%E5%85%B7/"/>
    <id>http://example.com/2021/12/31/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8Egitgub%E5%A5%BD%E7%94%A8%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%9B%BE%E5%BA%8A%E5%B7%A5%E5%85%B7/</id>
    <published>2021-12-31T07:24:30.000Z</published>
    <updated>2021-12-31T07:28:26.997Z</updated>
    
    <content type="html"><![CDATA[<p>这是一款基于GItHubAPI开发的图床神器，图片外链使用jsDriver进行CDN加速，免下载，免安装，打开网站简单配置后即可直接使用，免费，稳定，高效</p><p>PicX官网: <a class="link"   href="https://picx.xpoet.cn/#/upload" >https://picx.xpoet.cn/#/upload<i class="fas fa-external-link-alt"></i></a></p><p>PicXGitHub地址: <a class="link"   href="https://github.com/XPoet/picx" >https://github.com/XPoet/picx<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是一款基于GItHubAPI开发的图床神器，图片外链使用jsDriver进行CDN加速，免下载，免安装，打开网站简单配置后即可直接使用，免费，稳定，高效&lt;/p&gt;
&lt;p&gt;PicX官网: &lt;a class=&quot;link&quot;   href=&quot;https://picx.xpoet.c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>科学上网教程</title>
    <link href="http://example.com/2021/12/31/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2021/12/31/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/</id>
    <published>2021-12-31T07:19:30.000Z</published>
    <updated>2021-12-31T07:21:25.421Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搭hexo博客的时候在一篇theme配置教程中看到了一个开源的图床项目，里面有关于科学上网的介绍，这里我把它搬出来，详情请点击:<a class="link"   href="https://github.com/Alvin9999/new-pac/wiki" >https://github.com/Alvin9999/new-pac/wiki<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在搭hexo博客的时候在一篇theme配置教程中看到了一个开源的图床项目，里面有关于科学上网的介绍，这里我把它搬出来，详情请点击:&lt;a class=&quot;link&quot;   href=&quot;https://github.com/Alvin9999/new-pac/wiki&quot; &gt;ht</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>什么是宝塔面板</title>
    <link href="http://example.com/2021/12/31/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/"/>
    <id>http://example.com/2021/12/31/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/</id>
    <published>2021-12-31T06:48:30.000Z</published>
    <updated>2021-12-31T06:54:14.789Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说: 就是装在服务器上的管理面板！</p><p>宝塔面板是一款简单好用的服务器运维面板，简单说来就是一个可视化的面板管理工具，支持一键LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA等100多项服务器管理功能。出错少而且安全，由于宝塔面板既有windows版本也有linux版本，尤其是Linux服务器很多用户不会操作，宝塔是为了让那些不会linux的人使用的，使用宝塔，操作linux更简单，更方便，这里要提醒一下虽然宝塔面板可以安装在物理服务器或者云服务器，虚拟主机无法安装的，但是云服务器基本都是可以安装的。</p><p>大型网站程序都安装在服务器上，服务器用的是Linux系统，进行服务器维护需要记住很多的linux命令，这就比较麻烦；</p><p>面板的好处就是通过一个交互界面就能完成服务器的维护工作，比如更新系统，添加网站，修改设置等等，以前需要记住各种命令，下你在通过面板点点按钮就可以了，省时省力.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单来说: 就是装在服务器上的管理面板！&lt;/p&gt;
&lt;p&gt;宝塔面板是一款简单好用的服务器运维面板，简单说来就是一个可视化的面板管理工具，支持一键LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA等100多项服务器管理功能。出错少而且安全，由于宝塔面板既有windo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python思维导图</title>
    <link href="http://example.com/2021/12/31/Python%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://example.com/2021/12/31/Python%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</id>
    <published>2021-12-31T03:50:30.000Z</published>
    <updated>2021-12-31T06:35:18.758Z</updated>
    
    <content type="html"><![CDATA[<img                       lazyload                     src="/images/loading.svg"                     data-src="https://cdn.jsdelivr.net/gh/stormwasd/image-hosting@master/20211231/Python思维导图.3kk4b6whqsi0.webp"                      alt="Python思维导图" style="zoom: 200%;"                 ><p>原文链接:<a class="link"   href="https://blog.csdn.net/qq_44647926/article/details/90669352?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164090955916780269896755%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=164090955916780269896755&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-13-90669352.first_rank_v2_pc_rank_v29&amp;utm_term=Python&amp;spm=1018.2226.3001.4187" >https://blog.csdn.net/qq_44647926/article/details/90669352?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164090955916780269896755%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=164090955916780269896755&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-13-90669352.first_rank_v2_pc_rank_v29&amp;utm_term=Python&amp;spm=1018.2226.3001.4187<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;https://cdn.jsdelivr.net/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python之多进程</title>
    <link href="http://example.com/2021/12/30/Python%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2021/12/30/Python%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-12-30T08:44:30.000Z</published>
    <updated>2021-12-30T09:10:47.336Z</updated>
    
    <content type="html"><![CDATA[<p>要让Python实现多进程(multiprocessing),我们先来了解下操作系统相关知识, Unix和Linux操作系统提供了一个fork()函数系统调用，它非常特殊，普通的函数，调用一次它执行一次，但是fork()函数调用一次执行两次，因为操作系统自动把当前进程(称为父进程)复制了一份(称为子进程)，然后，分别在子进程和父进程中执行，子进程永远返回0，而父进程返回子进程的ID，而子进程只要调用getpid()就可以拿到父进程的ID。Python中os模块封装了常见的系统调用，其中就包括fork(),可以在Python程序中轻松创建子程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Process (%s) start ...&#x27;</span> % os.getpid())</span><br><span class="line"><span class="comment">#Only work on Unix/linux/Mac</span></span><br><span class="line"><span class="comment">#不能在Windows平台上运行</span></span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I am child process (%) and my parent is %s.&#x27;</span> % (os.getpid(),os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;I (%) just created a child process (%).&#x27;</span> % (os.getpid(),pid))</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Process (<span class="number">876</span>) start...</span><br><span class="line">I (<span class="number">876</span>) just created a child process (<span class="number">877</span>).</span><br><span class="line">I am child process (<span class="number">877</span>) <span class="keyword">and</span> my parent <span class="keyword">is</span> <span class="number">876.</span></span><br></pre></td></tr></table></figure><p>由于windows平台下没有fork()函数调用，多以代码没有办法在windows平台下运行，有了fork调用，一个进程在接到任务的时候就可以复制出来一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出新的子进程来处理新的http请求。</p><p>multiprocessing(多进程)</p><p>如果你想写多进程的服务程序，Unix/LInix平台最好了，当然也可以在Windows平台下来编写，因为Python跨平台，multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块提供了一个Process类来代表一个进程对象，下面一个例子来演示启动一个进程并等待结束的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"> </span><br><span class="line"><span class="comment">#子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run child process %s (%s)&#x27;</span> % (name,os.getpid()))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;parent process %s&#x27;</span> % os.getpid())</span><br><span class="line">    p = Process(target=run_proc,args=(<span class="string">&#x27;test&#x27;</span>,))<span class="comment">#创建子程序</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child process will start&#x27;</span>)</span><br><span class="line">    p.start()<span class="comment">#子程序开始执行</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Child process end.&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>创建子程序时，只需要传入衣蛾执行的函数和函数的参数</p></li><li><p>创建一个Process实例，用start()方式开启，这样创建的进程比fork还简单</p></li><li><p>join()方法可以等join子进程执行完后再继续往下运行，通常用于进程之间的同步</p></li><li><p>如果想要启动大量的子进程，可以用进程池的方式批量创建子进程，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run task %s (%s)...&#x27;</span> % (name,os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task %s run %0.2f seconds.&#x27;</span> % (name,(end-start)))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task,args=(i,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for all subprocess done...&#x27;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;All subprocess done&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要让Python实现多进程(multiprocessing),我们先来了解下操作系统相关知识, Unix和Linux操作系统提供了一个fork()函数系统调用，它非常特殊，普通的函数，调用一次它执行一次，但是fork()函数调用一次执行两次，因为操作系统自动把当前进程(称为</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python之多线程</title>
    <link href="http://example.com/2021/12/30/Python%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/12/30/Python%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-12-30T07:35:30.000Z</published>
    <updated>2021-12-30T08:40:42.704Z</updated>
    
    <content type="html"><![CDATA[<p>多个任务可以由多进程完成，也可以由一个进程内的多线程完成。</p><p>一个进程由多个线程组成，一个进程至少有一个线程。</p><p>由于线程是操作系统直接支持的单元，因此，高级语言都内置多线程的支持，Python也不例外，并且Python的线程是真正Posix Thread，不是模拟出来的线程。</p><p>Python的标准库提供了两个模块:_thread和threading，<code>_thread</code>是低级模块，threading是高级模块。绝大多数的情况下，我们只用threading就够了。</p><p>启动一个线程就是把函数传入并创建Thread实例,然后调用start(),函数开始执行就可以了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"> </span><br><span class="line"><span class="comment">#线程执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s is running&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;thread %s &gt;&gt;&gt; %s&#x27;</span> % (threading.current_thread().name,n))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s end&#x27;</span> % threading.current_thread().name)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % threading.current_thread().name)</span><br><span class="line">t = threading.Thread(target=loop,name=<span class="string">&#x27;LoopTread&#x27;</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;thread %s end&#x27;</span> % threading.current_thread().name)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread <span class="keyword">is</span> running...</span><br><span class="line">thread LoopTread <span class="keyword">is</span> running</span><br><span class="line">thread LoopTread &gt;&gt;&gt; <span class="number">1</span></span><br><span class="line">thread LoopTread &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">thread LoopTread &gt;&gt;&gt; <span class="number">3</span></span><br><span class="line">thread LoopTread &gt;&gt;&gt; <span class="number">4</span></span><br><span class="line">thread LoopTread &gt;&gt;&gt; <span class="number">5</span></span><br><span class="line">thread LoopTread end</span><br><span class="line">thread MainThread end</span><br></pre></td></tr></table></figure><p>由于任何进程都会默认开启一个线程，我们把该线程称为主线程，主线程又可以开启新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例；主线程实例的名字叫Main Thread，子线程的名字在创建的时候指定，我们用LoopThread命名子线程,名字仅仅在打印的时候用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1,Thread-2</p><p><strong>Lock</strong></p><p>多进程和多线程最大的不同在于，多进程中，同一个变量，各自有一份拷贝到每个进程，互不影响，而线程中，所有变量都是所有线程共享所有，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险就在与多线程同时修改一个变量，把内容给改乱了，举个栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假定这是你的银行存款</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment">#先存后取</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance += n</span><br><span class="line">    balance -= n</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        change_it(n)</span><br><span class="line"> </span><br><span class="line">t1 = threading.Thread(target=run_thread,args=(<span class="number">5</span>,))</span><br><span class="line">t2 = threading.Thread(target=run_thread,args=(<span class="number">8</span>,))</span><br><span class="line"> </span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line"><span class="built_in">print</span>(balance)</span><br></pre></td></tr></table></figure><p>我们定义了一个共享变量balance，初始化为0，并且启动两个线程，先存后去，理论上结果应该为0，但是由于线程的调度是由操作系统决定的，当t1，t2交替执行时，只要循环次数足够多，balence的结果就不一定是0了，原因是因为高级语言的一条语句在cpu执行的时候是若干条语句，即使一个简单的计算:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance += n</span><br></pre></td></tr></table></figure><p>也要分成两步:</p><ul><li>计算balance + n结果存到临时变量中</li><li>将临时变量的值赋给balance</li></ul><p>究其原因，是因为修改balance需要多条语句，而执行这几条语句时，线程可能中断，从而导致多个线程把一个对象的内容改乱了。</p><p>两个线程同时一存一取，就可能导致余额不对，你肯定不希望你的银行存款莫名其妙地变成了负数，所以我们要确保balance计算正确，就要给change_it()上一把锁，当某个线程开始执行change_it()时，我们说，该线程因为获得了锁，因此其他线程不能同时执行change_it(),只能等待，直到锁被释放后，获得该锁以后才能改。由于锁只有一个，无论多少线程，同一时间最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过threading.Lock()来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment">#先要获取锁</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">#放心改吧</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment">#改完记得释放锁哦</span></span><br><span class="line">            lock.release()</span><br></pre></td></tr></table></figure><p>当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p><p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally…来确保锁一定会被释放。</p><ul><li>锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行</li><li>坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。</li><li>其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。</li></ul><p><strong>多核CPU</strong></p><p>如果你拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。</p><p>如果写一个死循环的话，会出现什么情况呢？</p><p>打开Mac OS X的Activity Monitor，或者Windows的TaskManager，都可以监控某个进程的CPU使用率，我们可以监控到一个死循环线程会100%占用一个CPU。如果有两个死循环线程，再多核CPU中，可以监控到会占用200%的CPU，就是占用两个CPU核心。如果想把N核CPU的核心全部跑满，就必须启动N个死循环线程，在Python中真的如此嘛?</p><p>试试用Python写个死循环:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, multiprocessing</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span>():</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = x ^ <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(multiprocessing.cpu_count()):</span><br><span class="line">    t = threading.Thread(target=loop)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核，但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p><p>因为Python的线程虽然是真正的 线程，但解释器在执行代码时，有一个GIL锁: Global Interpreter Lock,任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p><p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p><p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核，如果一定要通过多线程利用多核，那就只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p><p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自的独立的GIL锁，互不影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;多个任务可以由多进程完成，也可以由一个进程内的多线程完成。&lt;/p&gt;
&lt;p&gt;一个进程由多个线程组成，一个进程至少有一个线程。&lt;/p&gt;
&lt;p&gt;由于线程是操作系统直接支持的单元，因此，高级语言都内置多线程的支持，Python也不例外，并且Python的线程是真正Posix Thr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python图片灰度处理</title>
    <link href="http://example.com/2021/12/30/Python%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2021/12/30/Python%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86/</id>
    <published>2021-12-30T07:32:12.340Z</published>
    <updated>2021-12-30T07:31:57.414Z</updated>
    
    <content type="html"><![CDATA[<p>Python的PIL库为我们提供了一些操作图片的方法，我们可以用这些把图片处理成我们想要的样子，比如把图片变模糊，或者改变大小，还有就是今天我们要讲的把图片变成漫画或者说素描的风格:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.asarray(Image.<span class="built_in">open</span>(<span class="string">&#x27;1.jpg&#x27;</span>).convert(<span class="string">&#x27;L&#x27;</span>)).astype(<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line">depath = <span class="number">10</span> <span class="comment"># (0-100)</span></span><br><span class="line">grad = np.gradient(a)<span class="comment"># 取图像灰度的梯度值</span></span><br><span class="line">grad_x,grad_y = grad <span class="comment"># 分别取横纵图像梯度值</span></span><br><span class="line">grad_x = grad_x * depath / <span class="number">100.</span></span><br><span class="line">grad_y = grad_y * depath / <span class="number">100.</span></span><br><span class="line">A = np.sqrt(grad_x ** <span class="number">2</span> + grad_y ** <span class="number">2</span> + <span class="number">1.</span>)</span><br><span class="line">uni_x = grad_x / A</span><br><span class="line">uni_y = grad_y / A</span><br><span class="line">uni_z = <span class="number">1.</span> / A</span><br><span class="line"></span><br><span class="line">vec_el = np.pi / <span class="number">2.2</span> <span class="comment"># 光源的俯视角度，弧度值</span></span><br><span class="line">vec_az = np.pi / <span class="number">4</span> <span class="comment"># 光源的方位角度，弧度值</span></span><br><span class="line">dx = np.cos(vec_el) * np.cos(vec_az) <span class="comment"># 光源对 x 轴的影响</span></span><br><span class="line">dy = np.cos(vec_el) * np.sin(vec_az) <span class="comment"># 光源对 y 轴的影响</span></span><br><span class="line">dz = np.sin(vec_el) <span class="comment"># 光源对 z 轴的影响</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">255</span> * (dx * uni_x + dy * uni_y + dz * uni_z) <span class="comment"># 光源归一化</span></span><br><span class="line">b = b.clip(<span class="number">0</span>,<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">im = Image.fromarray(b.astype(<span class="string">&#x27;uint8&#x27;</span>)) <span class="comment"># 重构图像</span></span><br><span class="line">im.save(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python的PIL库为我们提供了一些操作图片的方法，我们可以用这些把图片处理成我们想要的样子，比如把图片变模糊，或者改变大小，还有就是今天我们要讲的把图片变成漫画或者说素描的风格:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python对象引用,可变性和垃圾回收机制</title>
    <link href="http://example.com/2021/12/30/Python%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8,%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/12/30/Python%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8,%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-12-30T06:56:30.000Z</published>
    <updated>2021-12-30T07:16:55.897Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://imgtu.com/i/TR3TCn"><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s4.ax1x.com/2021/12/30/TR3TCn.png"                      alt="TR3TCn.png"                ></a></p><ol><li><p>Python中的变量到底是什么</p><p>Python的变量实质上是一个指针:</p><ul><li><p>事先没有预定大小，可以是任意类型，比如int,str</p></li><li><p>可以理解成一个便利贴，可以贴在任何类型上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a = <span class="string">&#x27;tyu&#x27;</span></span><br></pre></td></tr></table></figure><p>可以理解成一个便利贴，a贴在1上</p><p>注意:</p><ul><li>是先生成对象，然后再贴</li><li>不需要声明类型</li></ul><p>看一个例子:</p><p>a = [1, 2, 3]</p><p>b = a</p><p>b.append(4)</p><p>print(a)</p><p>输出：[1, 2, 3, 4]</p><p>结论: a和b贴在了同一个地方</p><p>判断一下a和b是不是同一个对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：True</span></span><br></pre></td></tr></table></figure><p>再判断一下a和b是不是同一个内存地址:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a),<span class="built_in">id</span>(b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：8533576 8533576</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>==和is的区别</p><p><strong>is是判断两个变量引用对象id是否相等</strong></p><p><strong>==用于判断引用变量的值是否相等</strong></p><p>整数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123456789</span></span><br><span class="line">b = <span class="number">123456789</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：True True</span></span><br></pre></td></tr></table></figure><p>字符串:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;123456789&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;123456789&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：True True</span></span><br></pre></td></tr></table></figure><p>列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：False True</span></span><br></pre></td></tr></table></figure><p>字典:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;sixkery&#x27;</span>&#125;</span><br><span class="line">b = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;sixkery&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：False True</span></span><br></pre></td></tr></table></figure><p>集合:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：False True</span></span><br></pre></td></tr></table></figure><p>总结:<br>只要对象的值一样，那么a == b的值一定为True</p><p>如果对象的类型为整数或者字符串且值一样，则a == b和a is b的值都为True(负浮点数不符合)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = -<span class="number">1.0</span></span><br><span class="line">b = -<span class="number">1.0</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：False True</span></span><br></pre></td></tr></table></figure></li><li><p>del语句和垃圾回收</p><p>Python中垃圾回收算法是: 引用计数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment"># 1 的计数器上加一</span></span><br><span class="line">b = a <span class="comment"># 1 的计数器上再加一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> a <span class="comment"># 计数器减一</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">   File <span class="string">&quot;e:/python/test.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"> NameError: name <span class="string">&#x27;a&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p>当计数器加为0的时候，Python就会把1回收，不占用内存</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://imgtu.com/i/TR3TCn&quot;&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Scrapy添加User-agent的方法</title>
    <link href="http://example.com/2021/12/30/Scrapy%E6%B7%BB%E5%8A%A0User-agent%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2021/12/30/Scrapy%E6%B7%BB%E5%8A%A0User-agent%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2021-12-30T03:19:30.000Z</published>
    <updated>2021-12-30T03:19:56.160Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>直接在spider中指定，比如在Scrapy项目中有一个项目grasp_baidu:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">graspbaidu</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;graspbaidu&#x27;</span></span><br><span class="line">    allowed_domians = [<span class="string">&#x27;www.baidu.com&#x27;</span>]</span><br><span class="line">    start_urls = [<span class="string">&quot;http//:www.baidu.com&quot;</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        self.logger.debug(response.text)</span><br></pre></td></tr></table></figure><p>这里的start_urls会默认由scrapy自带的start_request处理，然后再交给parse函数，我们就可以重写个start_request，然后里面带个UA即可，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_request</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">    url = f<span class="string">f&#x27;https://api2.fx361.com/JunJiProject/JUNJI_012_001/getSearchList?bkpagesize=14&amp;pagesize=30&amp;keyword=%E7%9B%91%E7%90%86%E5%88%9B%E6%96%B0&amp;pageIndex=<span class="subst">&#123;i&#125;</span>&amp;fragmentSize=150&#x27;</span></span><br><span class="line">    req = scrapy.Request(url, callback=self.parse, dont_filter=<span class="literal">True</span>, headers=self.headers)</span><br></pre></td></tr></table></figure></li><li><p>在配置文件settings.py中设置(一劳永逸):</p><p>将settings.py中的USER_AGENT修改一下即可</p></li><li><p>如果想修改的更加灵活，比如设置随机的Ua，那就需要如下用到一个库:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br></pre></td></tr></table></figure><p>然后需要在middlewares.py文件中添加一个RandomUserAgentMiddleware的类，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomUserAgentMiddleware</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment"># 随机更换 user_agent</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,srawler</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(RandomUserAgentMiddleware,self).__init__()</span><br><span class="line">        self.ua = UserAgent()</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span>(<span class="params">cls,crawler</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls(crawler)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span>(<span class="params">self,request,spider</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_ua</span>():</span></span><br><span class="line">        request.headers.setdefault(<span class="string">&#x27;User-Agent&#x27;</span>,self.ua.random)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>然后后我们在settings.py中调用这个中间件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">    <span class="string">&#x27;scrapy.contrib.downloadermiddleware.useragent.UserAgentMiddleware&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">    <span class="string">&#x27;scrapydownloadertest.middlewares.RandomUserAgentMiddleware&#x27;</span>: <span class="number">543</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接在spider中指定，比如在Scrapy项目中有一个项目grasp_baidu:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode最大回文子串</title>
    <link href="http://example.com/2021/12/30/Leetcode%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://example.com/2021/12/30/Leetcode%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2021-12-30T02:43:20.000Z</published>
    <updated>2021-12-30T02:44:01.942Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划:</p><p>对于一个字串而言，如果它是回文串，并且长度大于2，那么将它首位的两个字母去掉之后，它仍然是个回文串，根据这个思路，我们就可以用动态规划的方法解决本题，我们用s[i, j]表示字符串s的第i个到第j个字母组成的串是否为回文串:</p><p>我们可以得到只有s[i+1, j-1]是回文串，并且s的第i个和第j个字母相同时，s[i, j]才会是回文串</p><p>上文所有讨论都是建立在字串长度大于2的前提上的，我们还需要考虑动态规划中的边界条件，就是字串的长度为1或2。对于长度为1的字串，他显然是个回文串，对于长度为2的字串，只要它的两个字母相同，他就是一个回文串，因此我们就可以得到动态规划的边界条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        <span class="comment"># dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            dp[i][i] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递推开始</span></span><br><span class="line">        <span class="comment"># 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> L <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                j = L + i - <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= n:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> s[i] != s[j]:</span><br><span class="line">                    dp[i][j] = <span class="literal">False</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt; <span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j - i + <span class="number">1</span> &gt; max_len:</span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line">                    begin = i</span><br><span class="line">        <span class="keyword">return</span> s[begin:begin + max_len]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;动态规划:&lt;/p&gt;
&lt;p&gt;对于一个字串而言，如果它是回文串，并且长度大于2，那么将它首位的两个字母去掉之后，它仍然是个回文串，根据这个思路，我们就可以用动态规划的方法解决本题，我们用s[i, j]表示字符串s的第i个到第j个字母组成的串是否为回文串:&lt;/p&gt;
&lt;p&gt;我们可以</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于入门Go需要知道的几个特性</title>
    <link href="http://example.com/2021/12/29/%E5%85%B3%E4%BA%8E%E5%85%A5%E9%97%A8Go%E7%9A%84%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://example.com/2021/12/29/%E5%85%B3%E4%BA%8E%E5%85%A5%E9%97%A8Go%E7%9A%84%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2021-12-29T10:01:33.781Z</published>
    <updated>2021-12-29T10:08:28.199Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>go的关键字比较少，只有25个，这样可以简化编码过程中的混乱和复杂度</p></li><li><p>go没有类和继承的概念，但它通过接口的概念来实现多态</p></li><li><p>go支持交叉编译，比如说可以在运行Linux系统的计算机开发能在windows上运行的应用，这是第一门完全支持UTF-8的编程语言，就连他的源码文件格式都是使用UTF-8编码</p></li><li><p>go被设计成一门应用与搭载web服务器，存储集群或类似用途的巨型中央服务器的系统编程语言，对于高性能分布式系统领域而言，go有着更高的开发效率，提供了海量并行的支持，这对于游戏服务端的开发最好不过了</p></li><li><p>尽管go编译器产生的是本地可执行代码，这些代码仍旧运行在go的runtime中，这个runtime类似java和.net所用到的虚拟机，它负责管理包括内存分配，垃圾回收，栈处理、goroutine、channel、切片，map和反射等</p></li><li><p>go fmt，这是个工具用来将你的源代码格式化成符合官方统一标准的风格</p></li><li><p>go doc，这是个工具从go程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档</p></li><li><p>go install, 这是go的包的安装工具，类似Ruby中的rubygems</p></li><li><p>go test是一个轻量级的单元测试框架</p></li><li><p>go fix用于将你的go代码从旧的发行版迁移到最新的发行版</p></li><li><p>cgo提供了对FFI(外部函数接口)的支持，能够使用go代码安全地调用c语言库，cgo会代替go编译器来产生可以组合在同一个包中的go和c代码</p></li><li><p>在go代码中使用c语言需要用<code>import&quot;C&quot;</code>来导入，一般还需要<code>import&quot;unsafe&quot;</code>,然后你可以在<code>import&quot;C&quot;</code>之前使用注释(但行或多行注释均可)的形势导入C语言库(甚至有效的C语言代码)，注意他们之间没有空格</p></li><li><p>左大括号需要放在函数定义这一行</p></li><li><p>fmt.Println和fmt.Print只差了一个空格</p><p>2021-12-29 18:08:20</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;go的关键字比较少，只有25个，这样可以简化编码过程中的混乱和复杂度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;go没有类和继承的概念，但它通过接口的概念来实现多态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;go支持交叉编译，比如说可以在运行Linux系统的计算机开发能在</summary>
      
    
    
    
    
  </entry>
  
</feed>
