<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-25T08:12:42.869Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Restuful API--未完待续</title>
    <link href="http://example.com/2022/04/25/%E5%85%B3%E4%BA%8ERestuful%20API/"/>
    <id>http://example.com/2022/04/25/%E5%85%B3%E4%BA%8ERestuful%20API/</id>
    <published>2022-04-25T15:52:30.000Z</published>
    <updated>2022-04-25T08:12:42.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h2><h3 id="课程目标"><a href="#课程目标" class="headerlink" title="课程目标"></a>课程目标</h3><ol><li>理解RESTful API的6个限制和若干最佳实践</li><li>掌握Koa2、Postman、MongoDB、JWT等技术</li><li>运用上述技术搭建仿知乎RESTful API</li><li>掌握阿里云现上部署方法</li></ol><h3 id="功能技术分析"><a href="#功能技术分析" class="headerlink" title="功能技术分析"></a>功能技术分析</h3><ol><li>RESTful API理论</li><li>Koa2</li><li>Postman</li><li>MongoDB</li><li>JWT</li><li>阿里云部署</li></ol><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol><li>Node.js基础</li><li>ES6、ES7基础</li></ol><h3 id="重难点分析"><a href="#重难点分析" class="headerlink" title="重难点分析"></a>重难点分析</h3><ol><li>RESTful API理论</li><li>JWT认证原理</li><li>复杂的数据库关系(一对多、多对多等)</li></ol><h3 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h3><ol><li>RESTful API理论</li><li>Koa2、MongoDB、Postman、JWT等技术</li><li>使用这些技术进行仿知乎后台接口的搭建</li><li>阿里云线上部署</li></ol><h3 id="课程建议"><a href="#课程建议" class="headerlink" title="课程建议"></a>课程建议</h3><ol><li>理论部分做到自问自答</li><li>实战部分做到举一反三</li><li>不至于本课程，学习更多技术</li></ol><h2 id="REST简介"><a href="#REST简介" class="headerlink" title="REST简介"></a>REST简介</h2><h3 id="REST是什么"><a href="#REST是什么" class="headerlink" title="REST是什么"></a>REST是什么</h3><p>REST是一个风格，是一个<strong>万维网软件架构风格</strong>，风格这个关键词是非常重要的，因为它告诉了我们REST并不是什么协议，也并不是什么硬性的规范，它仅仅是一种架构风格而已，那么这种风格是用来干什么的呢?</p><p>很显然它既然是万维网软件架构风格，那么它必然是用来架构万维网软件的，换句话来说，它就是<strong>用来创建网络服务</strong>的</p><h3 id="为何叫REST"><a href="#为何叫REST" class="headerlink" title="为何叫REST?"></a>为何叫REST?</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/07/kDMarHnjZ8WXKoJ.png"                      alt="image.png"                ></p><h3 id="依然不明白REST"><a href="#依然不明白REST" class="headerlink" title="依然不明白REST?"></a>依然不明白REST?</h3><p>到这还不明白没有关系，REST的字面意思其实很难表达它的精髓，所以仅仅通过字面解读是无法理解REST的，那么怎么办呢，我们可以通过REST的6个限制详细了解它，<strong>这6个限制是REST的精髓，是它的重中之重，在面试中会经常考到</strong></p><h4 id="来看看6个限制"><a href="#来看看6个限制" class="headerlink" title="来看看6个限制"></a>来看看6个限制</h4><h5 id="客户-服务器-Client-Server"><a href="#客户-服务器-Client-Server" class="headerlink" title="客户-服务器(Client-Server)"></a>客户-服务器(Client-Server)</h5><p>也叫CS架构，这个限制其实现在已经非常常见了，现在几乎没有什么不是CS架构的，所以它也是没有任何争议的，值得一提的是，这个限制的本质其实是一种软件架构思想叫做<strong>关注点分离</strong>，所谓关注点分离就是各扫门前雪，自己管好自己的事，在这里指的是<strong>服务端专注数据存储，提高了简单性，而前端专注用户界面，提高了可移植性</strong></p><p>这里用到了一些专有名词，简单性和可移植性，这来着REST作者的博士论文</p><p><strong>简单性</strong>其实就是<strong>让服务端的代码更简单</strong>，那么为什么更简单了呢，因为在过去，服务端还要渲染页面，还要数据存储，那么现在它就什么都不需要管了，它不用管用户界面这一块，只要写好数据存储的逻辑就行了，所以说就更简单了</p><p><strong>可移植性</strong>就是说一个软件<strong>能够很方便地移植到其它平台</strong>，为什么在这里说它更方便移植了呢，这是因为在过去我们的前端其实都是在操作系统里写的那些软件，那时候前端还需要管一些数据存储一些计算一些很复杂的东西，现在的前端就是在浏览器中，不用管一些复杂的计算过程，只需要调用接口，渲染用户界面即可</p><h5 id="无状态-Stateless"><a href="#无状态-Stateless" class="headerlink" title="无状态(Stateless)"></a>无状态(Stateless)</h5><ol><li><p>所有用户会话信息都保存在客户端</p></li><li><p>每次请求必须包括所有信息，不能依赖上下文信息</p><p>举个栗子吧:</p><p>比如说你在看一本小说，你看到某一页，你要进入小说的下一页，这时候你必须要把具体的页数告诉服务端，不能单纯地和服务端说我要进入下一页，因为服务端根本不知道你当前在第几页，你说下一页它根本就无法理解；所以就是说你这个<strong>请求必须要包括所有的信息，不能依赖你当前的上下文，这就是无状态</strong>，那么无状态有什么好处呢，那就是下面这一条:</p></li><li><p>服务端不用保存会话信息，提升了简单性、可靠性、可见性</p><p>简单性刚才已经说了，也就是服务端少了很多代码，那么什么是可靠性呢，<strong>可靠性指的是一个软件的稳定程度，以及它从一次故障中恢复正常的能力</strong>，那么为什么说提升了可靠性呢，因为如果服务端要管理用户会话信息的话，一旦服务端出现故障，用户会话信息就会完全丢失，想要恢复起来几乎是不可能；如果<strong>服务端不管理用户会话信息，那么从故障中恢复起来就会非常容易</strong>，那么可见性指的是什么呢，可见性指的就是在软件工程中那些模块啊，接口之间的透明程度，为什么说提升了可见性呢，因为<strong>每次请求都必须包括所有信息，所以说接口之间就更加透明，因为我了解你所有信息，很多信息你都是传给我了，而不是存在服务端，这就更加透明了，可见性更高</strong></p></li></ol><h5 id="缓存-Cache"><a href="#缓存-Cache" class="headerlink" title="缓存(Cache)"></a>缓存(Cache)</h5><ol><li><p>所有服务端响应都要被标为可缓存或不可缓存</p><p>那么哪些可缓存哪些不可缓存呢，举个栗子吧，比如前端的JS、CSS、静态文件啥的就可以缓存，请求一次就行了，不用请求第二次，因为它们之间变化的可能性不大；那么对于一些动态的接口也就是一些经常会变的接口，那就是不能缓存的，因为如果缓存了，如果更新了那还是会显示老样子，用户就会说，我明明已经更新了啊，为什么还是老样子；那么缓存有什么作用呢，那就是下面这一条:</p></li><li><p>减少前后端交互，提升了性能</p><p>就比如说，<strong>如果没有缓存，那么你的一些JS文件每次都需要从服务端加载，速度很慢，如果缓存在浏览器里面的话，那么页面瞬间就能被打开</strong>，用户感知到的性能就得到了提升</p></li></ol><h5 id="统一接口-Uniform-Interface"><a href="#统一接口-Uniform-Interface" class="headerlink" title="统一接口(Uniform Interface)"></a>统一接口(Uniform Interface)</h5><p>这个限制是<strong>所有限制中最重要的一个</strong>，别的限制，如果不是在REST里面，你也可以遵循，比如说CS架构，现在生活中几乎都是CS架构了，也不一定是REST风格，别的风格也可以用到缓存啥的；但是只有<strong>统一接口突出了REST的特点</strong>，那么统一接口是什么意思呢，我们要分开来看:</p><p>统一:</p><p>所谓统一就是接口设计尽可能统一通用，也就是说接口的设计要遵循同一个规范，所有的接口都像是学校的学生，穿上了校服一样</p><p>提升了简单性:</p><p>既然所有的接口都很相似，那么学习起来肯定就很轻松了，比如说你学会了用户接口，那么你学话题接口、评论接口都是同样的规范，学起来肯定简单了</p><p>提升了可见性:</p><p>所有接口都遵循同一套规范，所以它们之间就更加相似更加透明了</p><p>那么接口又有什么作用呢?</p><p>前后端可以使用接口来进行通信，前端只需要调用接口就可以了，不需要再实现具体的代码；就比如说在过去，我想实现一个PDF转WORLD的功能，我就必须要把这个代码写在前端，一些windows或者mac的软件上，但现在，我只需要调用接口就可以实现了，我的接口和实现是解耦的，这样一来前后端就可以独立开发和迭代，两者只需要遵循同一套接口规范即可，谁也不用依赖谁，谁也不用等谁；就比如说如果在你的团队里面前端说后端这个接口没写完，我根本就没法开发，你就可以告诉他 ，那要接口是干嘛的，接口就是让前后端可以独立开发迭代的，让你们之间是可以解耦的，如果后端没有把接口实现完，可以先让它先给前端一个假数据啊，只要遵循接口规范就可以了，这是接口的作用</p><h5 id="分层系统-Layered-System"><a href="#分层系统-Layered-System" class="headerlink" title="分层系统(Layered System)"></a>分层系统(Layered System)</h5><p>这个限制的意思是，软件架构是分很多层的，而且<strong>每一层只知道相邻一层，后面隐藏的就不知道了</strong>，比如说客户端不知道是和代理还是真实服务器通信，客户端只知道自己最相邻的一层也就是接口，在这里呢，代理就可以算分层系统中的一层，同学们了解代理是什么嘛，就比如你想翻墙去看国外的一些网站，或者说你在家里想连接公司的内网进行办公，这时候你都需要用到代理，看起来你好像访问的还是谷歌、Facebook、YouTube但是你已经从代理那一层绕了一圈了才到了真实的服务器，这个分层系统远不止代理这么简单，在阿里巴巴这个企业有一个部门叫中间件，这个部门号称是阿里做技术的最想去的一个部门或者说那些做技术的最想去的一个部门，因为他们不用关心业务逻辑，只需要做一些中间件，也就是这些分层系统中的层；那么他们具体都做了哪些层呢，比如说有安全层、负载均衡、缓存层等，所谓安全层就是可以提前终止掉不安全的请求，另外有一个特别著名的层叫做负载均衡，所谓负载均衡就是说，如果你的软件或者你的网站用户量特别大，就像双十一那样，有很多很多请求，那你就要用很多服务器，让它们去共同分担这些流量，负载均衡这一层就是用来管理这些流量分发的，比如说这台服务器吃紧了，顶不住了，要挂了，怎么办呢， 负载均衡这一层就是把流量转到下一台服务器上，这就是负载均衡这一层的作用；缓存层一般就是缓存一些静态文件，这个前面也提到过</p><h5 id="按需代码-Code-On-Demand-可选"><a href="#按需代码-Code-On-Demand-可选" class="headerlink" title="按需代码(Code-On_Demand 可选)"></a>按需代码(Code-On_Demand 可选)</h5><p>这个限制是可选的，它也不是很重要，但因为是6大限制之一，所以说我们为了完整性还是提到了它，所谓按需代码指的就是客户端可以下载运行服务端传来的代码(比如JS)，比如你可以服务端给你传一段JS字符串，然后你在浏览器里面执行一下，执行JS的方法是<code>eval</code>，那么这个按需代码有什么好处呢，它通过减少一些功能，简化了客户端，也就是说有些逻辑，前端不需要自己去写，交给服务端就好了，服务端给你传过来执行一下就行了，所以说简化了客户端</p><h4 id="统一接口的限制"><a href="#统一接口的限制" class="headerlink" title="统一接口的限制"></a>统一接口的限制</h4><p>在前面的内容中，我们讲到了REST的6个限制，其中有一个很重要的限制是统一接口的限制，里面讲到了在REST风格中，接口都要设计的尽可能得统一，那么问题来了，接口都被统一成什么样了，这一节我们就要回答这个问题，也就是统一接口的限制，其实在这里应该是属于子限制，因为之前已经有6个限制了，而这属于限制里面的限制，也就是统一接口限制里面的子限制，用大白话说呢，就是想让大家看下REST风格的接口应该设计成什么样</p><h5 id="资源的标识"><a href="#资源的标识" class="headerlink" title="资源的标识"></a>资源的标识</h5><ol><li><p>资源是任何可以命名的事物，比如用户、评论等</p><p>REST整个都是围绕资源展开的，不像其他的是围绕动词展开的，REST是围绕名词展开的</p></li><li><p>每个资源可以通过URI被唯一地标识</p><ul><li><a class="link"   href="https://api.github.com/users" >https://api.github.com/users<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://api.github.com/users/lewis617" >https://api.github.com/users/lewis617<i class="fas fa-external-link-alt"></i></a></li></ul></li></ol><h5 id="通过表述来操作资源"><a href="#通过表述来操作资源" class="headerlink" title="通过表述来操作资源"></a>通过表述来操作资源</h5><ol><li><p>表述就是Representation，比如JSON、XML等</p><p>上面这句话可以反过来理解，也就成了下面这句:</p></li><li><p>客户端不能直接操作(比如MySQL)服务器资源</p></li><li><p>客户端只能通过表述(比如JSON)来操作资源</p><p>我们可以以GitHub为例来看看通过表述来操作资源，这是我找的一个网站: <a class="link"   href="http://docs2.lfe.io/v3/#http-verbs" >http://docs2.lfe.io/v3/#http-verbs<i class="fas fa-external-link-alt"></i></a></p></li></ol><h5 id="自描述消息"><a href="#自描述消息" class="headerlink" title="自描述消息"></a>自描述消息</h5><p>每个消息(请求或响应)必须提供足够的信息让接受者理解</p><p>那么这个消息具体又指什么呢，大概有如下几种:</p><p>媒体类型，也就是content-type(application/json、application/xml)</p><p>HTTP 方法: GET(查)、POST(增)、DELETE(删)</p><p>是否缓存: Cache-Control</p><p>我们同样可以以这个网站来看看: <a class="link"   href="http://docs2.lfe.io/v3/#http-verbs" >http://docs2.lfe.io/v3/#http-verbs<i class="fas fa-external-link-alt"></i></a></p><h5 id="超媒体作为应用状态引擎"><a href="#超媒体作为应用状态引擎" class="headerlink" title="超媒体作为应用状态引擎"></a>超媒体作为应用状态引擎</h5><p>超媒体就是带文字的链接，应用状态指的是一个网页，引擎指的是驱动、跳转，那么合起来就是点击链接跳转到另一个网页，就是这个API点击后会跳转</p><h2 id="RESTful-API简介"><a href="#RESTful-API简介" class="headerlink" title="RESTful API简介"></a>RESTful API简介</h2><h3 id="什么是RESTful-API"><a href="#什么是RESTful-API" class="headerlink" title="什么是RESTful API?"></a>什么是RESTful API?</h3><p>符合REST架构风格的API，API指的是应用编程接口</p><h3 id="RESTful-API具体什么样子"><a href="#RESTful-API具体什么样子" class="headerlink" title="RESTful API具体什么样子"></a>RESTful API具体什么样子</h3><p>主要以以下三方面组成:</p><ol><li>基本的URI，如: <a class="link"   href="https://api.github.com/users" >https://api.github.com/users<i class="fas fa-external-link-alt"></i></a></li><li>标准的HTTP方法，如GET、POST、PUT、PATCH、DELETE</li><li>传输的数据媒体类型，如: JSON，XML</li></ol><h3 id="现实举例"><a href="#现实举例" class="headerlink" title="现实举例"></a>现实举例</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/07/gNxH2pRW6BTJl8y.png"                      alt="image.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/07/RwaqdKhJo9k2NPl.png"                      alt="image.png"                ></p><p>PATCH是部分更新，PUT是整体更新</p><h2 id="RESTful-API设计最佳实践"><a href="#RESTful-API设计最佳实践" class="headerlink" title="RESTful API设计最佳实践"></a>RESTful API设计最佳实践</h2><h3 id="请求设计规范"><a href="#请求设计规范" class="headerlink" title="请求设计规范"></a>请求设计规范</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/07/SA7gKdOBNLv36pq.png"                      alt="image.png"                ></p><h3 id="响应设计规范"><a href="#响应设计规范" class="headerlink" title="响应设计规范"></a>响应设计规范</h3><p>应该来说会有以下这几个大点:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/07/CVZ52Fgyvt1uk8A.png"                      alt="image.png"                ></p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>使用HTTPS: 现在几乎所有的网站都开始往HTTPS发展了，因为HTTP是容易被篡改的</p><p>使用鉴权: 也就是需要先登录,保证用户的数据安全</p><p>使用限流: 是为了防止那些想故意攻击你网站的，他们会不停地调用接口，让你的服务器撑不下去，最后挂掉；为了防止这类人，我们可以在接口中加一些限流的措施，比如在分层系统里面专门加一个限流的层</p><p>同样参见这个网站: <a class="link"   href="http://docs2.lfe.io/v3/#http-verbs" >http://docs2.lfe.io/v3/#http-verbs<i class="fas fa-external-link-alt"></i></a></p><h3 id="开发者友好"><a href="#开发者友好" class="headerlink" title="开发者友好"></a>开发者友好</h3><ul><li><p>文档</p><p>共享出一份文档</p></li><li><p>超媒体(这个前面提到过)</p></li></ul><h2 id="Koa简介"><a href="#Koa简介" class="headerlink" title="Koa简介"></a>Koa简介</h2><h3 id="一句话简介"><a href="#一句话简介" class="headerlink" title="一句话简介"></a>一句话简介</h3><p>老外的产品就喜欢搞个一句话简介</p><ul><li><p>基于Node.js的下一代Web框架</p><p>基于Node.js这说明Koa基于Node.js模块，下一代表示正蚕食第一代Web框架Express的市场，因为Koa更好用，Koa是一个Web框架，不是我们所熟知的用JS写的命令行工具或算法</p></li></ul><h3 id="官网简介"><a href="#官网简介" class="headerlink" title="官网简介"></a>官网简介</h3><p>链接直达: <a class="link"   href="https://koa.bootcss.com/" >https://koa.bootcss.com/<i class="fas fa-external-link-alt"></i></a></p><p>总结:</p><ul><li>由Express幕后原班人马打造</li><li>Web应用和API开发领域</li><li>更小、更富有表现、更健壮</li><li>利用async函数，丢弃回调函数</li></ul><p>为什么要使用async函数，之前都是使用回调函数的，因为在JavaScript里面，如果多个异步串在一起就会出现回调地狱，写出来的代码非常丑，可读性非常差，自从有了async语法之后，写这种异步的逻辑看起来就和同步一样，非常的简洁，可读性大大提高</p><ul><li>增强错误处理: try…catch…</li></ul><p>也正是使用了async函数，使得代码就和同步一样，我们就可以用try…catch…进行一个错误处理</p><ul><li>没有捆绑任何中间件</li></ul><p>也就是说，你使用koa本身其实几乎什么都做不了，无法实现路由，甚至都无法实现一个静态服务器，但是不用担心，Koa社区里面有大量的中间件，利用这些中间件我们可以做几乎所有的事情；那么问题来了，没有捆绑任何中间件是不是很不方便啊，我们每次使用中间件还要再次安装啊，我的回答是，没错，但这样也有很多好处，就像买东西一样，我们非常不喜欢商家捆绑销售一些东西，这样的话我们就可以根据自己的实际需求来选择我们需要的商品，而不是被强迫购买一些商品；koa在这里的意图也是这样的，它并不想捆绑一些内置中间件，它希望开发者能够按照他自己的意愿使用他需要的中间件</p><ul><li><p>快速而愉快地编写程序</p><p>这是画的一个大饼哈哈哈哈</p></li></ul><h2 id="安装Koa并搭建首个Koa程序"><a href="#安装Koa并搭建首个Koa程序" class="headerlink" title="安装Koa并搭建首个Koa程序"></a>安装Koa并搭建首个Koa程序</h2><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>在windows电脑上推荐使用Git-bash这个命令行工具来初始化项目，因为在这里面我们可以使用上Linux相关命令</p><p>我就在我的Python_LHJ中创建一个项目文件夹为zhihu-api，使用如下命令:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir zhihu-api</span><br></pre></td></tr></table></figure><p>如果这个时候你想切换到vscode来写代码，就可以使用命令<code>code zhihu-api</code>来切换到vscode中来</p><p>然后我们需要进入到该项目文件夹并初始化该项目，使用如下命令:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>这个命令主要就是创建了一个<code>package.json</code>，这里面保存了项目的名称、描述、作者、依赖啊什么的，它最重要的功能其实是帮我们管理依赖，我们来看看它的用法:</p><p>你输入这个命令后，它会以对话的形式来问你你想要输入哪些东西，第一个问题是包名，默认是和项目名一样的，这个通常保持默认即可，然后会要求我们输入描述，下面的我们都可保持默认，直接按回车即可:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/07/QrNgVIxyJ4pStwc.png"                      alt="image.png"                ></p><p>我们来看看package.json长啥样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhihu-api&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;仿知乎RESTful API&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是它最重要的作用还是管理依赖，那么怎么管理依赖呢，我们就通过</p><h3 id="安装Koa"><a href="#安装Koa" class="headerlink" title="安装Koa"></a>安装Koa</h3><p>安装Koa来看看它怎么管理依赖，使用以下命令安装:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i koa --save</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa --save</span><br></pre></td></tr></table></figure><p><code>--save</code>参数表示将会保存到<code>package.json</code>中，那么保存到里面有什么好处呢，别人拿到你的项目的话就不用再执行<code>npm i koa</code>了，他只需要简单地在目录下执行<code>npm i</code>就行了，为什么呢，因为刚刚的<code>--save</code>已经把<code>koa</code>的安装信息已经保存到了<code>package.json</code>里面了，所以说你执行<code>npm i</code>的时候就会自动安装这个<code>koa</code>了</p><h3 id="编写Hello-World"><a href="#编写Hello-World" class="headerlink" title="编写Hello World"></a>编写Hello World</h3><p>安装完了<code>koa</code>我们如何使用它呢，使用<code>koa</code>非常简单，我们先新建一个<code>index.js</code>文件，这个文件的名称是可以随便写的，新建完这个<code>index.js</code>后，我们先引用<code>koa</code>，那我们直上代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)  <span class="comment">// 引入koa模块，const后面的变量名一般以大写字母开头，因为它可以看成是一个类，类就是首字母大写</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()  <span class="comment">// 实例化一个对象，app是应用程序(application)的简写，我们待会儿想搭建的应用程序都在这个app里面</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;  <span class="comment">// use方法里面可以传递一个函数，这个函数就是我们所说的中间件</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;hello world!&#x27;</span>  <span class="comment">// 在中间件里面，我们就可以返回返回值了，在这里这个函数接受一个参数叫ctx，它是Context上下文的缩写，我们只需要给这个参数的.body属性赋值就可以</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);  <span class="comment">// 指定应用的监听端口</span></span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/07/mn6fKXYADey2ti3.png"                      alt="image.png"                ></p><p>如上图所示，我们在运行后控制台是没有任何提示信息的，这个状态就是已经运行起来了，然后我们每次修改代码之后，都要重启服务才能在浏览器看到更改的效果，时间长了次数多了未免会有点繁琐，然后我们可以安装一个小工具，第一次使用这个工具运行了项目之后，后面如果代码又改动这个小工具就会帮我们自动重启，而不用手动了</p><h3 id="学习自动重启"><a href="#学习自动重启" class="headerlink" title="学习自动重启"></a>学习自动重启</h3><p>安装命令为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nodemon --save-dev</span><br></pre></td></tr></table></figure><p>这里要注意这个参数<code>--save-dev</code>，<code>--save</code>表示把这个模块加入<code>package.json</code>，后面如果有人使用该项目直接<code>npm i</code>即可完成此项目所有模块的安装，<code>-dev</code>表示它只在开发阶段使用，如果部署到服务器上，是不需要重启的</p><p>之前我们运行项目是<code>node index.js</code>，那么在安装完<code>nodemon</code>后，把<code>node</code>改为<code>nodemon</code>即可</p><p>但是当我们使用<code>nodemon index.js</code>时可能会报一个错:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;nodemon&#x27;不是内部或外部命令，也不是可运行的程序或批处理文件</span><br></pre></td></tr></table></figure><p>这是为什么呢</p><p>因为我们把<code>nodemon</code>安装到了<code>node_modules</code>里面，所以我们直接访问不到，我们要使用可能要先在<code>package.json</code>里面写脚本，但是如果我们全局安装了，也就是使用了<code>npm i nodemon -g</code>这个命令安装，就可以直接使用了</p><p>我们可以在<code>package.json</code>中的<code>scripts</code>字典中新增一个<code>start</code>命令:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;nodemon index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们使用命令<code>npm start</code>就可以启动项目了，<code>start</code>命令实际上就是指代了<code>nodemon index.js</code>命令</p><h2 id="Koa中间件与洋葱模型"><a href="#Koa中间件与洋葱模型" class="headerlink" title="Koa中间件与洋葱模型"></a>Koa中间件与洋葱模型</h2><p>本节以操作为主</p><h3 id="学习async-await"><a href="#学习async-await" class="headerlink" title="学习async await"></a>学习async await</h3><p>async await语法已经成了JavaScript的标准，所以说不管是在node.js还是在chrome的console面板，都可以直接使用这种语法</p><p>我们看看传统的实现，我们对比着来看看:</p><p>我们写的逻辑如下:</p><p>首先请求下github的用户列表接口，这是个异步，请求完之后，我们再请求下github的特定用户的列表接口，并把两次请求接口的结果都打印出来:</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统实现</span></span><br><span class="line">fetch(<span class="string">&#x27;//api.github.com/users&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).then(<span class="function"><span class="params">json</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(json)</span><br><span class="line">    fetch(<span class="string">&#x27;//api.github.com/storm999&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json()).then(<span class="function"><span class="params">json2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(json2)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到这里我们使用了一个嵌套，第一个json打印完毕之后就打印第二个了，但是我们会发现代码是比较丑的，这里只是请求了两个接口，如果是上十上百个就要一直嵌套了，上面代码运行结果如下: </p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/07/WtnuLfTNeA8ka9g.png"                      alt="image.png"                ></p><p>那么接下来我们就来看看如何使用async await语法来优化下上面的逻辑，首先，如果你要使用await的话，那么你必须在async的函数里面，直接上代码叭，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">&#x27;//api.github.com/users&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> res.json();  <span class="comment">// 转成json依然是一个异步操作，所以需要加关键字await</span></span><br><span class="line">    <span class="built_in">console</span>.log(json)  <span class="comment">// 打印用户列表接口</span></span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> fetch(<span class="string">&#x27;//api.github.com/users/storm666&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> json2 = <span class="keyword">await</span> res2.json();  <span class="comment">// 转成json依然是一个异步操作，所以需要加关键字await</span></span><br><span class="line">    <span class="built_in">console</span>.log(json2 )  <span class="comment">// 打印特定用户接口</span></span><br><span class="line">&#125;)()  <span class="comment">// 这是一个立即执行函数</span></span><br></pre></td></tr></table></figure><p>在async await里面就不用在then里面写回调函数了，相比来说比较方便</p><p>我们可以明显感觉到用来异步之后的逻辑就会同步一样清晰明了，这就是async await的用法，这里只是用了async await一个典型的例子</p><h3 id="学习编写Koa中间件"><a href="#学习编写Koa中间件" class="headerlink" title="学习编写Koa中间件"></a>学习编写Koa中间件</h3><p>在编写Hello World一节里面我们就写了一个中间件，现在我们要学习写多个中间件，我们在写了下一个中间件后，发现这个中间件什么都没有打印；其实在koa里面，如果你想执行下一个中间件，那你必须要申明它，在ctx后面加个参数叫next，next就是下一个，next()也是一个异步的函数(返回了一个promise)，所以这里要使用async await关键字，如下图所示:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/JLWabkCVwmeZDYt.png"                      alt="image.png"                ></p><p>很明显可以知道是先打印2然后打印1，为了排除图标请求的干扰，我们可以使用fetch方法来看看结果:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/vhtZEx5TmFVz8pI.png"                      alt="image.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/3sCFS2DOQJrwyUu.png"                      alt="image.png"                ></p><p>这就是写多个中间件的执行顺序，这个中间件的执行顺序就像洋葱一样:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/WFuo36d4CSpsQNP.png"                      alt="image.png"                ></p><h2 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h2><h3 id="路由是什么"><a href="#路由是什么" class="headerlink" title="路由是什么"></a>路由是什么</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/eJAhQG5Dnaxu2Is.png"                      alt="image.png"                ></p><h3 id="为什么要用路由"><a href="#为什么要用路由" class="headerlink" title="为什么要用路由"></a>为什么要用路由</h3><p>路由指向了不同资源，以此来进行区分</p><h3 id="路由存在的意义"><a href="#路由存在的意义" class="headerlink" title="路由存在的意义"></a>路由存在的意义</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/ISkVKYOTXPCp6zH.png"                      alt="image.png"                ></p><h2 id="自己编写Koa路由中间件"><a href="#自己编写Koa路由中间件" class="headerlink" title="自己编写Koa路由中间件"></a>自己编写Koa路由中间件</h2><p>主要用于实现:</p><p>处理不同的URL，处理不同的HTTP方法，解析URL上的参数</p><p>路由为<code>/users</code>就返回这是用户列表页，路由为<code>/</code>就返回这是主页，两个都不匹配的话就返回404，代码如下:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/EmPgZBqk1OKCWYI.png"                      alt="image.png"                ></p><p>上面是一个较为简单的功能，下面我们在深入一点，像前面提到的那样，处理不同的HTTP方法，就是GET和POST方法作为区分，那我们就这么设计吧，getusers就返回用户列表页，如果是postusers就返回创建用户，两个都不匹配的话就是方法不允许，也就是返回405，代码如下:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/HQNgmD5osA1Ebwn.png"                      alt="image.png"                ></p><p>最后我们来看看如何解析URL上的参数，比如用户请求了一个users/userid，然后返回这是用户，然后加上id，代码如下:</p><p>这里是用的正则表达式，用的是JavaScript原生的match方法</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/njxod5HMhKzX6ul.png"                      alt="image.png"                ></p><h2 id="使用Koa-router实现路由"><a href="#使用Koa-router实现路由" class="headerlink" title="使用Koa-router实现路由"></a>使用Koa-router实现路由</h2><p>本节要点:</p><ul><li>更优雅地实现路由基本功能</li><li>演示一些高级路由功能，如前缀、多中间件</li></ul><p>要使用Koa-router首先我们需要先安装下它，使用如下命令安装:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i koa-router --save</span><br></pre></td></tr></table></figure><p>接下来就是使用了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);  <span class="comment">// 引入&#x27;koa-router</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();  <span class="comment">// 实例化</span></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;  <span class="comment">// 写一个路由</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;这是主页&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/users&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;这是用户列表&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">&#x27;/users&#x27;</span>, (ctx)) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;创建用户&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/users/:id&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;这是用户&#x27;</span> $&#123;ctx.params.id&#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routers());  <span class="comment">// 需要把router注册到app里面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>上面我们通过代码更优雅地实现了路由的基本功能，现在我们来演示一些高级功能，比如前缀和高级中间件:<br>如果有了前缀的话，我们就不用每个路由都写个users了</p><p>首先我们需要再实例化一个新的router，这里就叫usersRouter吧，然后在里面配置一个参数prefix，也就是前缀，然后用usersRouter把下面的router替换掉，那就可以省略之前每个路由中的users了，如下代码所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);  <span class="comment">// 引入&#x27;koa-router</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();  <span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">const</span> usresRouter = <span class="keyword">new</span> Router(&#123; <span class="attr">prefix</span>: <span class="string">&#x27;users/&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;  <span class="comment">// 写一个路由</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;这是主页&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">usersRouter.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;这是用户列表&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">usersRouter.post(<span class="string">&#x27;/&#x27;</span>, (ctx)) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;创建用户&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">usersRouter.get(<span class="string">&#x27;/:id&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;这是用户&#x27;</span> $&#123;ctx.params.id&#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routers());  <span class="comment">// 需要把router注册到app里面</span></span><br><span class="line">app.use(usresRouter.routers())  <span class="comment">// 同样的注册下usresRouter</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>那么前缀的好处第一个就是能大大简洁我们路由中路径的编写，使得路由能灵活变换，使用前缀能帮我们节约一些代码</p><p>接下来我们要实现一个多中间件的功能，多中间件通常用于用户校验或者是用户安全，下面我们伪造一个用户安全，用来说明多中间件，代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);  <span class="comment">// 引入&#x27;koa-router</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();  <span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">const</span> usresRouter = <span class="keyword">new</span> Router(&#123; <span class="attr">prefix</span>: <span class="string">&#x27;users/&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个中间件</span></span><br><span class="line"><span class="keyword">const</span> auth = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.url !== <span class="string">&#x27;/users&#x27;</span>)&#123;</span><br><span class="line">        ctx.throw(<span class="number">401</span>);  <span class="comment">// 显示报错信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, auth, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;  <span class="comment">// 写一个路由</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;这是主页&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">usersRouter.get(<span class="string">&#x27;/&#x27;</span>, auth, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;这是用户列表&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">usersRouter.post(<span class="string">&#x27;/&#x27;</span>, auth, (ctx)) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;创建用户&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">usersRouter.get(<span class="string">&#x27;/:id&#x27;</span>, auth, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;这是用户&#x27;</span> $&#123;ctx.params.id&#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routers());  <span class="comment">// 需要把router注册到app里面</span></span><br><span class="line">app.use(usresRouter.routers())  <span class="comment">// 同样的注册下usresRouter</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="HTTP-options方法的作用是什么"><a href="#HTTP-options方法的作用是什么" class="headerlink" title="HTTP options方法的作用是什么?"></a>HTTP options方法的作用是什么?</h2><p>为什么要了解options方法的作用？首先这是一道面试题，很多面试官都喜欢通过这个来考察面试者对HTTP理解的深度以及对跨域理解的深度；其次就是它也可以帮助理解koa-router的allowedMethods的作用</p><p>下面我们言归正传，那么HTTP options方法的作用是什么呢？</p><p>第一它可以检测服务器所支持的请求方法，比如说我们之前实现的users这个接口，它支持get和post方法，并没有写其他方法，那么用户想知道users这个接口都支持哪些方法的话就可以使用options这个方法，比如:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/FVKZiXWr8JjbQpn.png"                      alt="image.png"                ></p><p>第二呢，它可以在CORS里面进行预检请求，CORS是用作跨域的一个技术，但是这个技术可能只支持一个网站的其中的其中一部分的接口的其中一部分方法来跨域，那么如何知道这个方法是否可以跨域呢，在这里也可以使用options方法来提前检测下，如果允许跨域了，再发出真实的请求。</p><p>讲了options方法我们就可以顺水推舟来讲讲allowedMethod是的作用，这个方法的第一个作用就是用来响应options方法的，告诉它所支持的请求方法，当用户使用options方法请求某个接口，那么就会自动返回这个接口所支持的方法。</p><p>就以我们上面实现的users路由为例，本来是不支持options方法的的，我们如果直接使用options请求就会报错，我们可以加上<code>app.use(usersRouter.allowedMethods());</code>，再次请求就能返回此接口所支持的所有方法了，代码如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);  <span class="comment">// 引入&#x27;koa-router</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();  <span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">const</span> usresRouter = <span class="keyword">new</span> Router(&#123; <span class="attr">prefix</span>: <span class="string">&#x27;users/&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个中间件</span></span><br><span class="line"><span class="keyword">const</span> auth = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.url !== <span class="string">&#x27;/users&#x27;</span>)&#123;</span><br><span class="line">        ctx.throw(<span class="number">401</span>);  <span class="comment">// 显示报错信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, auth, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;  <span class="comment">// 写一个路由</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;这是主页&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">usersRouter.get(<span class="string">&#x27;/&#x27;</span>, auth, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;这是用户列表&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">usersRouter.post(<span class="string">&#x27;/&#x27;</span>, auth, (ctx)) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;创建用户&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">usersRouter.get(<span class="string">&#x27;/:id&#x27;</span>, auth, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;这是用户&#x27;</span> $&#123;ctx.params.id&#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routers());  <span class="comment">// 需要把router注册到app里面</span></span><br><span class="line">app.use(usresRouter.routers())  <span class="comment">// 同样的注册下usresRouter</span></span><br><span class="line">app.use(usersRouter.allowedMethods());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>allowedMethod的第二个作用就是它能相应的返回405和501</p><p>刚刚我们配置了allowedMethod，如果用options方法请求接口的话就会返回这个接口所支持的所有方法是get、post和head，但如果我用put来请求呢，这个时候接口就会自动返回405，405就代表这个请求方法不支持；如果用一些比较偏僻的请求方法去请求这个接口，就会返回501，这是因为Koa只支持一些主流的请求 方法，</p><h2 id="RESTful-API最佳实践–增删改查应该返回什么响应？"><a href="#RESTful-API最佳实践–增删改查应该返回什么响应？" class="headerlink" title="RESTful API最佳实践–增删改查应该返回什么响应？"></a>RESTful API最佳实践–增删改查应该返回什么响应？</h2><p>我们在前面的内容中实现了一些简单的路由，这部分内容我们要用路由实现一个完整的增删改查，并在增删改查的每一个接口中返回最适合它的一个响应；其实对查这个操作来说还是比较容易理解的，查列表那就返回一个数组，查单个信息就返回数组中某一项，这个很简单，那么增删改应该返回什么响应呢？在RESTful API最佳实践中，我们约定，增加和修改应该返回当前增加和修改的数据，通常就是一个对象，如果是删除的话因该返回一个204状态码，这个状态码代表没有内容，但是成功了。以上所说的只是RESTful API最佳实践，如果你非要返回其他内容，也是可以的，如果你不这么写就会显得另类和奇怪。</p><p>这部分内容我们实现一个增删改查，然后返回正确的响应，下面来看看代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);  <span class="comment">// 引入&#x27;koa-router</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();  <span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">const</span> usresRouter = <span class="keyword">new</span> Router(&#123; <span class="attr">prefix</span>: <span class="string">&#x27;users/&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个中间件</span></span><br><span class="line"><span class="keyword">const</span> auth = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.url !== <span class="string">&#x27;/users&#x27;</span>)&#123;</span><br><span class="line">        ctx.throw(<span class="number">401</span>);  <span class="comment">// 显示报错信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;  <span class="comment">// 写一个路由</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;这是主页&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">usersRouter.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;这是用户列表&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">usersRouter.post(<span class="string">&#x27;/&#x27;</span>, (ctx)) =&gt; &#123;  <span class="comment">// 返回当前增加和修改的对象</span></span><br><span class="line">    ctx.body = &#123; <span class="attr">name</span>: <span class="string">&#x27;li&#x27;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">usersRouter.get(<span class="string">&#x27;/:id&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = [&#123; <span class="attr">name</span>: <span class="string">&#x27;li&#x27;</span>&#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;hou&#x27;</span> &#125;];</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">usersRouter.put(<span class="string">&#x27;/:id&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;这是用户&#x27;</span> $&#123;ctx.params.id&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">usersRouter.delete(<span class="string">&#x27;/:id&#x27;</span>, <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.status = <span class="number">204</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(router.routers());  <span class="comment">// 需要把router注册到app里面</span></span><br><span class="line">app.use(usresRouter.routers())  <span class="comment">// 同样的注册下usresRouter</span></span><br><span class="line">app.use(usersRouter.allowedMethods());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="控制器简介"><a href="#控制器简介" class="headerlink" title="控制器简介"></a>控制器简介</h2><p>控制器就是拿到路由分配的任务，并执行，其实在前面部分的内容中，注册在路由中的那个中间件就是个控制器，所以在Koa中控制器也是一个中间件，那么我们为什么要用控制器呢，控制器主要分为三个方面:</p><ul><li>可以用来获取HTTP请求参数</li><li>然后它可以处理一些业务逻辑</li><li>它会根据不同情况发送不同的HTTP响应</li></ul><p>HTTP请求参数主要有两方面:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/YXRjpk5ZLxDME9O.png"                      alt="image.png"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;课程简介&quot;&gt;&lt;a href=&quot;#课程简介&quot; class=&quot;headerlink&quot; title=&quot;课程简介&quot;&gt;&lt;/a&gt;课程简介&lt;/h2&gt;&lt;h3 id=&quot;课程目标&quot;&gt;&lt;a href=&quot;#课程目标&quot; class=&quot;headerlink&quot; title=&quot;课程目标&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo在Git上传时报ssh connect to host github.com port 22 Connection timed out</title>
    <link href="http://example.com/2022/04/25/hexo%E5%9C%A8Git%E4%B8%8A%E4%BC%A0%E6%97%B6%E6%8A%A5ssh%20connect%20to%20host%20github.com%20port%2022%20Connection%20timed%20out/"/>
    <id>http://example.com/2022/04/25/hexo%E5%9C%A8Git%E4%B8%8A%E4%BC%A0%E6%97%B6%E6%8A%A5ssh%20connect%20to%20host%20github.com%20port%2022%20Connection%20timed%20out/</id>
    <published>2022-04-25T06:22:30.000Z</published>
    <updated>2022-04-25T06:25:52.298Z</updated>
    
    <content type="html"><![CDATA[<p>今天在hexo上传时报了如下错误:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/25/eLT6D82btQrOizv.png"                      alt="image.png"                ></p><p>解决方案如下:</p><p>转载自csdn: <a class="link"   href="https://blog.csdn.net/hdm314/article/details/119947761" >https://blog.csdn.net/hdm314/article/details/119947761<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天在hexo上传时报了如下错误:&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-sr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Nginx最新易懂教程--哔哩哔哩狂神说</title>
    <link href="http://example.com/2022/04/24/Nginx%E6%9C%80%E6%96%B0%E6%98%93%E6%87%82%E6%95%99%E7%A8%8B--%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E7%8B%82%E7%A5%9E%E8%AF%B4/"/>
    <id>http://example.com/2022/04/24/Nginx%E6%9C%80%E6%96%B0%E6%98%93%E6%87%82%E6%95%99%E7%A8%8B--%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E7%8B%82%E7%A5%9E%E8%AF%B4/</id>
    <published>2022-04-24T06:21:30.000Z</published>
    <updated>2022-04-24T09:02:32.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx简介"><a href="#Nginx简介" class="headerlink" title="Nginx简介"></a>Nginx简介</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/AzQuhOs5va2tXZW.png"                      alt="image.png"                ></p><p>同时提供Web服务和邮件服务，其特定是占用内存少(大概1M)，并发能力也好，支撑5万个并发连接数的响应，tomcat一般才五六百个，如果网站不是特别大，一个Nginx就够用了。</p><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><p>Nginx第一个最核心的功能就是反向代理，在了解反向代理之前我们先来看看正向代理</p><p><strong>正向代理是代理客户端的</strong>，比方说你在你本机上装的VPN软件，这个VPN软件就是代理你的本机，通过VPN这个代理，才能去请求外网:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/3CmGs7ultvp8XTy.png"                      alt="image.png"                ></p><p><strong>反向代理是代理服务器端的</strong>，让你无感知地去浏览服务器资源，我后面无论动态扩容增加多少台服务器你访问的永远是我们的域名；就拿百度来说，百度肯定不止这一台服务器，这就是使用了反向代理，让我们无论访问哪一台服务器比如访问深圳的服务器或者广州的服务器，都能通过<code>www.baidu.com</code>来获取资源。</p><h2 id="负载均衡理解"><a href="#负载均衡理解" class="headerlink" title="负载均衡理解"></a>负载均衡理解</h2><p>比如我们有三个服务器，一个是64G的，一个是16G的，一个是8G的我们希望更多的请求打到64G的服务器上，更少的请求打到8G的服务器上，这个时候就要使用上负载均衡了，Nginx具有一些内置的策略:</p><p>Nginx提供的负载均衡策略有两种: 内置策略和扩展策略。内置策略为轮询、加权轮询和ip hash。扩展策略，就天马行空只有你想不到的，没有它做不到的。</p><p>轮询理解起来就是依次把请求打到每一个服务器然后循环，如下图所示:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/cSANKt894iPCban.png"                      alt="image.png"                ></p><p>加权轮询理解起来就是每个服务器都有一个权重，权重大的会接收到更多的请求，权重小的会接收到更少的请求，如下图所示:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/G3nRtIjbkiTgJFY.png"                      alt="image.png"                ></p><p>什么叫ip hash呢，我们在写项目的时候经常有个Session的问题，这个Session也就是会话，它会保存到tomcat里面，但如果我们启动了很多个服务器，就有很多个tomcat，这时候tomcat就有n个，那n个tomcat，Session就有n个，这个时候肯定是不可能做到Session共享的；我们现在更多方案可能是使用Redis，Nginx也给我们提供了一种默认的算法，就是可以通过ip进行计算，固定的ip永远只能打到这台服务器上，那就可以保证Session一直在这台服务器上，但这样做性能也不是很好，如果这台服务器挂了，那所有信息就都没了，所以最好还是使用Redis来做Session共享，ip hash实现如下图所示:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/ZEj6QMufmThK9F2.png"                      alt="image.png"                ></p><p>我们还可以使用Nginx来做动静分离，什么叫动静分离呢，比如说你项目里面有很多静态资源，比如说你放了一个bootstrap的js或者说放了一堆jQuery的js，像这样一堆静态资源每次都要从你的jar包里面去加载就比较麻烦，那我希望有一个静态资源服务器去返回这些静态资源，Nginx就能做到这个</p><h2 id="Nginx安装-Windows"><a href="#Nginx安装-Windows" class="headerlink" title="Nginx安装-Windows"></a>Nginx安装-Windows</h2><p>Nginx是跨平台的</p><p>直接官网安装即可，你可以发现，它才1.几M</p><p>里面有个conf文件，然后其中有个nginx.conf文件，打开这个文件发现有个listen监听端口，默认是80端口，以后只要访问这个端口，就会被Nginx拦截:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/WYMITVwZS32yKkJ.png"                      alt="image.png"                ></p><p>我们可以双击nginx.exe来启动Nginx，但是我不建议大家双击，因为双击会一闪而过然后就没了，我们可以在路径这一栏先清除，然后输入cmd进入控制台，然后键入nginx.exe进行启动，这个时候要注意，如果路径中包含中文是可能报错的；那么怎么判断启动成功了呢，我们可以在浏览器中访问本地的80端口，因为刚刚配置文件中默认配的监听端口就是80，80端口是HTTP的默认端口，我们也可以省略不写，如果能看到Welcome to nginx就代表我们的nginx启动成功了，如下图所示:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/x3FBXHLDZPA8e6O.png"                      alt="image.png"                ></p><h2 id="Nginx安装-Linux"><a href="#Nginx安装-Linux" class="headerlink" title="Nginx安装-Linux"></a>Nginx安装-Linux</h2><p>Linux安装就需要下载Linux版本的Nginx的安装包，然后把它上传到Linux的服务器上，首先我们要确保本机上是没有Nginx的，使用命令<code>whereis nginx</code>来查看是否已经存在Nginx(还可以输入局nginx来再次确定):<img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/DPzdgoU648QbRat.png"                      alt="image.png"                ></p><p>确保本机上没有Nginx后，我们需要解压刚刚上传的nginx-1.18.0.tar.gz，使用<code>tar -zxvf nginx-1.18.0.tar.gz</code>来解压，解压完之后，我们进入nginx-1.18.0这个目录(在Linux上一般叫做目录)来看看它其实和在Windows上看到的目录是一样的，这里面也有我们的config配置文件，在这里面的话，我们要去安装以前学Linux的话学过make命令，这里面有个configure文件，我们先使用<code>.\configure</code>执行下这个文件，等它执行完之后使用命令<code>make</code>一下就可以了，跟安装咱们的Redis是一样的，然后再使用<code>make install</code>命令，执行完这个命令之后我们可以使用<code>whereis nginx</code>来找一下nginx，看看能不嫩肤找得到，找得到就说明安装成功了。那么如何启动它呢，我们可以进入它的安装目录，然后使用<code>ll</code>名看看有什么文件夹，可以看到有个sbin文件夹:<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/QPMxarkOVIuHogj.png"                      alt="image.png"                ></p><p>sbin里面就是一些执行文件，我们可以在里面进行启动，首先进入到这个文件夹，然后可以看到里面有个nginx的程序，直接执行这个nginx文件即可:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/BgnsFIQtlx8dvZS.png"                      alt="image.png"                ></p><p>如果执行成功的话，你是看不到任何日志的，在Linux里面没有报错就代表成功了，我们可以像刚刚在Windows中访问80端口一样看看是否能打开<code>Welcome to nginx</code>页面，能打开就说明启动成功了</p><h2 id="Nginx的常用命令"><a href="#Nginx的常用命令" class="headerlink" title="Nginx的常用命令"></a>Nginx的常用命令</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/24/vYSKqOaePsH1wb6.png"                      alt="image.png"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nginx简介&quot;&gt;&lt;a href=&quot;#Nginx简介&quot; class=&quot;headerlink&quot; title=&quot;Nginx简介&quot;&gt;&lt;/a&gt;Nginx简介&lt;/h2&gt;&lt;p&gt;&lt;img  
                     lazyload
             </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>详解如何进入、退出docker容器的方法</title>
    <link href="http://example.com/2022/04/18/%E8%AF%A6%E8%A7%A3%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E3%80%81%E9%80%80%E5%87%BAdocker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/04/18/%E8%AF%A6%E8%A7%A3%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E3%80%81%E9%80%80%E5%87%BAdocker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2022-04-18T01:29:30.000Z</published>
    <updated>2022-04-18T01:51:24.889Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>启动docker服务:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>关闭docker服务:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker stop</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure></li><li><p>启动docker的某个image(镜像)的container(容器)，也就是从指定镜像生成一个容器并启动它，容器也被称为镜像的一个实例:</p><p>Docker的镜像称为image，容器称为container；对于Docker来说，image是静态的，类似于操作系统快照，而container则是动态的，是image的运行实例；比如，有一个image名称为ubuntu，那么比如现在我们启动这个image的container<strong>并且进入到这个container的bash命令行中</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i ubuntu /<span class="built_in">bin</span>/bash</span><br></pre></td></tr></table></figure><p>命令理解:</p><ul><li>docker run: 启动由指定image生成的container</li><li>ubuntu: 你指定的image</li><li>-t: 进入container的终端</li><li>-i: 获得一个交互式的连接，通过获取container的输入</li><li>/bin/bash: 在container中启动一个bash shell</li></ul><p>这样就进入container的内部了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>如果要退出当前容器，使用<code>exit</code>或者<code>Ctrl+D</code>，退出后，这个容器也会停止运行，我们要使用以下命令重启这个container:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start goofy_almeida</span><br></pre></td></tr></table></figure><p>其中<code>goofy_almeida</code>是容器的名称</p><p>那么这里也提下，停止一个<code>container</code>使用以下命令:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop goofy_almeida</span><br></pre></td></tr></table></figure><p>其中<code>goofy_almeida</code>是容器的名称</p></li><li><p>进入container(容器)</p><ul><li><p>使用<code>docker attach</code>命令进入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach goofy_almeida</span><br></pre></td></tr></table></figure><p>其中<code>goofy_almeida</code>是容器的名称</p></li><li><p>使用<code>docker exec -it</code>命令进入:</p><p>使用<code>docker attach</code>命令进入<code>container</code>有一个缺点，那就是每次从<code>container</code>中退出到前台时，<code>container</code>也跟着退出了；要想退出<code>container</code>时，让<code>container</code>仍然在后台运行着，那就需要使用<code>docker exec -it</code>命令，每次使用这个命令进入<code>container</code>后，当退出<code>container</code>后，<code>container</code>仍然在后台运行，使用方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it goofy_almeida /<span class="built_in">bin</span>/bash</span><br></pre></td></tr></table></figure><ul><li>goofy_almeida: 要进入容器的名称</li><li>/bin/bash: 在container中启动一个bash shell</li></ul><p>这样输入<code>exit</code>或者按键<code>Ctrl+C</code>退出<code>container</code>时，这个<code>container</code>仍然在后台运行，我们可以使用<code>docker ps</code>来查看当前在运行的<code>container</code>，使用<code>docker ps -a</code>查看所有容器，包括在运行的和不在运行的</p></li></ul></li></ol><p>参考自: <a class="link"   href="https://www.jb51.net/article/203279.htm" >https://www.jb51.net/article/203279.htm<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;启动docker服务:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker部署Django项目</title>
    <link href="http://example.com/2022/04/18/Docker%E9%83%A8%E7%BD%B2Django%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2022/04/18/Docker%E9%83%A8%E7%BD%B2Django%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-04-18T01:17:20.000Z</published>
    <updated>2022-04-18T01:18:29.136Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞毕设，然后想着前端这边还是用docker部署下，转载自CSDN: <a class="link"   href="https://blog.csdn.net/qq_42393859/article/details/106429198?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_aa&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4" >https://blog.csdn.net/qq_42393859/article/details/106429198?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_aa&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在搞毕设，然后想着前端这边还是用docker部署下，转载自CSDN: &lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/qq_42393859/article/details/106429198?utm_medium=distr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker部署Flask项目</title>
    <link href="http://example.com/2022/04/16/Docker%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2022/04/16/Docker%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-04-16T10:43:30.000Z</published>
    <updated>2022-04-16T10:58:09.887Z</updated>
    
    <content type="html"><![CDATA[<p>小项目其实用不着docker部署，不过这里也还是记录下，之前的文章(Flask以配置文件启动)其实就足够了</p><p>首先我们需要创建一个<code>requirements.txt</code>，推荐使用<code>pipreqs</code>，可以参考这个文章，点击<a class="link"   href="http://kest.club/2022/04/16/%E5%AF%B9%E6%AF%94pip%20freeze,%E6%88%91%E9%80%89%E6%8B%A9pipreqs/" >跳转<i class="fas fa-external-link-alt"></i></a>，示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django==<span class="number">1.8</span><span class="number">.7</span></span><br><span class="line">numpy</span><br><span class="line">pandas</span><br></pre></td></tr></table></figure><p>然后我们需要创建一个Dockerfile文件，该文件没有后缀，以便Docker镜像的构建，示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM python:<span class="number">3.6</span></span><br><span class="line"></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"></span><br><span class="line">COPY requirements.txt ./</span><br><span class="line">RUN pip install --no-cache-<span class="built_in">dir</span> -r requirements.txt</span><br><span class="line"></span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">&quot;gunicorn&quot;</span>, <span class="string">&quot;app:app&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;./gunicorn.conf.py&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基于的基础镜像</span></span><br><span class="line">FROM python:<span class="number">3.5</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#代码添加到code文件夹</span></span><br><span class="line">ADD ./package /code</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置code文件夹是工作目录</span></span><br><span class="line">WORKDIR /code</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 安装支持</span></span><br><span class="line">RUN pip install -i https://pypi.doubanio.com/simple/ -r requirements.txt</span><br><span class="line"> </span><br><span class="line">CMD [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/code/docker_test/run.py&quot;</span>]</span><br></pre></td></tr></table></figure><p>然后是把代码上传到云服务器创建镜像(反正我是这么做的):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t flask项目名 .</span><br></pre></td></tr></table></figure><p>查看镜像:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>运行镜像，生成并启动容器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p <span class="number">8000</span>:<span class="number">8000</span> --name xxx xxxx</span><br></pre></td></tr></table></figure><p>-it: 表示交互式终端的容器，非启动后立刻结束的容器</p><p>-p 8000:8000：表示将docker的8000端口，映射到Linux的8000端口</p><p>–name xxx：给容器取个名字，嫌麻烦可以省去</p><p>xxxx: 容器是用哪个镜像启动的(一个容器，必须依赖一个镜像启动)</p><ul><li>参考自: <a class="link"   href="https://blog.csdn.net/qq_42393859/article/details/106429198?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_aa&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4" >https://blog.csdn.net/qq_42393859/article/details/106429198?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_aa&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=4<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://juejin.cn/post/6844904142159233038" >https://juejin.cn/post/6844904142159233038<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小项目其实用不着docker部署，不过这里也还是记录下，之前的文章(Flask以配置文件启动)其实就足够了&lt;/p&gt;
&lt;p&gt;首先我们需要创建一个&lt;code&gt;requirements.txt&lt;/code&gt;，推荐使用&lt;code&gt;pipreqs&lt;/code&gt;，可以参考这个文章，点击</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Flask以配置文件启动</title>
    <link href="http://example.com/2022/04/16/Flask%E4%BB%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8/"/>
    <id>http://example.com/2022/04/16/Flask%E4%BB%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%90%AF%E5%8A%A8/</id>
    <published>2022-04-16T10:39:30.000Z</published>
    <updated>2022-04-16T10:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写毕业设计，然后要完成一个图片的上传接口，我是用Flask写的，然后需要放到云服务器上去跑，这个时候我们可以在项目中写一个<code>gunicorn.conf.py</code>文件这个文件其实就是<code>gunicorn</code>的配置文件，然后我们还需要安装两个模块<code>gunicorn</code>和<code>gevent</code>，使用以下命令安装:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gunicorn gevent</span><br></pre></td></tr></table></figure><p>以下是我接口项目的<code>gunicorn.conf.py</code>，在这里也是给出一个案例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workers = <span class="number">5</span>    <span class="comment"># 定义同时开启的处理请求的进程数量，根据网站流量适当调整</span></span><br><span class="line">worker_class = <span class="string">&quot;gevent&quot;</span>   <span class="comment"># 采用gevent库，支持异步处理请求，提高吞吐量</span></span><br><span class="line">bind = <span class="string">&quot;0.0.0.0:8888&quot;</span>    <span class="comment"># 监听IP放宽(让别的主机也能访问)</span></span><br></pre></td></tr></table></figure><p>到这里，我们就可以在云服务器上跑我们的接口了，使用以下命令:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -c gunicorn.conf.py app:app</span><br></pre></td></tr></table></figure><p>第一个<code>app</code>指的是<code>app.py</code>文件的名字，第二个<code>app</code>指的是flask应用的名字，还可以加上参数<code>-d</code>表示后台启动</p><p>附上一个<code>Flask</code>代码案例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app.py</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>():</span>  </span><br><span class="line">    app = Flask(__name__)  </span><br><span class="line">    <span class="keyword">return</span> app  </span><br><span class="line">app = create_app()  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span>  </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world!&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    app.run()   <span class="comment"># .run()前的就是flask应用的名字</span></span><br></pre></td></tr></table></figure><p>附上<code>gunicorn</code>的参数详解:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">-c CONFIG    : CONFIG,配置文件的路径，通过配置文件启动；生产环境使用；</span><br><span class="line"></span><br><span class="line">-b ADDRESS   : ADDRESS，ip加端口，绑定运行的主机；</span><br><span class="line"></span><br><span class="line">-w INT, --workers INT：用于处理工作进程的数量，为正整数，默认为<span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">-k STRTING, --worker-<span class="class"><span class="keyword">class</span> <span class="title">STRTING</span>：要使用的工作模式，默认为<span class="title">sync</span>异步，可以下载<span class="title">eventlet</span>和<span class="title">gevent</span>并指定</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">threads</span> <span class="title">INT</span>：处理请求的工作线程数，使用指定数量的线程运行每个<span class="title">worker</span>。为正整数，默认为1。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">worker</span>-<span class="title">connections</span> <span class="title">INT</span>：最大客户端并发数量，默认情况下这个值为1000。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">backlog</span> <span class="title">int</span>：未决连接的最大数量，即等待服务的客户的数量。默认2048个，一般不修改；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-<span class="title">p</span> <span class="title">FILE</span>, --<span class="title">pid</span> <span class="title">FILE</span>：设置<span class="title">pid</span>文件的文件名，如果不设置将不会创建<span class="title">pid</span>文件</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">access</span>-<span class="title">logfile</span> <span class="title">FILE</span>   ：  要写入的访问日志目录</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">access</span>-<span class="title">logformat</span> <span class="title">STRING</span>：要写入的访问日志格式</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">error</span>-<span class="title">logfile</span> <span class="title">FILE</span>, --<span class="title">log</span>-<span class="title">file</span> <span class="title">FILE</span>  ：  要写入错误日志的文件目录。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">log</span>-<span class="title">level</span> <span class="title">LEVEL</span>   ：   错误日志输出等级。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">limit</span>-<span class="title">request</span>-<span class="title">line</span> <span class="title">INT</span>   ：  <span class="title">HTTP</span>请求头的行数的最大大小，此参数用于限制<span class="title">HTTP</span>请求行的允许大小，默认情况下，这个值为4094。值是0~8190的数字。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">limit</span>-<span class="title">request</span>-<span class="title">fields</span> <span class="title">INT</span>   ：  限制<span class="title">HTTP</span>请求中请求头字段的数量。此字段用于限制请求头字段的数量以防止<span class="title">DDOS</span>攻击，默认情况下，这个值为100，这个值不能超过32768</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">limit</span>-<span class="title">request</span>-<span class="title">field</span>-<span class="title">size</span> <span class="title">INT</span>  ：  限制<span class="title">HTTP</span>请求中请求头的大小，默认情况下这个值为8190字节。值是一个整数或者0，当该值为0时，表示将对请求头大小不做限制</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-<span class="title">t</span> <span class="title">INT</span>, --<span class="title">timeout</span> <span class="title">INT</span>：超过这么多秒后工作将被杀掉，并重新启动。一般设定为30秒；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">daemon</span>： 是否以守护进程启动，默认<span class="title">false</span>；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">chdir</span>： 在加载应用程序之前切换目录；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">graceful</span>-<span class="title">timeout</span> <span class="title">INT</span>：默认情况下，这个值为30，在超时(<span class="params">从接收到重启信号开始</span>)之后仍然活着的工作将被强行杀死；一般使用默认；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">keep</span>-<span class="title">alive</span> <span class="title">INT</span>：在<span class="title">keep</span>-<span class="title">alive</span>连接上等待请求的秒数，默认情况下值为2。一般设定在1~5秒之间。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">reload</span>：默认为<span class="title">False</span>。此设置用于开发，每当应用程序发生更改时，都会导致工作重新启动。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">spew</span>：打印服务器执行过的每一条语句，默认<span class="title">False</span>。此选择为原子性的，即要么全部打印，要么全部不打印；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">--<span class="title">check</span>-<span class="title">config</span>   ：显示现在的配置，默认值为<span class="title">False</span>，即显示。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-<span class="title">e</span> <span class="title">ENV</span>, --<span class="title">env</span> <span class="title">ENV</span>： 设置环境变量；</span></span><br></pre></td></tr></table></figure><p>参考自:</p><ul><li><a class="link"   href="https://blog.csdn.net/weixin_42881588/article/details/108768493" >https://blog.csdn.net/weixin_42881588/article/details/108768493<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://juejin.cn/post/6844904142159233038" >https://juejin.cn/post/6844904142159233038<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在写毕业设计，然后要完成一个图片的上传接口，我是用Flask写的，然后需要放到云服务器上去跑，这个时候我们可以在项目中写一个&lt;code&gt;gunicorn.conf.py&lt;/code&gt;文件这个文件其实就是&lt;code&gt;gunicorn&lt;/code&gt;的配置文件，然后我们还需要</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Django项目在服务器上跑出现样式不起作用</title>
    <link href="http://example.com/2022/04/16/Django%E9%A1%B9%E7%9B%AE%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%B7%91%E5%87%BA%E7%8E%B0%E6%A0%B7%E5%BC%8F%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2022/04/16/Django%E9%A1%B9%E7%9B%AE%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E8%B7%91%E5%87%BA%E7%8E%B0%E6%A0%B7%E5%BC%8F%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</id>
    <published>2022-04-15T17:10:50.000Z</published>
    <updated>2022-04-16T01:06:14.289Z</updated>
    
    <content type="html"><![CDATA[<p>请参考: <a class="link"   href="https://blog.csdn.net/qq_36874480/article/details/100652364?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-5.pc_relevant_default&amp;utm_relevant_index=9" >https://blog.csdn.net/qq_36874480/article/details/100652364?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5.pc_relevant_default&amp;utm_relevant_index=9<i class="fas fa-external-link-alt"></i></a></p><p>可以加个<code>--insecure </code>参数，但这是处于不安全模式下的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;请参考: &lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/qq_36874480/article/details/100652364?spm=1001.2101.3001.6650.5&amp;amp;utm_medium=distrib</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Layui使用文档</title>
    <link href="http://example.com/2022/04/16/Layui%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2022/04/16/Layui%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</id>
    <published>2022-04-15T17:04:43.000Z</published>
    <updated>2022-04-16T01:06:16.715Z</updated>
    
    <content type="html"><![CDATA[<p>请跳转: <a class="link"   href="http://layui-doc.pearadmin.com/doc/index.html" >http://layui-doc.pearadmin.com/doc/index.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;请跳转: &lt;a class=&quot;link&quot;   href=&quot;http://layui-doc.pearadmin.com/doc/index.html&quot; &gt;http://layui-doc.pearadmin.com/doc/index.html&lt;i class=&quot;fas f</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前后端分离与不分离</title>
    <link href="http://example.com/2022/04/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%8E%E4%B8%8D%E5%88%86%E7%A6%BB/"/>
    <id>http://example.com/2022/04/16/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%8E%E4%B8%8D%E5%88%86%E7%A6%BB/</id>
    <published>2022-04-15T16:54:45.000Z</published>
    <updated>2022-04-16T01:06:19.026Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a class="link"   href="https://www.cnblogs.com/xiaobenshou/p/10263851.html" >https://www.cnblogs.com/xiaobenshou/p/10263851.html<i class="fas fa-external-link-alt"></i></a></li></ul><p>前后端不分离: 后端直接返回一个完整的html文件给前端，前端只负责将他展示出来</p><p>前后端分离: 后端将生成一个接口(API)，前端访问该接口获取相应的数据(比如数据库数据)，然后再进行页面渲染展示</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;link&quot;   href=&quot;https://www.cnblogs.com/xiaobenshou/p/10263851.html&quot; &gt;https://www.cnblogs.com/xiaobenshou/p/10263851.html&lt;i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python创建虚拟环境之pipenv</title>
    <link href="http://example.com/2022/04/16/Python%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%B9%8Bpipenv/"/>
    <id>http://example.com/2022/04/16/Python%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%B9%8Bpipenv/</id>
    <published>2022-04-15T16:35:29.000Z</published>
    <updated>2022-04-16T01:06:20.978Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a class="link"   href="https://www.cnblogs.com/xp1315458571/p/13365454.html" >https://www.cnblogs.com/xp1315458571/p/13365454.html<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://blog.csdn.net/RNG_uzi_/article/details/121903762" >https://blog.csdn.net/RNG_uzi_/article/details/121903762<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://zhuanlan.zhihu.com/p/349919589" >https://zhuanlan.zhihu.com/p/349919589<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;link&quot;   href=&quot;https://www.cnblogs.com/xp1315458571/p/13365454.html&quot; &gt;https://www.cnblogs.com/xp1315458571/p/13365454.html</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>对比pip freeze,我选择pipreqs</title>
    <link href="http://example.com/2022/04/16/%E5%AF%B9%E6%AF%94pip%20freeze,%E6%88%91%E9%80%89%E6%8B%A9pipreqs/"/>
    <id>http://example.com/2022/04/16/%E5%AF%B9%E6%AF%94pip%20freeze,%E6%88%91%E9%80%89%E6%8B%A9pipreqs/</id>
    <published>2022-04-15T16:16:19.000Z</published>
    <updated>2022-04-16T01:06:22.896Z</updated>
    
    <content type="html"><![CDATA[<p>我们在部署项目的时候通常会将依赖的一些模块写入<code>requirements.txt</code>中，如果是在一个虚拟环境中(如何创建虚拟环境请参考<a class="link"   href="http://kest.club/2022/03/19/Python%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E6%AD%A5%E9%AA%A4/" >这里<i class="fas fa-external-link-alt"></i></a>)，在虚拟环境中的项目，我们可以在项目根目录下使用以下命令创建:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><p>上面的命令是我们所熟知的，但如果我们不是在虚拟环境中创建的项目，使用上面的命令就会把<code>Python site-package</code>里面的所有模块都添加到<code>requirements.txt</code>中，这显然不是我们想要的，所以就有了下面的方法</p><p>首先我们需要安装一个模块<code>pipreqs</code>，使用以下命令:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pipreqs</span><br></pre></td></tr></table></figure><p>然后进入到项目的根目录中运行以下命令:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipreqs . --encoding=utf8 --force</span><br></pre></td></tr></table></figure><p><code>.</code>表示在当前目录生成</p><p>注意: <code>--encoding=utf8</code> 为使用<code>utf8</code>编码，不然可能会报<code>UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0xae in position 406: illegal multibyte sequence</code> 的错误；<code>--force</code> 强制执行，当该目录下已有<code>requirements.txt</code>时会覆盖掉原有的</p><p>示例:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/16/Zw9AGHrynfEK8Oj.png"                      alt="image.png"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们在部署项目的时候通常会将依赖的一些模块写入&lt;code&gt;requirements.txt&lt;/code&gt;中，如果是在一个虚拟环境中(如何创建虚拟环境请参考&lt;a class=&quot;link&quot;   href=&quot;http://kest.club/2022/03/19/Python%E</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MongoDB数据库莫名其妙没了被黑客勒索(要开启验证)</title>
    <link href="http://example.com/2022/04/11/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E6%B2%A1%E4%BA%86%E8%A2%AB%E9%BB%91%E5%AE%A2%E5%8B%92%E7%B4%A2/"/>
    <id>http://example.com/2022/04/11/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E6%B2%A1%E4%BA%86%E8%A2%AB%E9%BB%91%E5%AE%A2%E5%8B%92%E7%B4%A2/</id>
    <published>2022-04-11T08:02:30.000Z</published>
    <updated>2022-04-11T08:03:44.496Z</updated>
    
    <content type="html"><![CDATA[<p>参考自1: <a class="link"   href="https://blog.csdn.net/u013513053/article/details/105785980?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-105785980.pc_agg_new_rank&amp;utm_term=read_me_to_recover_database&amp;spm=1000.2123.3001.4430" >https://blog.csdn.net/u013513053/article/details/105785980?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-105785980.pc_agg_new_rank&amp;utm_term=read_me_to_recover_database&amp;spm=1000.2123.3001.4430<i class="fas fa-external-link-alt"></i></a></p><p>参考自2: <a class="link"   href="https://segmentfault.com/a/1190000011554055" >https://segmentfault.com/a/1190000011554055<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考自1: &lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/u013513053/article/details/105785980?utm_medium=distribute.pc_aggpage_search_result.n</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python重试机制之自带模块tenacity</title>
    <link href="http://example.com/2022/04/11/Python%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97tenacity/"/>
    <id>http://example.com/2022/04/11/Python%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E4%B9%8B%E8%87%AA%E5%B8%A6%E6%A8%A1%E5%9D%97tenacity/</id>
    <published>2022-04-11T07:59:30.000Z</published>
    <updated>2022-04-11T08:00:11.409Z</updated>
    
    <content type="html"><![CDATA[<p>参考自: <a class="link"   href="https://blog.csdn.net/hhs_1996/article/details/114590778" >https://blog.csdn.net/hhs_1996/article/details/114590778<i class="fas fa-external-link-alt"></i></a></p><p>官方文档: <a class="link"   href="https://pypi.org/project/retry/" >https://pypi.org/project/retry/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考自: &lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/hhs_1996/article/details/114590778&quot; &gt;https://blog.csdn.net/hhs_1996/article/details/11</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>删除mongodb中存在的用户</title>
    <link href="http://example.com/2022/04/11/%E5%88%A0%E9%99%A4mongodb%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E7%94%A8%E6%88%B7/"/>
    <id>http://example.com/2022/04/11/%E5%88%A0%E9%99%A4mongodb%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E7%94%A8%E6%88%B7/</id>
    <published>2022-04-11T07:55:30.000Z</published>
    <updated>2022-04-11T07:55:40.408Z</updated>
    
    <content type="html"><![CDATA[<p>参考自: <a class="link"   href="https://blog.csdn.net/K_520_W/article/details/108309862?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mongodb%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-108309862.nonecase&amp;spm=1018.2226.3001.4187" >https://blog.csdn.net/K_520_W/article/details/108309862?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=mongodb%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-108309862.nonecase&amp;spm=1018.2226.3001.4187<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考自: &lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/K_520_W/article/details/108309862?ops_request_misc=&amp;amp;request_id=&amp;amp;biz_id=102&amp;amp</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于使用WinSCP上传文件报permission denied的解决</title>
    <link href="http://example.com/2022/04/08/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8WinSCP%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8A%A5permission%20denied%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://example.com/2022/04/08/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8WinSCP%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8A%A5permission%20denied%E7%9A%84%E8%A7%A3%E5%86%B3/</id>
    <published>2022-04-08T10:55:30.000Z</published>
    <updated>2022-04-08T10:56:11.216Z</updated>
    
    <content type="html"><![CDATA[<p>详见: <a class="link"   href="https://www.likecs.com/show-204385837.html" >https://www.likecs.com/show-204385837.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;详见: &lt;a class=&quot;link&quot;   href=&quot;https://www.likecs.com/show-204385837.html&quot; &gt;https://www.likecs.com/show-204385837.html&lt;i class=&quot;fas fa-exter</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Flask写接口的一个案例</title>
    <link href="http://example.com/2022/04/06/Flask%E5%86%99%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2022/04/06/Flask%E5%86%99%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B/</id>
    <published>2022-04-06T08:55:30.000Z</published>
    <updated>2022-04-06T10:53:50.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向的人群"><a href="#面向的人群" class="headerlink" title="面向的人群"></a>面向的人群</h2><p>具有Python基础知识</p><p>只写接口，想好好学做接口的</p><h2 id="Flask是什么"><a href="#Flask是什么" class="headerlink" title="Flask是什么"></a>Flask是什么</h2><p>以下来自百度百科:</p><p>Flask是一个使用 <a class="link"   href="https://baike.baidu.com/item/Python" >Python<i class="fas fa-external-link-alt"></i></a> 编写的轻量级 Web 应用框架。其 <a class="link"   href="https://baike.baidu.com/item/WSGI" >WSGI<i class="fas fa-external-link-alt"></i></a> 工具箱采用 Werkzeug ，<a class="link"   href="https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/907667" >模板引擎<i class="fas fa-external-link-alt"></i></a>则使用 Jinja2 。Flask使用 BSD 授权。</p><p>Flask也被称为 “microframework” ，因为它使用简单的核心，用 extension 增加其他功能。Flask没有默认使用的数据库、窗体验证工具</p><h2 id="推荐使用虚拟环境"><a href="#推荐使用虚拟环境" class="headerlink" title="推荐使用虚拟环境"></a>推荐使用虚拟环境</h2><p>关于环境可以参考:</p><p><a class="link"   href="http://kest.club/2022/03/19/Python%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E6%AD%A5%E9%AA%A4/" >http://kest.club/2022/03/19/Python%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E7%9A%84%E6%AD%A5%E9%AA%A4/<i class="fas fa-external-link-alt"></i></a></p><p>以下所写的项目是没有用虚拟环境的，这个见仁见智</p><h2 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h2><p>app.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span>  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/06/yc4NCBEdqgAP3Sl.png"                      alt="image.png"                ></p><h2 id="路由加入变量"><a href="#路由加入变量" class="headerlink" title="路由加入变量"></a>路由加入变量</h2><p>app.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span>  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hey/&lt;username&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hey_lihoujian</span>(<span class="params">username</span>):</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hey, &#123;&#125;&quot;</span>.<span class="built_in">format</span>(username)  <span class="comment"># 要注意这里传入的username会转化为字符串，比如我们如果返回&quot;hey,&#123;&#125;&quot;.format(username + username)，当路由中的username我们传入的是1，那么实际上会返回hey, 11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p>那如果我们就是不想它默认转化为字符串呢，这里有四个选择:</p><ul><li>int 接受正整数</li><li>float 接受正浮点数</li><li>path 类似<code>string</code>但可以包含斜杠</li><li>uuid 接受UUID字符串</li><li><strong>String</strong> (缺省值)接受任何不包含斜杠的文本<code>&lt;&gt;</code></li></ul><p>app.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test/&lt;int:number&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_number</span>(<span class="params">number</span>):</span>  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;test &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(number + number)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p>这个路由一定要注意，我们路由一定要匹配特别是路由的末尾不要多一个反斜杠，如果在浏览器的路径中多了个反斜杠，那么相应的在flask的代码中也要在路由末尾加个反斜杠，如果是路由中有反斜杠而我们在浏览器中忘了在最末尾加上一个反斜杠，这是可以的，因为浏览器会帮我们加反斜杠，如果在路由中没有斜杆而我们在浏览器中添加了斜杠，这就会报错</p><h2 id="URL的重定向行为"><a href="#URL的重定向行为" class="headerlink" title="URL的重定向行为"></a>URL的重定向行为</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/06/TtWEJCXHNjlRS5n.png"                      alt="image.png"                ></p><h2 id="FlaskHTTP方法"><a href="#FlaskHTTP方法" class="headerlink" title="FlaskHTTP方法"></a>FlaskHTTP方法</h2><p>以下引用自菜鸟教程:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/06/PfJsFdLZRpUozqM.png"                      alt="image.png"                ></p><h2 id="Json格式的API"><a href="#Json格式的API" class="headerlink" title="Json格式的API"></a>Json格式的API</h2><p>这里以post为例，常见的提交格式有:</p><ul><li>json</li><li>form</li><li>xml</li></ul><p>获取前端过来的数据:</p><p>app.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test/my/first&#x27;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_post</span>():</span></span><br><span class="line">my_json = request.get_json()</span><br><span class="line"><span class="built_in">print</span>(my_json)</span><br><span class="line"><span class="keyword">return</span> my_json.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/06/APaDvSVZMY4RfyO.png"                      alt="image.png"                ></p><p>返回json格式的数据:</p><p>app.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test/my/first&#x27;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_post</span>():</span></span><br><span class="line">my_json = request.get_json()</span><br><span class="line"><span class="built_in">print</span>(my_json)</span><br><span class="line">get_name = my_json.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">get_age = my_json.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">get_age += <span class="number">10</span></span><br><span class="line"><span class="keyword">return</span> jsonify(name=get_name, age=get_age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/06/XgPdGBvHTlobKFn.png"                      alt="image.png"                ></p><p>然后我们还可以加一些异常处理:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/test/my/first&#x27;</span>, methods=[<span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first_post</span>():</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">my_json = request.get_json()</span><br><span class="line"><span class="built_in">print</span>(my_json)</span><br><span class="line">get_name = my_json.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">get_age = my_json.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>([get_age, get_name]):</span><br><span class="line"><span class="keyword">return</span> jsonify(msg=<span class="string">&quot;缺少参数!&quot;</span>)</span><br><span class="line">get_age += <span class="number">10</span></span><br><span class="line"><span class="keyword">return</span> jsonify(name=get_name, age=get_age)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">return</span> jsonify(msg=<span class="string">&quot;请查看是否正确访问!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure><h2 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h2><p>具体参见: <a class="link"   href="https://dormousehole.readthedocs.io/en/latest/" >https://dormousehole.readthedocs.io/en/latest/<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面向的人群&quot;&gt;&lt;a href=&quot;#面向的人群&quot; class=&quot;headerlink&quot; title=&quot;面向的人群&quot;&gt;&lt;/a&gt;面向的人群&lt;/h2&gt;&lt;p&gt;具有Python基础知识&lt;/p&gt;
&lt;p&gt;只写接口，想好好学做接口的&lt;/p&gt;
&lt;h2 id=&quot;Flask是什么&quot;&gt;&lt;a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>权力的游戏第三季第四集对话片段</title>
    <link href="http://example.com/2022/04/04/%E6%9D%83%E5%8A%9B%E7%9A%84%E6%B8%B8%E6%88%8F%E7%AC%AC%E4%B8%89%E5%AD%A3%E7%AC%AC%E4%B8%89%E9%9B%86%E5%AF%B9%E8%AF%9D%E7%89%87%E6%AE%B5/"/>
    <id>http://example.com/2022/04/04/%E6%9D%83%E5%8A%9B%E7%9A%84%E6%B8%B8%E6%88%8F%E7%AC%AC%E4%B8%89%E5%AD%A3%E7%AC%AC%E4%B8%89%E9%9B%86%E5%AF%B9%E8%AF%9D%E7%89%87%E6%AE%B5/</id>
    <published>2022-04-04T12:59:39.000Z</published>
    <updated>2022-04-06T09:08:14.912Z</updated>
    
    <content type="html"><![CDATA[<p>T: you`re still here 还不走啊</p><p>S: yes 对</p><p>T: why 为什么</p><p>S: dit lt ever occur to you that I might be the one who deserves your confidence and your trust, not your sons ? 你有没有想过，也许我是最值得你信任的人，而不是你的儿子们？</p><p>S: Not Jaime or Tyrion, but me. 不是詹姆也不是提利昂，是我</p><p>S: Years and Years of lectures on family and <strong>legacy</strong>–the same lacture, really; just with tiny, tedious variations, did it ever occur to you that your daughter living by them年复一年的教诲，有关家族和祖传家业，千篇一律；只有乏味而微小的改变，不知你是否意识到你的女儿可能是唯一以此为信念的人</p><p><strong>legacy</strong>: 遗产</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/05/HkVDnz9UrglIf6h.png"                      alt="image.png"                ></p><p>S: That she might have the most to contribute to your legacy that you love so much more than your actual children? 您把祖训(遗产)看得比自己的孩子们要重要得多，而她也许最能帮助你去完成</p><p>T: All right. Contribute. 好吧，来帮助我</p><p>S: The Tyrells are a problem. 提利尔家族是个问题</p><p>T: The Tyrells helped us defeat Stannis Baratheon. 提利尔家族帮我们打败了史坦尼丝拜拉席恩</p><p>T: The Tyrells saved your life, your childen`s lives. 提利尔家族救了你的命，救了你孩子们的命</p><p>S: Margaery has her claws in Joffrey. 玛格丽将魔爪伸向了乔佛里</p><p>S: She konws how to <strong>manipulate</strong> him. 她懂得如何操控他</p><p><strong>manipulate</strong>: 操控</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/05/XogV6LqSr1CmNpB.png"                      alt="image.png"                ></p><p>T: Good. I wish you knew how to manipulate him. 不错，我真希望你也懂得如何操控他</p><p>T: I don`t distrust you because you are a woman. I distrust you because you are not as smart as you think you are. You have allowed that boy to ride <strong>roughshod</strong> over you and everyone else in this city. 我不信任你，不是因为你是女人，而是因为你自以为是；你让儿子骑在你头上，还任凭他欺压城里的所有人</p><p><strong>roughshod</strong>: 为所欲为，横行霸道</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/05/NhVBwE3ojunKTLX.png"                      alt="image.png"                ></p><p>S: Perhaps… you should try stopping him from doing what he likes. 也许… 您应该阻止他为所欲为</p><p>T: I will. 我会的</p><p>S: Do you like lt, Nana? 您喜欢吗？奶奶</p><p>N: Aonther golden rose. How original. 又一朵金玫瑰，真没劲</p><p>N: I eat from plates stamped with roses. 我吃饭的盘子里刻着玫瑰</p><p>N: I sleep in sheets embroidered with roses. 我睡觉的被单上绣着玫瑰</p><p>N: I have a golden rose painted on my <strong>chamber pot</strong>, as if that makes it smell any better. 我的夜壶上也有一个金玫瑰，难道这样就能好闻点</p><p><strong>chamber pot</strong>: 夜壶</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://s2.loli.net/2022/04/05/Wto9rbgNjq2cZkT.png"                      alt="image.png"                ></p><p>N: rose are boring, dear. 亲爱的，玫瑰很无趣</p><p>N: “Growing strong” “生生不息”</p><p>N: Ha! The dullest words of any house. 所有家族中最无趣的族语</p><p>N: “Winter is coming” “凛冬将至”</p><p>N: Now that`s memorable. 这才让人过目不忘</p><p>N: “We do not sow.” Strong. Strong. “抢取胜于苦耕” 多么强大</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;T: you`re still here 还不走啊&lt;/p&gt;
&lt;p&gt;S: yes 对&lt;/p&gt;
&lt;p&gt;T: why 为什么&lt;/p&gt;
&lt;p&gt;S: dit lt ever occur to you that I might be the one who deserves your </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于vim的几种使用</title>
    <link href="http://example.com/2022/04/01/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2022/04/01/%E5%85%B3%E4%BA%8Evim%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-01T03:43:30.000Z</published>
    <updated>2022-04-01T10:48:34.655Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>清空全部内容</p><p>例如我们在打开一个.txt文件时，想清除这个.txt文件，可以发现<code>Ctrl+A</code>是无法使用的，这时候我们可以先按<code>Esc</code>键然后输入冒号，键入<strong>0,$d</strong>即可清除全部内容</p></li><li><p>显示或不显示行号</p><p>使用命令<code>set number</code>为显示行号，使用命令<code>set nonumber</code>为不显示行号</p></li><li><p>删除字符</p><p>要删除一个字符，只需要将光标移动到该字符上按下<code>x</code></p></li><li><p>删除一行</p><p>删除一整行内容使用<code>dd</code>命令，删除后后面的行会移动上来填补空缺</p></li><li><p>撤销</p><p>如果你误删了过多的内容。显然你可以再输入一遍，但是命令<code>u</code>更简便，它可以撤消上一次的操作</p></li><li><p>追加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;i&quot;命令可以在当前光标之前插入文本。</span><br><span class="line">  &quot;a&quot;命令可以在当前光标之后插入文本。</span><br><span class="line">  &quot;o&quot;命令可以在当前行的下面另起一行，并使当前模式转为Insert模式。</span><br><span class="line">  &quot;O&quot;命令(注意是大写的字母O)将在当前行的上面另起一行</span><br></pre></td></tr></table></figure></li><li><p>退出</p><p>要退出Vim，用命令<code>ZZ</code>。该命令保存当前文件并退出Vim</p></li></ol><p>以上内容参考自: <a class="link"   href="https://www.cnblogs.com/cy0628/p/13888577.html" >https://www.cnblogs.com/cy0628/p/13888577.html<i class="fas fa-external-link-alt"></i></a></p><p>内容还不完整，如需了解更多请点击链接，给定的这个链接还是比较全面的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;清空全部内容&lt;/p&gt;
&lt;p&gt;例如我们在打开一个.txt文件时，想清除这个.txt文件，可以发现&lt;code&gt;Ctrl+A&lt;/code&gt;是无法使用的，这时候我们可以先按&lt;code&gt;Esc&lt;/code&gt;键然后输入冒号，键入&lt;strong&gt;0,$d&lt;/strong</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于修改Jenkins默认端口(8080)</title>
    <link href="http://example.com/2022/04/01/%E5%85%B3%E4%BA%8E%E4%BF%AE%E6%94%B9Jenkins%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3(8080)/"/>
    <id>http://example.com/2022/04/01/%E5%85%B3%E4%BA%8E%E4%BF%AE%E6%94%B9Jenkins%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3(8080)/</id>
    <published>2022-04-01T03:15:30.000Z</published>
    <updated>2022-04-01T03:23:12.215Z</updated>
    
    <content type="html"><![CDATA[<p>Jenkins的安装请移步: <a class="link"   href="http://kest.club/2022/02/23/ubuntu16%E5%AE%89%E8%A3%85Jenkins/" >http://kest.club/2022/02/23/ubuntu16%E5%AE%89%E8%A3%85Jenkins/<i class="fas fa-external-link-alt"></i></a></p><p>然后下面我们来看看如何修改Jenkins这个默认的端口，主要是我安装爬虫可视化工具CrawLab遇到点问题，所以想着修改下</p><p>总体来说就两步</p><ol><li>使用<code>vim /etc/init.d/jenkins</code>命令，修改<code>do_start</code>函数中的<code>check_tcp_port</code>命令，端口号从8080换成8082或者其他</li><li>使用<code>vim /etc/default/jenkins</code>命令，将断口8080改成8082</li></ol><p>本文参考自: <a class="link"   href="https://www.qieseo.com/217847.html" >https://www.qieseo.com/217847.html<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Jenkins的安装请移步: &lt;a class=&quot;link&quot;   href=&quot;http://kest.club/2022/02/23/ubuntu16%E5%AE%89%E8%A3%85Jenkins/&quot; &gt;http://kest.club/2022/02/23/ubunt</summary>
      
    
    
    
    
  </entry>
  
</feed>
