[{"title":"Python中常用的国内pip源","url":"/2021/12/29/Python%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84pip%E6%BA%90/","content":"在我们下载包的时候，很可能由于网络原因会很卡，这个时候可能需要科学上网，但是我们又没有买节点，或者没有搭建海外服务器，这个时候我们就可以访问一些国内的pip源，这里面和国外上传的pip源几乎是一样的，也是一段时间就会更新:\n\n阿里云: http://mirrors.aliyun.com/pypi/simple/\n中国科学技术大学: https://pypi.mirrors.ustc.edu.cn/simple/\n豆瓣: http://pypi.douban.com/simple/\n清华大学: https://pypi.tuna.tsinghua.edu.cn/simple/\n华中科技大学: http://pypi.hustunique.com/\n\n注意: 新版ubuntu要求使用https源\n","categories":["Database"]},{"title":"Python中pip和pip3的区别","url":"/2021/12/29/Python%E4%B8%ADpip%E5%92%8Cpip3%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"pip是Python的一款很好用的包管理工具，类似于node中的npm，Python有Python2和Python3的区别，那么pip也有pip和pip3的区别,大概是这样的: \n相同点(虽然主要是区别，但还是有相同点的撒):\n\npip和pip3版本不同，但二者都位于Script\\目录下\n\n不同点：\n\n如果系统中只安装了Python2，那么就只能用pip\n如果系统中只安装了Python3，那么既可以使用pip也可以使用pip3，二者是等价的\n如果系统中同时安装了Python2和Python3，则pip默认给Python2使用，pip3默认给Python3使用\n重要: 在虚拟环境中，若只存在一个Python版本，可以认为在用系统中的pip和pip3命令都是相同作用的\n\n"},{"title":"Python中with...as...语句的深度解刨","url":"/2021/12/28/Python%E4%B8%ADwith...as...%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%88%A8/","content":"任何一门编程语言中，文件的输入输出、数据库的连接断开等，都是很常见的资源管理操作。但资源都是有限的，在写程序时，必须保证这些资源在使用过后得到释放，不然就容易造成资源泄露，轻者使得系统处理缓慢，严重时会使系统崩溃。\n例如，前面在介绍文件操作时，一直强调打开的文件最后一定要关闭，否则会程序的运行造成意想不到的隐患。但是，即便使用 close() 做好了关闭文件的操作，如果在打开文件或文件操作过程中抛出了异常，还是无法及时关闭文件。\n为了更好地避免此类问题，不同的编程语言都引入了不同的机制。在 Python 中，对应的解决方式是使用 with as 语句操作上下文管理器（context manager），它能够帮助我们自动分配并且释放资源，代码示例如下:\nwith open(&quot;test.txt&quot;) as file:    data = file.read()    print(data)# 等价于try:    file = open(&quot;test.txt&quot;)    data = file.read()    print(data)finally:    file.close()\n\nwith…as…语句只会捕获异常而不会处理异常，代码示例如下:\nwith open(&quot;test.txt&quot;) as file:    data = file.read()    print(data)# 若没有test.txt，会出现以下错误,程序会就此停下，说明并不会处理异常FileNotFoundError Traceback (most recent call last)&lt;ipython-input-4-bf5e860f28d5&gt; in &lt;module&gt;      1 try:----&gt; 2     file = open(&quot;test.txt&quot;)      3     data = file.read()      4     print(data)      5 # except Exception as err:FileNotFoundError: [Errno 2] No such file or directory: &#x27;test.txt&#x27;\n\n"},{"title":"Python如何升级pip,以及如何查看pip版本","url":"/2021/12/29/Python%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7pip,%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bpip%E7%89%88%E6%9C%AC/","content":"有些时候我们用pip安装包的时候会报红提示说安装失败，也有时候会出现一串黄色的警告说pip版本太低，这个时候我们可能就该考虑升级下pip，升级pip会获得更好的体验然后很多新的包也会收录在新版本的pip下，我们来看下如何升级: \n\n打开命令行键入以下命令:\npip3 install --upgrade pip -i &quot;https://pypi.mirrors.ustc.edu.cn/simple&quot;\n\n对以上命令做下解释:\n\npip3: 如果在系统中既有Python2又有Python3那么且两个都有pip工具,pip3就是为Python3服务\n-i: 指定包的源\n\n\n\n"},{"title":"Python每个版本都自带pip嘛,以及如何安装pip","url":"/2021/12/29/Python%E6%AF%8F%E4%B8%AA%E7%89%88%E6%9C%AC%E9%83%BD%E8%87%AA%E5%B8%A6pip%E5%98%9B,%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85pip/","content":"pip是Python的包管理工具，该工具提供了对Python包的查找、下载、安装、以及卸载的功能，目前如果你在Python.org下载最新版本的安装包，则是已经自带了该工具，Python2.7.9+或者Python3.4+以上版本都自带pip工具(通常跟wheel.exe在同一个目录下)\n下面讲讲如果安装的时候没有自带pip工具那么如何安装pip工具：\n\n访问https://bootstrap.pypa.io/get-pip.py这个网址，然后Ctrl+S将get-pip.py文件保存到你所安装的Python的Script目录下\n然后进入Script目录，并且在该目录下进入下命令行界面\n在命令行界面输入python get-pip.py，pip3工具就会自动安装\n安装成功之后输入python -m pip –version，确保成功安装了pip\n\n"},{"title":"Python如何修改pip源","url":"/2021/12/29/Python%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9pip%E6%BA%90/","content":"如果每次都pip用-i指定源会比较麻烦，我们可以把某个国内源设置为默认，这样下次就会从默认源里面寻找包并且下载，来看看如何设为默认:\n在命令行中键入以下命令:\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n\n以上以清华源的为例\n"},{"title":"Python类中call函数的作用","url":"/2021/12/25/Python%E7%B1%BB%E4%B8%ADcall%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/","content":"本节再介绍 Python类中一个非常特殊的实例方法，即 call()。该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用，一句话总结: call函数可以把类变成函数来调用\nclass Demo():    def __init__(self, name):        self.name = name    def __call__(self):        print(self.name)Demo(&#x27;孙悟空&#x27;)() # 输出 孙悟空\n\n在Python中，凡是可以将()直接应用到自身并执行，都称为可调用对象，可调用对象包括自定义的函数，Python内置函数以及这里讲的类实例对象，对于可调用对象，实际上“名称()”可以理解为是“名称.call()”的简写。仍以上面程序中定义的 clangs 实例对象为例，其最后一行代码还可以改写为如下形式：\nclangs.__call__(&quot;C语言中文网&quot;,&quot;http://c.biancheng.net&quot;)\n"},{"title":"Python魔法方法总览","url":"/2021/12/28/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E6%80%BB%E8%A7%88/","content":"关于魔法方法: 使用魔法方法可以使Python的自由度变得更高，当不需要重写魔法方法也可以在规定的默认情况下生效，在需要重写时也可以让使用者根据自己的需求来重写部分方法来达到自己的预期。而且众所周知Python是支持面向对象的语言，其基本魔法方法就使得Python在面向对象方面做得更好。\n今天在CSDN上看到了有一篇文章整理得还不错，讲述了很多魔法方法以及其作用，详情见:https://blog.csdn.net/qq_38520096/article/details/79237593?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164067535716780261982154%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164067535716780261982154&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-8-79237593.first_rank_v2_pc_rank_v29&amp;utm_term=python%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95&amp;spm=1018.2226.3001.4187\n"},{"title":"对Docker的认识","url":"/2021/12/29/%E5%AF%B9Docker%E7%9A%84%E8%AE%A4%E8%AF%86/","content":"首先，Docker是个容器，使用的是宿主机的资源，因为都是Linux，所以内核资源是可以共用的，无论什么发行版，他们的内核都是Linux kernel，所以Docker才能实现，Docker其实只共用了宿主机的内核，然后我们可以在里面安装镜像，运行一个隔离于系统的独立系统，但是默认是不和宿主机发生交互的，如果要使用到宿主机的文件，就要用volumn将宿主机的文件挂载到容器中，让容器可以访问\n现在windows上也可以安装Docker，其实windows上的Docker只是一个客户端，实际上还是开了一个虚拟机跑Linux，然后Linux里再跑Docker\n"},{"title":"Linux(ubuntu)提示command not fonund的解决","url":"/2021/12/29/Linux(ubuntu)%E6%8F%90%E7%A4%BAcommand%20not%20fonund%E7%9A%84%E8%A7%A3%E5%86%B3/","content":"Linux系统中，-bash: wget: comment not found是找不到命令的意思，也就是无法执行下载命令，这是因为系统太干净了，没有安装下载命令的控制器，我们给系统安装个下载命令即可:\nCentOS系统:\nyum install wget -y\n\nDebian/Ubuntu系统:\napt -get install -y wget\n\n"},{"title":"关于入门Go需要知道的几个特性","url":"/2021/12/29/%E5%85%B3%E4%BA%8E%E5%85%A5%E9%97%A8Go%E7%9A%84%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","content":"\ngo的关键字比较少，只有25个，这样可以简化编码过程中的混乱和复杂度\n\ngo没有类和继承的概念，但它通过接口的概念来实现多态\n\ngo支持交叉编译，比如说可以在运行Linux系统的计算机开发能在windows上运行的应用，这是第一门完全支持UTF-8的编程语言，就连他的源码文件格式都是使用UTF-8编码\n\ngo被设计成一门应用与搭载web服务器，存储集群或类似用途的巨型中央服务器的系统编程语言，对于高性能分布式系统领域而言，go有着更高的开发效率，提供了海量并行的支持，这对于游戏服务端的开发最好不过了\n\n尽管go编译器产生的是本地可执行代码，这些代码仍旧运行在go的runtime中，这个runtime类似java和.net所用到的虚拟机，它负责管理包括内存分配，垃圾回收，栈处理、goroutine、channel、切片，map和反射等\n\ngo fmt，这是个工具用来将你的源代码格式化成符合官方统一标准的风格\n\ngo doc，这是个工具从go程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档\n\ngo install, 这是go的包的安装工具，类似Ruby中的rubygems\n\ngo test是一个轻量级的单元测试框架\n\ngo fix用于将你的go代码从旧的发行版迁移到最新的发行版\n\ncgo提供了对FFI(外部函数接口)的支持，能够使用go代码安全地调用c语言库，cgo会代替go编译器来产生可以组合在同一个包中的go和c代码\n\n在go代码中使用c语言需要用import&quot;C&quot;来导入，一般还需要import&quot;unsafe&quot;,然后你可以在import&quot;C&quot;之前使用注释(但行或多行注释均可)的形势导入C语言库(甚至有效的C语言代码)，注意他们之间没有空格\n\n左大括号需要放在函数定义这一行\n\nfmt.Println和fmt.Print只差了一个空格\n2021-12-29 18:08:20\n\n\n"},{"title":"在Docker中安装Python3.7","url":"/2021/12/29/%E5%9C%A8Docker%E4%B8%AD%E5%AE%89%E8%A3%85Python3.7/","content":"详情见: \nhttps://www.icode9.com/content-1-120863.html\n"},{"title":"如何在ubuntu16中安装Python","url":"/2021/12/29/%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu16%E4%B8%AD%E5%AE%89%E8%A3%85Python/","content":"详情见:(我这采用的是第二种方法)https://www.runoob.com/docker/ubuntu-docker-install.html\n"},{"title":"查看Docker是否安装成功以及使用Docker安装nginx","url":"/2021/12/29/%E6%9F%A5%E7%9C%8BDocker%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8Docker%E5%AE%89%E8%A3%85nginx/","content":"\n检查是否安装成功\n使用命令:\ndocker ps\n\n使用docker搜索nginx:\n使用命令:\ndocker search nginx\n使用 docker安装nginx:\n使用命令:\ndocker pull nginx\n\n运行nignx:\n使用命令:\ndocker run nginx\n检查Docker是否安装成功可以使用命令:\ndocker version\n\n有client和service两部分表示docker安装启动都成功了\n\n\n"},{"title":"LeetCode最大回文子串","url":"/2021/12/30/Leetcode%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","content":"动态规划:\n对于一个字串而言，如果它是回文串，并且长度大于2，那么将它首位的两个字母去掉之后，它仍然是个回文串，根据这个思路，我们就可以用动态规划的方法解决本题，我们用s[i, j]表示字符串s的第i个到第j个字母组成的串是否为回文串:\n我们可以得到只有s[i+1, j-1]是回文串，并且s的第i个和第j个字母相同时，s[i, j]才会是回文串\n上文所有讨论都是建立在字串长度大于2的前提上的，我们还需要考虑动态规划中的边界条件，就是字串的长度为1或2。对于长度为1的字串，他显然是个回文串，对于长度为2的字串，只要它的两个字母相同，他就是一个回文串，因此我们就可以得到动态规划的边界条件\nclass Solution:    def longestPalindrome(self, s: str) -&gt; str:        n = len(s)        if n &lt; 2:            return s                max_len = 1        begin = 0        # dp[i][j] 表示 s[i..j] 是否是回文串        dp = [[False] * n for _ in range(n)]        for i in range(n):            dp[i][i] = True                # 递推开始        # 先枚举子串长度        for L in range(2, n + 1):            # 枚举左边界，左边界的上限设置可以宽松一些            for i in range(n):                # 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得                j = L + i - 1                # 如果右边界越界，就可以退出当前循环                if j &gt;= n:                    break                                    if s[i] != s[j]:                    dp[i][j] = False                 else:                    if j - i &lt; 3:                        dp[i][j] = True                    else:                        dp[i][j] = dp[i + 1][j - 1]                                # 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置                if dp[i][j] and j - i + 1 &gt; max_len:                    max_len = j - i + 1                    begin = i        return s[begin:begin + max_len]\n\n\n\n"},{"title":"Scrapy添加User-agent的方法","url":"/2021/12/30/Scrapy%E6%B7%BB%E5%8A%A0User-agent%E7%9A%84%E6%96%B9%E6%B3%95/","content":"\n直接在spider中指定，比如在Scrapy项目中有一个项目grasp_baidu:\nimport scrapyclass graspbaidu(scrapy.Spider):    name = &#x27;graspbaidu&#x27;    allowed_domians = [&#x27;www.baidu.com&#x27;]    start_urls = [&quot;http//:www.baidu.com&quot;]    def parse(self, response):        self.logger.debug(response.text)\n\n这里的start_urls会默认由scrapy自带的start_request处理，然后再交给parse函数，我们就可以重写个start_request，然后里面带个UA即可，比如：\ndef start_request(self):    for i in range(1, 2):    url = ff&#x27;https://api2.fx361.com/JunJiProject/JUNJI_012_001/getSearchList?bkpagesize=14&amp;pagesize=30&amp;keyword=%E7%9B%91%E7%90%86%E5%88%9B%E6%96%B0&amp;pageIndex=&#123;i&#125;&amp;fragmentSize=150&#x27;    req = scrapy.Request(url, callback=self.parse, dont_filter=True, headers=self.headers)\n在配置文件settings.py中设置(一劳永逸):\n将settings.py中的USER_AGENT修改一下即可\n\n如果想修改的更加灵活，比如设置随机的Ua，那就需要如下用到一个库:\nfrom fake_useragent import UserAgent\n\n然后需要在middlewares.py文件中添加一个RandomUserAgentMiddleware的类，如下:\nclass RandomUserAgentMiddleware(object):    # 随机更换 user_agent    def __init__(self,srawler):        super(RandomUserAgentMiddleware,self).__init__()        self.ua = UserAgent()    @classmethod    def from_crawler(cls,crawler):        return cls(crawler)     def process_request(self,request,spider):        def get_ua():        request.headers.setdefault(&#x27;User-Agent&#x27;,self.ua.random)        \n\n然后后我们在settings.py中调用这个中间件:\nDOWNLOADER_MIDDLEWARES = &#123;    &#x27;scrapy.contrib.downloadermiddleware.useragent.UserAgentMiddleware&#x27;: None,    &#x27;scrapydownloadertest.middlewares.RandomUserAgentMiddleware&#x27;: 543,&#125;\n\n"},{"title":"关于协程记录一下","url":"/2021/01/01/%E5%85%B3%E4%BA%8E%E5%8D%8F%E7%A8%8B%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B/","content":"\n\n什么是可迭代对象:\n可迭代对象(iterable): Python中的任意对象，只要它定义了可以返回一个迭代器的__iter__方法，或者定义了可以支持下标索引的__gititem__方法这两个魔法方法，那么他就是一个可迭代对象，简单说，可迭代对象就是能提供迭代器的任意对象,常见的可迭代对象有:字符串，列表，字典，元组等。\nfrom collections.abc import Iterable, Iterator, Generatorstr_1 = &#x27;sixkery&#x27;print(&#x27;字符串是否是可迭代对象：&#x27;,isinstance(str_1,Iterable))print(&#x27;字符串是否是迭代器：&#x27;,isinstance(str_1,Iterator))print(&#x27;字符串是否是生成器：&#x27;,isinstance(str_1,Generator))list_1 = [1,2,3,4]print(&#x27;列表是否是可迭代对象：&#x27;,isinstance(list_1,Iterable))print(&#x27;列表是否是迭代器：&#x27;,isinstance(list_1,Iterator))print(&#x27;列表是否是生成器：&#x27;,isinstance(list_1,Generator))dict_1 = &#123;&#x27;name&#x27;:&#x27;小沐&#x27;,&#x27;age&#x27;:23&#125;print(&#x27;字典是否是可迭代对象：&#x27;,isinstance(dict_1,Iterable))print(&#x27;字典是否是迭代器：&#x27;,isinstance(dict_1,Iterator))print(&#x27;字典是否是生成器：&#x27;,isinstance(dict_1,Generator))\n\n以上都是可迭代对象，可以使用方法dir()查看是否有__iter__来判断一个变量是否是可迭代对象，可迭代对象都可以使用for循环\nif &#x27;__iter__&#x27; in dir(list()):\tprint(&#x27;list是可迭代对象&#x27;)\n什么是迭代器\n迭代器，是在可迭代对象的基础上实现的，创建一个迭代器，首先要用一个可迭代对象:\n用iter()方法即可把可迭代对象转化为迭代器：\nstr_1 = &#x27;asdfg&#x27; # 字符串，是可迭代对象alterator = iter(str_1) # 通过方法 iter() 把字符串变成迭代器print(&#x27;是否成功转换成迭代器:&#x27;,isinstance(alterator,Iterator))\n\n迭代器比可迭代对象多了一个函数next(),我们可以用它来获取元素，for循环也是支持的,这是因为在迭代器内部实现了__next__方法：\nnext(alterator)# &#x27;a&#x27;\n\nfor i in alterator:    print(i)# ...\n生成器:\n之所以引入生成器，是为了实现一个在计算下一个值时不需要浪费空间的结构，通常我们使用列表，即使很大一个列表在一开始也得生成，如果能需要使用的时候自动生成下一个那就节省了很大空间\n之前说的迭代器，是在可迭代对象的基础上加了一个next方法，而生成器是在迭代器的基础上，再实现了yield,所以生成器也可以使用for和next()\nyield是啥呢?它相当于我们函数中的return，在每次next(),或者for循环便利的时候，都会在yield的地方将新的值返回回去，并在这里阻塞，等待下一次的调用，正是有了这个机制，才使得生成器在Python中大放异彩，实现节省内存，实现异步编程。\n\n将列表生成式的中括号改成小括号就是一个生成器啦：\na = (x*x for x in range(1,5))next(a)# 1a = (x*x for x in range(1,5))print(&#x27;是否是生成器：&#x27;,isinstance(a,Generator))# 是否是生成器： True\n实现生成器函数(yield)：\ndef my_gen(n):    a = 0    while a &lt; n:        yield a        a += 1if __name__ == &#x27;__main__&#x27;:    gen = my_gen(5)    print(&#x27;是否是生成器：&#x27;,isinstance(gen,Generator))    for i in gen:        print(i)    # 是否是生成器： True01234\n生成器的执行状态，生成器在其生命周期中，会有以下四个状态:\n\nGEN_CREATED: 等待开始执行\nGEN_RUNNING: 解释器正在执行(只有在多线程应用中才能看到这个状态)\nGEN_SUSPENDED: 在yield表达式处暂停\nGEN_CLOSED: 执行结束\n\nfrom inspect import getgeneratorstatedef my_gen(n):    a = 0    while a &lt; n:        yield a        a += 1if __name__ == &#x27;__main__&#x27;:    gen = my_gen(5)    print(getgeneratorstate(gen)) # 等待开始执行        print(next(gen))    print(getgeneratorstate(gen)) # 在 yield 表达式出暂停        print(next(gen))    gen.close() # 手动关闭结束生成器    print(getgeneratorstate(gen)) # 执行结束GEN_CREATED0GEN_SUSPENDED1GEN_CLOSED\n生成器的异常处理\n在生成器工作中，若生成器不满足生成元素的条件，获取没有元素生产了，就会抛出异常(Stopiteration)\na = (x*x for x in range(1,3))next(a)next(a)next(a)\n\n---------------------------------------------------------------------------StopIteration                             Traceback (most recent call last)&lt;ipython-input-50-0f82892640d1&gt; in &lt;module&gt;()      2 next(a)      3 next(a)----&gt; 4 next(a)StopIteration: \n\n所以在定义生成器时，要考虑这个问题，在不满足生产元素条件的时候，抛出异常:\ndef my_gen(n):    a = 0    while a &lt; n:        yield a        a += 1    raise StopIterationif __name__ == &#x27;__main__&#x27;:    gen = my_gen(2)    next(gen)    next(gen)    next(gen)\n\n不过如果用for循环遍历生成器就不会抛出异常\n\n\n\n从生成器过渡到协程: yield\n通过上面的介绍，我们知道了生成器为我们引入了暂停函数执行(yield)的功能，当我们有了暂停函数的功能之后，就想能不能在生成器暂停的时候向生成器发送一点东西(gen.send(None)),这种机制催生了携程的诞生\n协程: 协程是为非抢占式多任务产生子程序组件的，协程允许不同入口点在不同位置暂停或开始执行任务\n从本质上来看，协程并不属于某种语言的概念，而是编程模型上的概念\n协程和线程一样都能交叉串行执行任务，但是线程频繁加锁解锁，线程切换。协程只要在yield暂停处把任务交到别处执行，协程还是很有发展潜力的\ndef fn(n):    a = 0    while a &lt; n:        jump = yield a        if jump is None:            jump = 1        a += jump        if __name__ == &#x27;__main__&#x27;:    itr = fn(5)    print(next(itr))    print(itr.send(2))\n\n02\n\nyield a 是将a返回出去\njump = yield 是接收传递进来的值\n\n\n"},{"title":"Python对象引用,可变性和垃圾回收机制","url":"/2021/12/30/Python%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8,%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","content":"\n\nPython中的变量到底是什么\nPython的变量实质上是一个指针:\n\n事先没有预定大小，可以是任意类型，比如int,str\n\n可以理解成一个便利贴，可以贴在任何类型上\na = 1a = &#x27;tyu&#x27;\n\n可以理解成一个便利贴，a贴在1上\n注意:\n\n是先生成对象，然后再贴\n不需要声明类型\n\n看一个例子:\na = [1, 2, 3]\nb = a\nb.append(4)\nprint(a)\n输出：[1, 2, 3, 4]\n结论: a和b贴在了同一个地方\n判断一下a和b是不是同一个对象\na = [1,2,3]b = [1,2,3]print(a is b)# 输出：True\n\n再判断一下a和b是不是同一个内存地址:\na = [1,2,3]b = [1,2,3]print(id(a),id(b))# 输出：8533576 8533576\n\n\n==和is的区别\nis是判断两个变量引用对象id是否相等\n==用于判断引用变量的值是否相等\n整数:\na = 123456789b = 123456789print(a is b)print(a == b)# 结果：True True\n\n字符串:\na = &#x27;123456789&#x27;b = &#x27;123456789&#x27;print(a is b)print(a == b)# 结果：True True\n\n列表:\na = [1,2,3]b = [1,2,3]print(a is b)print(a == b)# 结果：False True\n\n字典:\na = &#123;&#x27;name&#x27;:&#x27;sixkery&#x27;&#125;b = &#123;&#x27;name&#x27;:&#x27;sixkery&#x27;&#125;print(a is b)print(a == b)# 结果：False True\n\n集合:\na = (1,2)b = (1,2)print(a is b)print(a == b)# 结果：False True\n\n总结:只要对象的值一样，那么a == b的值一定为True\n如果对象的类型为整数或者字符串且值一样，则a == b和a is b的值都为True(负浮点数不符合)\na = -1.0b = -1.0print(a is b)print(a == b)# 结果：False True\ndel语句和垃圾回收\nPython中垃圾回收算法是: 引用计数\na = 1 # 1 的计数器上加一b = a # 1 的计数器上再加一del a # 计数器减一print(b)print(a)# 结果：1Traceback (most recent call last):   File &quot;e:/python/test.py&quot;, line 8, in &lt;module&gt;    print(a) NameError: name &#x27;a&#x27; is not defined\n\n当计数器加为0的时候，Python就会把1回收，不占用内存\n\n\n"},{"title":"Python之多线程","url":"/2021/12/30/Python%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"多个任务可以由多进程完成，也可以由一个进程内的多线程完成。\n一个进程由多个线程组成，一个进程至少有一个线程。\n由于线程是操作系统直接支持的单元，因此，高级语言都内置多线程的支持，Python也不例外，并且Python的线程是真正Posix Thread，不是模拟出来的线程。\nPython的标准库提供了两个模块:_thread和threading，_thread是低级模块，threading是高级模块。绝大多数的情况下，我们只用threading就够了。\n启动一个线程就是把函数传入并创建Thread实例,然后调用start(),函数开始执行就可以了:\nimport timeimport threading #线程执行的代码def loop():    print(&#x27;thread %s is running&#x27; % threading.current_thread().name)    n = 0    while n &lt; 5:        n += 1        print(&#x27;thread %s &gt;&gt;&gt; %s&#x27; % (threading.current_thread().name,n))        time.sleep(1)    print(&#x27;thread %s end&#x27; % threading.current_thread().name) print(&#x27;thread %s is running...&#x27; % threading.current_thread().name)t = threading.Thread(target=loop,name=&#x27;LoopTread&#x27;)t.start()t.join()print(&#x27;thread %s end&#x27; % threading.current_thread().name)\n\n运行结果:\nthread MainThread is running...thread LoopTread is runningthread LoopTread &gt;&gt;&gt; 1thread LoopTread &gt;&gt;&gt; 2thread LoopTread &gt;&gt;&gt; 3thread LoopTread &gt;&gt;&gt; 4thread LoopTread &gt;&gt;&gt; 5thread LoopTread endthread MainThread end\n\n由于任何进程都会默认开启一个线程，我们把该线程称为主线程，主线程又可以开启新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例；主线程实例的名字叫Main Thread，子线程的名字在创建的时候指定，我们用LoopThread命名子线程,名字仅仅在打印的时候用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1,Thread-2\nLock\n多进程和多线程最大的不同在于，多进程中，同一个变量，各自有一份拷贝到每个进程，互不影响，而线程中，所有变量都是所有线程共享所有，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险就在与多线程同时修改一个变量，把内容给改乱了，举个栗子:\n#假定这是你的银行存款balance = 0 def change_it(n):    #先存后取    global balance    balance += n    balance -= n def run_thread(n):    for i in range(100000):        change_it(n) t1 = threading.Thread(target=run_thread,args=(5,))t2 = threading.Thread(target=run_thread,args=(8,)) t1.start()t2.start()t1.join()t2.join()print(balance)\n\n我们定义了一个共享变量balance，初始化为0，并且启动两个线程，先存后去，理论上结果应该为0，但是由于线程的调度是由操作系统决定的，当t1，t2交替执行时，只要循环次数足够多，balence的结果就不一定是0了，原因是因为高级语言的一条语句在cpu执行的时候是若干条语句，即使一个简单的计算:\nbalance += n\n\n也要分成两步:\n\n计算balance + n结果存到临时变量中\n将临时变量的值赋给balance\n\n究其原因，是因为修改balance需要多条语句，而执行这几条语句时，线程可能中断，从而导致多个线程把一个对象的内容改乱了。\n两个线程同时一存一取，就可能导致余额不对，你肯定不希望你的银行存款莫名其妙地变成了负数，所以我们要确保balance计算正确，就要给change_it()上一把锁，当某个线程开始执行change_it()时，我们说，该线程因为获得了锁，因此其他线程不能同时执行change_it(),只能等待，直到锁被释放后，获得该锁以后才能改。由于锁只有一个，无论多少线程，同一时间最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过threading.Lock()来实现：\nlock = threading.Lock()def run_thread(n):    for i in range(100000):        #先要获取锁        lock.acquire()        try:            #放心改吧            change_it(n)        finally:            #改完记得释放锁哦            lock.release()\n\n当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。\n获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally…来确保锁一定会被释放。\n\n锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行\n坏处当然也很多，首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。\n其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。\n\n多核CPU\n如果你拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。\n如果写一个死循环的话，会出现什么情况呢？\n打开Mac OS X的Activity Monitor，或者Windows的TaskManager，都可以监控某个进程的CPU使用率，我们可以监控到一个死循环线程会100%占用一个CPU。如果有两个死循环线程，再多核CPU中，可以监控到会占用200%的CPU，就是占用两个CPU核心。如果想把N核CPU的核心全部跑满，就必须启动N个死循环线程，在Python中真的如此嘛?\n试试用Python写个死循环:\nimport threading, multiprocessing def loop():    x = 0    while True:        x = x ^ 1 for i in range(multiprocessing.cpu_count()):    t = threading.Thread(target=loop)    t.start()\n\n启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核，但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？\n因为Python的线程虽然是真正的 线程，但解释器在执行代码时，有一个GIL锁: Global Interpreter Lock,任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。\nGIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。\n所以，在Python中，可以使用多线程，但不要指望能有效利用多核，如果一定要通过多线程利用多核，那就只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。\n不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自的独立的GIL锁，互不影响。\n"},{"title":"Python图片灰度处理","url":"/2021/12/30/Python%E5%9B%BE%E7%89%87%E7%81%B0%E5%BA%A6%E5%A4%84%E7%90%86/","content":"Python的PIL库为我们提供了一些操作图片的方法，我们可以用这些把图片处理成我们想要的样子，比如把图片变模糊，或者改变大小，还有就是今天我们要讲的把图片变成漫画或者说素描的风格:\nfrom PIL import Imageimport numpy as npa = np.asarray(Image.open(&#x27;1.jpg&#x27;).convert(&#x27;L&#x27;)).astype(&#x27;float&#x27;)depath = 10 # (0-100)grad = np.gradient(a)# 取图像灰度的梯度值grad_x,grad_y = grad # 分别取横纵图像梯度值grad_x = grad_x * depath / 100.grad_y = grad_y * depath / 100.A = np.sqrt(grad_x ** 2 + grad_y ** 2 + 1.)uni_x = grad_x / Auni_y = grad_y / Auni_z = 1. / Avec_el = np.pi / 2.2 # 光源的俯视角度，弧度值vec_az = np.pi / 4 # 光源的方位角度，弧度值dx = np.cos(vec_el) * np.cos(vec_az) # 光源对 x 轴的影响dy = np.cos(vec_el) * np.sin(vec_az) # 光源对 y 轴的影响dz = np.sin(vec_el) # 光源对 z 轴的影响b = 255 * (dx * uni_x + dy * uni_y + dz * uni_z) # 光源归一化b = b.clip(0,255)im = Image.fromarray(b.astype(&#x27;uint8&#x27;)) # 重构图像im.save(&#x27;2.jpg&#x27;)\n\n"},{"title":"Python之多进程","url":"/2021/12/30/Python%E4%B9%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/","content":"要让Python实现多进程(multiprocessing),我们先来了解下操作系统相关知识, Unix和Linux操作系统提供了一个fork()函数系统调用，它非常特殊，普通的函数，调用一次它执行一次，但是fork()函数调用一次执行两次，因为操作系统自动把当前进程(称为父进程)复制了一份(称为子进程)，然后，分别在子进程和父进程中执行，子进程永远返回0，而父进程返回子进程的ID，而子进程只要调用getpid()就可以拿到父进程的ID。Python中os模块封装了常见的系统调用，其中就包括fork(),可以在Python程序中轻松创建子程序：\nimport os print(&#x27;Process (%s) start ...&#x27; % os.getpid())#Only work on Unix/linux/Mac#不能在Windows平台上运行pid = os.fork()if pid == 0:    print(&#x27;I am child process (%) and my parent is %s.&#x27; % (os.getpid(),os.getppid()))else:    print(&#x27;I (%) just created a child process (%).&#x27; % (os.getpid(),pid))\n\n运行结果:\nProcess (876) start...I (876) just created a child process (877).I am child process (877) and my parent is 876.\n\n由于windows平台下没有fork()函数调用，多以代码没有办法在windows平台下运行，有了fork调用，一个进程在接到任务的时候就可以复制出来一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出新的子进程来处理新的http请求。\nmultiprocessing(多进程)\n如果你想写多进程的服务程序，Unix/LInix平台最好了，当然也可以在Windows平台下来编写，因为Python跨平台，multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块提供了一个Process类来代表一个进程对象，下面一个例子来演示启动一个进程并等待结束的例子：\nimport osfrom multiprocessing import Process #子进程要执行的代码def run_proc(name):    print(&#x27;Run child process %s (%s)&#x27; % (name,os.getpid())) if __name__ == &#x27;__main__&#x27;:    print(&#x27;parent process %s&#x27; % os.getpid())    p = Process(target=run_proc,args=(&#x27;test&#x27;,))#创建子程序    print(&#x27;Child process will start&#x27;)    p.start()#子程序开始执行    p.join()    print(&#x27;Child process end.&#x27;)\n\n\n创建子程序时，只需要传入衣蛾执行的函数和函数的参数\n\n创建一个Process实例，用start()方式开启，这样创建的进程比fork还简单\n\njoin()方法可以等join子进程执行完后再继续往下运行，通常用于进程之间的同步\n\n如果想要启动大量的子进程，可以用进程池的方式批量创建子进程，如下所示：\nimport os,time,randomfrom multiprocessing import Pool def long_time_task(name):    print(&#x27;Run task %s (%s)...&#x27; % (name,os.getpid()))    start = time.time()    time.sleep(random.random() * 3)    end = time.time()    print(&#x27;Task %s run %0.2f seconds.&#x27; % (name,(end-start))) if __name__ == &#x27;__main__&#x27;:    print(&#x27;Parent process %s.&#x27; % os.getpid())    p = Pool(4)    for i in range(5):        p.apply_async(long_time_task,args=(i,))    print(&#x27;Waiting for all subprocess done...&#x27;)    p.close()    p.join()    print(&#x27;All subprocess done&#x27;)\n\n"},{"title":"Python思维导图","url":"/2021/12/31/Python%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","content":"\n\n原文链接:https://blog.csdn.net/qq_44647926/article/details/90669352?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164090955916780269896755%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=164090955916780269896755&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-13-90669352.first_rank_v2_pc_rank_v29&amp;utm_term=Python&amp;spm=1018.2226.3001.4187\n"},{"title":"什么是宝塔面板","url":"/2021/12/31/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF/","content":"简单来说: 就是装在服务器上的管理面板！\n宝塔面板是一款简单好用的服务器运维面板，简单说来就是一个可视化的面板管理工具，支持一键LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA等100多项服务器管理功能。出错少而且安全，由于宝塔面板既有windows版本也有linux版本，尤其是Linux服务器很多用户不会操作，宝塔是为了让那些不会linux的人使用的，使用宝塔，操作linux更简单，更方便，这里要提醒一下虽然宝塔面板可以安装在物理服务器或者云服务器，虚拟主机无法安装的，但是云服务器基本都是可以安装的。\n大型网站程序都安装在服务器上，服务器用的是Linux系统，进行服务器维护需要记住很多的linux命令，这就比较麻烦；\n面板的好处就是通过一个交互界面就能完成服务器的维护工作，比如更新系统，添加网站，修改设置等等，以前需要记住各种命令，下你在通过面板点点按钮就可以了，省时省力.\n"},{"title":"Docker最详细入门教程","url":"/2022/01/05/Docker%E6%9C%80%E8%AF%A6%E7%BB%86%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/","content":"请参考: http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\n"},{"title":"科学上网教程","url":"/2021/12/31/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/","content":"最近在搭hexo博客的时候在一篇theme配置教程中看到了一个开源的图床项目，里面有关于科学上网的介绍，这里我把它搬出来，详情请点击:https://github.com/Alvin9999/new-pac/wiki\n"},{"title":"推荐一款基于GitHub好用的在线图床工具","url":"/2021/12/31/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%AC%BE%E5%9F%BA%E4%BA%8Egitgub%E5%A5%BD%E7%94%A8%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%9B%BE%E5%BA%8A%E5%B7%A5%E5%85%B7/","content":"这是一款基于GItHubAPI开发的图床神器，图片外链使用jsDriver进行CDN加速，免下载，免安装，打开网站简单配置后即可直接使用，免费，稳定，高效\nPicX官网: https://picx.xpoet.cn/#/upload\nPicXGitHub地址: https://github.com/XPoet/picx\n"}]