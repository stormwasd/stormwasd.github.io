[{"title":"Python中常用的国内pip源","url":"/2021/12/29/Python%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84pip%E6%BA%90/","content":"在我们下载包的时候，很可能由于网络原因会很卡，这个时候可能需要科学上网，但是我们又没有买节点，或者没有搭建海外服务器，这个时候我们就可以访问一些国内的pip源，这里面和国外上传的pip源几乎是一样的，也是一段时间就会更新:\n\n阿里云: http://mirrors.aliyun.com/pypi/simple/\n中国科学技术大学: https://pypi.mirrors.ustc.edu.cn/simple/\n豆瓣: http://pypi.douban.com/simple/\n清华大学: https://pypi.tuna.tsinghua.edu.cn/simple/\n华中科技大学: http://pypi.hustunique.com/\n\n注意: 新版ubuntu要求使用https源\n","categories":["Database"]},{"title":"Python中pip和pip3的区别","url":"/2021/12/29/Python%E4%B8%ADpip%E5%92%8Cpip3%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"pip是Python的一款很好用的包管理工具，类似于node中的npm，Python有Python2和Python3的区别，那么pip也有pip和pip3的区别,大概是这样的: \n相同点(虽然主要是区别，但还是有相同点的撒):\n\npip和pip3版本不同，但二者都位于Script\\目录下\n\n不同点：\n\n如果系统中只安装了Python2，那么就只能用pip\n如果系统中只安装了Python3，那么既可以使用pip也可以使用pip3，二者是等价的\n如果系统中同时安装了Python2和Python3，则pip默认给Python2使用，pip3默认给Python3使用\n重要: 在虚拟环境中，若只存在一个Python版本，可以认为在用系统中的pip和pip3命令都是相同作用的\n\n"},{"title":"Python中with...as...语句的深度解刨","url":"/2021/12/28/Python%E4%B8%ADwith...as...%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E5%88%A8/","content":"任何一门编程语言中，文件的输入输出、数据库的连接断开等，都是很常见的资源管理操作。但资源都是有限的，在写程序时，必须保证这些资源在使用过后得到释放，不然就容易造成资源泄露，轻者使得系统处理缓慢，严重时会使系统崩溃。\n例如，前面在介绍文件操作时，一直强调打开的文件最后一定要关闭，否则会程序的运行造成意想不到的隐患。但是，即便使用 close() 做好了关闭文件的操作，如果在打开文件或文件操作过程中抛出了异常，还是无法及时关闭文件。\n为了更好地避免此类问题，不同的编程语言都引入了不同的机制。在 Python 中，对应的解决方式是使用 with as 语句操作上下文管理器（context manager），它能够帮助我们自动分配并且释放资源，代码示例如下:\nwith open(&quot;test.txt&quot;) as file:    data = file.read()    print(data)# 等价于try:    file = open(&quot;test.txt&quot;)    data = file.read()    print(data)finally:    file.close()\n\nwith…as…语句只会捕获异常而不会处理异常，代码示例如下:\nwith open(&quot;test.txt&quot;) as file:    data = file.read()    print(data)# 若没有test.txt，会出现以下错误,程序会就此停下，说明并不会处理异常FileNotFoundError Traceback (most recent call last)&lt;ipython-input-4-bf5e860f28d5&gt; in &lt;module&gt;      1 try:----&gt; 2     file = open(&quot;test.txt&quot;)      3     data = file.read()      4     print(data)      5 # except Exception as err:FileNotFoundError: [Errno 2] No such file or directory: &#x27;test.txt&#x27;\n\n"},{"title":"Python如何升级pip,以及如何查看pip版本","url":"/2021/12/29/Python%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7pip,%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bpip%E7%89%88%E6%9C%AC/","content":"有些时候我们用pip安装包的时候会报红提示说安装失败，也有时候会出现一串黄色的警告说pip版本太低，这个时候我们可能就该考虑升级下pip，升级pip会获得更好的体验然后很多新的包也会收录在新版本的pip下，我们来看下如何升级: \n\n打开命令行键入以下命令:\npip3 install --upgrade pip -i &quot;https://pypi.mirrors.ustc.edu.cn/simple&quot;\n\n对以上命令做下解释:\n\npip3: 如果在系统中既有Python2又有Python3那么且两个都有pip工具,pip3就是为Python3服务\n-i: 指定包的源\n\n\n\n"},{"title":"Python每个版本都自带pip嘛,以及如何安装pip","url":"/2021/12/29/Python%E6%AF%8F%E4%B8%AA%E7%89%88%E6%9C%AC%E9%83%BD%E8%87%AA%E5%B8%A6pip%E5%98%9B,%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85pip/","content":"pip是Python的包管理工具，该工具提供了对Python包的查找、下载、安装、以及卸载的功能，目前如果你在Python.org下载最新版本的安装包，则是已经自带了该工具，Python2.7.9+或者Python3.4+以上版本都自带pip工具(通常跟wheel.exe在同一个目录下)\n下面讲讲如果安装的时候没有自带pip工具那么如何安装pip工具：\n\n访问https://bootstrap.pypa.io/get-pip.py这个网址，然后Ctrl+S将get-pip.py文件保存到你所安装的Python的Script目录下\n然后进入Script目录，并且在该目录下进入下命令行界面\n在命令行界面输入python get-pip.py，pip3工具就会自动安装\n安装成功之后输入python -m pip –version，确保成功安装了pip\n\n"},{"title":"Python如何修改pip源","url":"/2021/12/29/Python%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9pip%E6%BA%90/","content":"如果每次都pip用-i指定源会比较麻烦，我们可以把某个国内源设置为默认，这样下次就会从默认源里面寻找包并且下载，来看看如何设为默认:\n在命令行中键入以下命令:\npip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\n\n以上以清华源的为例\n"},{"title":"Python类中call函数的作用","url":"/2021/12/25/Python%E7%B1%BB%E4%B8%ADcall%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/","content":"本节再介绍 Python类中一个非常特殊的实例方法，即 call()。该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用，一句话总结: call函数可以把类变成函数来调用\nclass Demo():    def __init__(self, name):        self.name = name    def __call__(self):        print(self.name)Demo(&#x27;孙悟空&#x27;)() # 输出 孙悟空\n\n在Python中，凡是可以将()直接应用到自身并执行，都称为可调用对象，可调用对象包括自定义的函数，Python内置函数以及这里讲的类实例对象，对于可调用对象，实际上“名称()”可以理解为是“名称.call()”的简写。仍以上面程序中定义的 clangs 实例对象为例，其最后一行代码还可以改写为如下形式：\nclangs.__call__(&quot;C语言中文网&quot;,&quot;http://c.biancheng.net&quot;)\n"},{"title":"Python魔法方法总览","url":"/2021/12/28/Python%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E6%80%BB%E8%A7%88/","content":"关于魔法方法: 使用魔法方法可以使Python的自由度变得更高，当不需要重写魔法方法也可以在规定的默认情况下生效，在需要重写时也可以让使用者根据自己的需求来重写部分方法来达到自己的预期。而且众所周知Python是支持面向对象的语言，其基本魔法方法就使得Python在面向对象方面做得更好。\n今天在CSDN上看到了有一篇文章整理得还不错，讲述了很多魔法方法以及其作用，详情见:https://blog.csdn.net/qq_38520096/article/details/79237593?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164067535716780261982154%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164067535716780261982154&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-8-79237593.first_rank_v2_pc_rank_v29&amp;utm_term=python%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95&amp;spm=1018.2226.3001.4187\n"},{"title":"对Docker的认识","url":"/2021/12/29/%E5%AF%B9Docker%E7%9A%84%E8%AE%A4%E8%AF%86/","content":"首先，Docker是个容器，使用的是宿主机的资源，因为都是Linux，所以内核资源是可以共用的，无论什么发行版，他们的内核都是Linux kernel，所以Docker才能实现，Docker其实只共用了宿主机的内核，然后我们可以在里面安装镜像，运行一个隔离于系统的独立系统，但是默认是不和宿主机发生交互的，如果要使用到宿主机的文件，就要用volumn将宿主机的文件挂载到容器中，让容器可以访问\n现在windows上也可以安装Docker，其实windows上的Docker只是一个客户端，实际上还是开了一个虚拟机跑Linux，然后Linux里再跑Docker\n"},{"url":"/2021/12/29/%E5%85%B3%E4%BA%8E%E5%85%A5%E9%97%A8Go%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E7%89%B9%E6%80%A7/","content":""},{"title":"Linux(ubuntu)提示command not fonund的解决","url":"/2021/12/29/Linux(ubuntu)%E6%8F%90%E7%A4%BAcommand%20not%20fonund%E7%9A%84%E8%A7%A3%E5%86%B3/","content":"Linux系统中，-bash: wget: comment not found是找不到命令的意思，也就是无法执行下载命令，这是因为系统太干净了，没有安装下载命令的控制器，我们给系统安装个下载命令即可:\nCentOS系统:\nyum install wget -y\n\nDebian/Ubuntu系统:\napt -get install -y wget\n\n"},{"title":"关于入门Go需要知道的几个特性","url":"/2021/12/29/%E5%85%B3%E4%BA%8E%E5%85%A5%E9%97%A8Go%E7%9A%84%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","content":"\ngo的关键字比较少，只有25个，这样可以简化编码过程中的混乱和复杂度\n\ngo没有类和继承的概念，但它通过接口的概念来实现多态\n\ngo支持交叉编译，比如说可以在运行Linux系统的计算机开发能在windows上运行的应用，这是第一门完全支持UTF-8的编程语言，就连他的源码文件格式都是使用UTF-8编码\n\ngo被设计成一门应用与搭载web服务器，存储集群或类似用途的巨型中央服务器的系统编程语言，对于高性能分布式系统领域而言，go有着更高的开发效率，提供了海量并行的支持，这对于游戏服务端的开发最好不过了\n\n尽管go编译器产生的是本地可执行代码，这些代码仍旧运行在go的runtime中，这个runtime类似java和.net所用到的虚拟机，它负责管理包括内存分配，垃圾回收，栈处理、goroutine、channel、切片，map和反射等\n\ngo fmt，这是个工具用来将你的源代码格式化成符合官方统一标准的风格\n\ngo doc，这是个工具从go程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档\n\ngo install, 这是go的包的安装工具，类似Ruby中的rubygems\n\ngo test是一个轻量级的单元测试框架\n\ngo fix用于将你的go代码从旧的发行版迁移到最新的发行版\n\ncgo提供了对FFI(外部函数接口)的支持，能够使用go代码安全地调用c语言库，cgo会代替go编译器来产生可以组合在同一个包中的go和c代码\n\n在go代码中使用c语言需要用import&quot;C&quot;来导入，一般还需要import&quot;unsafe&quot;,然后你可以在import&quot;C&quot;之前使用注释(但行或多行注释均可)的形势导入C语言库(甚至有效的C语言代码)，注意他们之间没有空格\n\n左大括号需要放在函数定义这一行\n\nfmt.Println和fmt.Print只差了一个空格\n2021-12-29 18:08:20\n\n\n"},{"title":"在Docker中安装Python3.7","url":"/2021/12/29/%E5%9C%A8Docker%E4%B8%AD%E5%AE%89%E8%A3%85Python3.7/","content":"详情见: \nhttps://www.icode9.com/content-1-120863.html\n"},{"title":"如何在ubuntu16中安装Python","url":"/2021/12/29/%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu16%E4%B8%AD%E5%AE%89%E8%A3%85Python/","content":"详情见:(我这采用的是第二种方法)https://www.runoob.com/docker/ubuntu-docker-install.html\n"},{"title":"查看Docker是否安装成功以及使用Docker安装nginx","url":"/2021/12/29/%E6%9F%A5%E7%9C%8BDocker%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8Docker%E5%AE%89%E8%A3%85nginx/","content":"\n检查是否安装成功\n使用命令:\ndocker ps\n\n使用docker搜索nginx:\n使用命令:\ndocker search nginx\n使用 docker安装nginx:\n使用命令:\ndocker pull nginx\n\n运行nignx:\n使用命令:\ndocker run nginx\n检查Docker是否安装成功可以使用命令:\ndocker version\n\n有client和service两部分表示docker安装启动都成功了\n\n\n"},{"title":"LeetCode最大回文子串","url":"/2021/12/30/Leetcode%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","content":"动态规划:\n对于一个字串而言，如果它是回文串，并且长度大于2，那么将它首位的两个字母去掉之后，它仍然是个回文串，根据这个思路，我们就可以用动态规划的方法解决本题，我们用s[i, j]表示字符串s的第i个到第j个字母组成的串是否为回文串:\n我们可以得到只有s[i+1, j-1]是回文串，并且s的第i个和第j个字母相同时，s[i, j]才会是回文串\n上文所有讨论都是建立在字串长度大于2的前提上的，我们还需要考虑动态规划中的边界条件，就是字串的长度为1或2。对于长度为1的字串，他显然是个回文串，对于长度为2的字串，只要它的两个字母相同，他就是一个回文串，因此我们就可以得到动态规划的边界条件\nclass Solution:    def longestPalindrome(self, s: str) -&gt; str:        n = len(s)        if n &lt; 2:            return s                max_len = 1        begin = 0        # dp[i][j] 表示 s[i..j] 是否是回文串        dp = [[False] * n for _ in range(n)]        for i in range(n):            dp[i][i] = True                # 递推开始        # 先枚举子串长度        for L in range(2, n + 1):            # 枚举左边界，左边界的上限设置可以宽松一些            for i in range(n):                # 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得                j = L + i - 1                # 如果右边界越界，就可以退出当前循环                if j &gt;= n:                    break                                    if s[i] != s[j]:                    dp[i][j] = False                 else:                    if j - i &lt; 3:                        dp[i][j] = True                    else:                        dp[i][j] = dp[i + 1][j - 1]                                # 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置                if dp[i][j] and j - i + 1 &gt; max_len:                    max_len = j - i + 1                    begin = i        return s[begin:begin + max_len]\n\n\n\n"}]